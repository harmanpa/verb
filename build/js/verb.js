// Generated by Haxe 4.1.4
(function ($hx_exports, $global) { "use strict";
$hx_exports["eval"] = $hx_exports["eval"] || {};
$hx_exports["core"] = $hx_exports["core"] || {};
$hx_exports["geom"] = $hx_exports["geom"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static strDate(s) {
		switch(s.length) {
		case 8:
			let k = s.split(":");
			let d = new Date();
			d["setTime"](0);
			d["setUTCHours"](k[0]);
			d["setUTCMinutes"](k[1]);
			d["setUTCSeconds"](k[2]);
			return d;
		case 10:
			let k1 = s.split("-");
			return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
		case 19:
			let k2 = s.split(" ");
			let y = k2[0].split("-");
			let t = k2[1].split(":");
			return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
		default:
			throw haxe_Exception.thrown("Invalid date format : " + s);
		}
	}
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static fold(it,f,first) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			first = f(x1,first);
		}
		return first;
	}
}
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
}
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
var ValueType = $hxEnums["ValueType"] = { __ename__ : "ValueType", __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
	,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
};
class Type {
	static createEnum(e,constr,params) {
		let f = Reflect.field(e,constr);
		if(f == null) {
			throw haxe_Exception.thrown("No such constructor " + constr);
		}
		if(Reflect.isFunction(f)) {
			if(params == null) {
				throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
			}
			return f.apply(e,params);
		}
		if(params != null && params.length != 0) {
			throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
		}
		return f;
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let ctorName = enm.__constructs__[e._hx_index];
		let params = enm[ctorName].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
class haxe_IMap {
}
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	get_native() {
		return this.__nativeException;
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_Serializer {
	constructor() {
		this.buf = new StringBuf();
		this.cache = [];
		this.useCache = haxe_Serializer.USE_CACHE;
		this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
		this.shash = new haxe_ds_StringMap();
		this.scount = 0;
	}
	toString() {
		return this.buf.b;
	}
	serializeString(s) {
		let x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	serializeRef(v) {
		let vt = typeof(v);
		let _g = 0;
		let _g1 = this.cache.length;
		while(_g < _g1) {
			let i = _g++;
			let ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	serializeFields(v) {
		let _g = 0;
		let _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	serialize(v) {
		let _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			let v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			let v2 = v;
			if(isNaN(v2)) {
				this.buf.b += "k";
			} else if(!isFinite(v2)) {
				this.buf.b += v2 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v2 == null ? "null" : "" + v2;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				let className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			let c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				let ucount = 0;
				this.buf.b += "a";
				let l = v["length"];
				let _g1 = 0;
				let _g2 = l;
				while(_g1 < _g2) {
					let i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				let d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				let v3 = v;
				let k = v3.keys();
				while(k.hasNext()) {
					let k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v3.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				let v4 = v;
				let _g_head = v4.h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					let i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				let v5 = v;
				let k1 = v5.keys();
				while(k1.hasNext()) {
					let k = k1.next();
					let id = Reflect.field(k,"__id__");
					Reflect.deleteField(k,"__id__");
					this.serialize(k);
					k["__id__"] = id;
					this.serialize(v5.h[k.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				let v6 = v;
				let k2 = haxe_ds_StringMap.keysIterator(v6.h);
				while(k2.hasNext()) {
					let k = k2.next();
					this.serializeString(k);
					this.serialize(v6.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				let v7 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v7.length * 8 / 6));
				this.buf.b += ":";
				let i = 0;
				let max = v7.length - 2;
				let b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					let this1 = new Array(haxe_Serializer.BASE64.length);
					b64 = this1;
					let _g = 0;
					let _g1 = haxe_Serializer.BASE64.length;
					while(_g < _g1) {
						let i = _g++;
						b64[i] = HxOverrides.cca(haxe_Serializer.BASE64,i);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					let b1 = v7.b[i++];
					let b2 = v7.b[i++];
					let b3 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					let b1 = v7.b[i++];
					let b2 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					let b1 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			let e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				let e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]);
			}
			this.buf.b += ":";
			let params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			let _g3 = 0;
			while(_g3 < params.length) {
				let p = params[_g3];
				++_g3;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
}
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = "haxe.Serializer";
Object.assign(haxe_Serializer.prototype, {
	__class__: haxe_Serializer
});
class haxe__$Unserializer_DefaultResolver {
	constructor() {
	}
	resolveClass(name) {
		return $hxClasses[name];
	}
	resolveEnum(name) {
		return $hxEnums[name];
	}
}
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
Object.assign(haxe__$Unserializer_DefaultResolver.prototype, {
	__class__: haxe__$Unserializer_DefaultResolver
});
class haxe_Unserializer {
	constructor(buf) {
		this.buf = buf;
		this.length = buf.length;
		this.pos = 0;
		this.scache = [];
		this.cache = [];
		let r = haxe_Unserializer.DEFAULT_RESOLVER;
		if(r == null) {
			r = new haxe__$Unserializer_DefaultResolver();
			haxe_Unserializer.DEFAULT_RESOLVER = r;
		}
		this.resolver = r;
	}
	readDigits() {
		let k = 0;
		let s = false;
		let fpos = this.pos;
		while(true) {
			let c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	readFloat() {
		let p1 = this.pos;
		while(true) {
			let c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	unserializeObject(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			let k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			let v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	unserializeEnum(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		let nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		let args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	unserialize() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			let name = this.unserialize();
			let cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			let name1 = this.unserialize();
			let e = this.resolver.resolveEnum(name1);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name1);
			}
			return e;
		case 67:
			let name2 = this.unserialize();
			let cl1 = this.resolver.resolveClass(name2);
			if(cl1 == null) {
				throw haxe_Exception.thrown("Class not found " + name2);
			}
			let o = Object.create(cl1.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			let h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			let buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				let s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			let n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			let buf1 = this.buf;
			let a = [];
			this.cache.push(a);
			while(true) {
				let c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					let n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			let h1 = new haxe_ds_StringMap();
			this.cache.push(h1);
			let buf2 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				let s = this.unserialize();
				let value = this.unserialize();
				h1.h[s] = value;
			}
			this.pos++;
			return h1;
		case 99:
			let name3 = this.unserialize();
			let cl2 = this.resolver.resolveClass(name3);
			if(cl2 == null) {
				throw haxe_Exception.thrown("Class not found " + name3);
			}
			let o1 = Object.create(cl2.prototype);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			let name4 = this.unserialize();
			let edecl = this.resolver.resolveEnum(name4);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name4);
			}
			this.pos++;
			let index = this.readDigits();
			let tag = edecl.__constructs__.slice()[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name4 + "@" + index);
			}
			let e1 = this.unserializeEnum(edecl,tag);
			this.cache.push(e1);
			return e1;
		case 107:
			return NaN;
		case 108:
			let l = new haxe_ds_List();
			this.cache.push(l);
			let buf3 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			let o2 = { };
			this.cache.push(o2);
			this.unserializeObject(o2);
			return o2;
		case 112:
			return Infinity;
		case 113:
			let h2 = new haxe_ds_IntMap();
			this.cache.push(h2);
			let buf4 = this.buf;
			let c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				let i = this.readDigits();
				let value = this.unserialize();
				h2.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h2;
		case 114:
			let n1 = this.readDigits();
			if(n1 < 0 || n1 >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n1];
		case 115:
			let len = this.readDigits();
			let buf5 = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			let codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			let i = this.pos;
			let rest = len & 3;
			let size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			let max = i + (len - rest);
			let bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			let bpos = 0;
			while(i < max) {
				let c1 = codes[buf5.charCodeAt(i++)];
				let c2 = codes[buf5.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				let c3 = codes[buf5.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				let c4 = codes[buf5.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				let c1 = codes[buf5.charCodeAt(i++)];
				let c2 = codes[buf5.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					let c3 = codes[buf5.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			let d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			let name5 = this.unserialize();
			let edecl1 = this.resolver.resolveEnum(name5);
			if(edecl1 == null) {
				throw haxe_Exception.thrown("Enum not found " + name5);
			}
			let e2 = this.unserializeEnum(edecl1,this.unserialize());
			this.cache.push(e2);
			return e2;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			let len1 = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len1) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			let s = HxOverrides.substr(this.buf,this.pos,len1);
			this.pos += len1;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	static initCodes() {
		let codes = [];
		let _g = 0;
		let _g1 = haxe_Unserializer.BASE64.length;
		while(_g < _g1) {
			let i = _g++;
			codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
		}
		return codes;
	}
}
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
Object.assign(haxe_Unserializer.prototype, {
	__class__: haxe_Unserializer
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
}
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
}
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	keys() {
		let a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
}
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_ObjectMap.prototype, {
	__class__: haxe_ds_ObjectMap
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	static keysIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return keys[idx - 1];
		}};
	}
}
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
}
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
class verb_Verb {
	static main() {
		console.log("src/verb/Verb.hx:45:","verb 3.0.0");
	}
}
$hxClasses["verb.Verb"] = verb_Verb;
verb_Verb.__name__ = "verb.Verb";
class verb_core_ArrayExtensions {
	static alloc(a,n) {
		if(n < 0) {
			return;
		}
		while(a.length < n) a.push(null);
	}
	static reversed(a) {
		let ac = a.slice();
		ac.reverse();
		return ac;
	}
	static last(a) {
		return a[a.length - 1];
	}
	static first(a) {
		return a[0];
	}
	static spliceAndInsert(a,start,end,ele) {
		a.splice(start,end);
		a.splice(start,0,ele);
	}
	static left(arr) {
		if(arr.length == 0) {
			return [];
		}
		let len = Math.ceil(arr.length / 2);
		return arr.slice(0,len);
	}
	static right(arr) {
		if(arr.length == 0) {
			return [];
		}
		let len = Math.ceil(arr.length / 2);
		return arr.slice(len);
	}
	static rightWithPivot(arr) {
		if(arr.length == 0) {
			return [];
		}
		let len = Math.ceil(arr.length / 2);
		return arr.slice(len - 1);
	}
	static unique(arr,comp) {
		let uniques = [];
		if(arr.length == 0) {
			return uniques;
		}
		uniques.push(arr.pop());
		while(arr.length > 0) {
			let ele = arr.pop();
			let isUnique = true;
			let _g = 0;
			while(_g < uniques.length) {
				let unique = uniques[_g];
				++_g;
				if(comp(ele,unique)) {
					isUnique = false;
					break;
				}
			}
			if(isUnique) {
				uniques.push(ele);
			}
		}
		return uniques;
	}
}
$hxClasses["verb.core.ArrayExtensions"] = verb_core_ArrayExtensions;
verb_core_ArrayExtensions.__name__ = "verb.core.ArrayExtensions";
class verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint {
	constructor(scoreFunction) {
		this.content = [];
		this.scoreFunction = scoreFunction;
	}
	push(element) {
		this.content.push(element);
		this.bubbleUp(this.content.length - 1);
	}
	pop() {
		let result = this.content[0];
		let end = this.content.pop();
		if(this.content.length > 0) {
			this.content[0] = end;
			this.sinkDown(0);
		}
		return result;
	}
	peek() {
		return this.content[0];
	}
	remove(node) {
		let len = this.content.length;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			if(this.content[i] == node) {
				let end = this.content.pop();
				if(i != len - 1) {
					this.content[i] = end;
					if(this.scoreFunction(end) < this.scoreFunction(node)) {
						this.bubbleUp(i);
					} else {
						this.sinkDown(i);
					}
				}
				return;
			}
		}
		throw haxe_Exception.thrown("Node not found.");
	}
	size() {
		return this.content.length;
	}
	bubbleUp(n) {
		let element = this.content[n];
		while(n > 0) {
			let parentN = Math.floor((n + 1.0) / 2) - 1;
			let parent = this.content[parentN];
			if(this.scoreFunction(element) < this.scoreFunction(parent)) {
				this.content[parentN] = element;
				this.content[n] = parent;
				n = parentN;
			} else {
				break;
			}
		}
	}
	sinkDown(n) {
		let length = this.content.length;
		let element = this.content[n];
		let elemScore = this.scoreFunction(element);
		while(true) {
			let child2N = (n + 1) * 2;
			let child1N = child2N - 1;
			let swap = -1;
			let child1Score = 0.0;
			if(child1N < length) {
				let child1 = this.content[child1N];
				child1Score = this.scoreFunction(child1);
				if(child1Score < elemScore) {
					swap = child1N;
				}
			}
			if(child2N < length) {
				let child2 = this.content[child2N];
				let child2Score = this.scoreFunction(child2);
				if(child2Score < (swap == -1 ? elemScore : child1Score)) {
					swap = child2N;
				}
			}
			if(swap != -1) {
				this.content[n] = this.content[swap];
				this.content[swap] = element;
				n = swap;
			} else {
				break;
			}
		}
	}
}
$hxClasses["verb.core.BinaryHeap_verb_core_KdNode_verb_core_MeshIntersectionPoint"] = verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint;
verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.BinaryHeap_verb_core_KdNode_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint
});
class verb_core_Binomial {
	static get(n,k) {
		if(k == 0.0) {
			return 1.0;
		}
		if(n == 0 || k > n) {
			return 0.0;
		}
		if(k > n - k) {
			k = n - k;
		}
		if(verb_core_Binomial.memo_exists(n,k)) {
			return verb_core_Binomial.get_memo(n,k);
		}
		let r = 1;
		let n_o = n;
		let _g = 1;
		let _g1 = k + 1;
		while(_g < _g1) {
			let d = _g++;
			if(verb_core_Binomial.memo_exists(n_o,d)) {
				--n;
				r = verb_core_Binomial.get_memo(n_o,d);
				continue;
			}
			r *= n--;
			r /= d;
			verb_core_Binomial.memoize(n_o,d,r);
		}
		return r;
	}
	static get_no_memo(n,k) {
		if(k == 0) {
			return 1;
		}
		if(n == 0 || k > n) {
			return 0;
		}
		if(k > n - k) {
			k = n - k;
		}
		let r = 1;
		let n_o = n;
		let _g = 1;
		let _g1 = k + 1;
		while(_g < _g1) {
			let d = _g++;
			r *= n--;
			r /= d;
		}
		return r;
	}
	static memo_exists(n,k) {
		if(verb_core_Binomial.memo.h.hasOwnProperty(n)) {
			return verb_core_Binomial.memo.h[n].h.hasOwnProperty(k);
		} else {
			return false;
		}
	}
	static get_memo(n,k) {
		return verb_core_Binomial.memo.h[n].h[k];
	}
	static memoize(n,k,val) {
		if(!verb_core_Binomial.memo.h.hasOwnProperty(n)) {
			let _this = verb_core_Binomial.memo;
			let value = new haxe_ds_IntMap();
			_this.h[n] = value;
		}
		verb_core_Binomial.memo.h[n].h[k] = val;
	}
}
$hxClasses["verb.core.Binomial"] = verb_core_Binomial;
verb_core_Binomial.__name__ = "verb.core.Binomial";
class verb_core_BoundingBox {
	constructor(pts) {
		this.max = null;
		this.min = null;
		this.dim = 3;
		this.initialized = false;
		if(pts != null) {
			this.addRange(pts);
		}
	}
	fromPoint(pt) {
		return new verb_core_BoundingBox([pt]);
	}
	add(point) {
		if(!this.initialized) {
			this.dim = point.length;
			this.min = point.slice(0);
			this.max = point.slice(0);
			this.initialized = true;
			return this;
		}
		let _g = 0;
		let _g1 = this.dim;
		while(_g < _g1) {
			let i = _g++;
			if(point[i] > this.max[i]) {
				this.max[i] = point[i];
			}
			if(point[i] < this.min[i]) {
				this.min[i] = point[i];
			}
		}
		return this;
	}
	addRange(points) {
		let l = points.length;
		let _g = 0;
		let _g1 = l;
		while(_g < _g1) {
			let i = _g++;
			this.add(points[i]);
		}
		return this;
	}
	contains(point,tol) {
		if(tol == null) {
			tol = -1;
		}
		if(!this.initialized) {
			return false;
		}
		return this.intersects(new verb_core_BoundingBox([point]),tol);
	}
	intersects(bb,tol) {
		if(tol == null) {
			tol = -1;
		}
		if(!this.initialized || !bb.initialized) {
			return false;
		}
		let a1 = this.min;
		let a2 = this.max;
		let b1 = bb.min;
		let b2 = bb.max;
		let _g = 0;
		let _g1 = this.dim;
		while(_g < _g1) {
			let i = _g++;
			if(!verb_core_BoundingBox.intervalsOverlap(a1[i],a2[i],b1[i],b2[i],tol)) {
				return false;
			}
		}
		return true;
	}
	clear() {
		this.initialized = false;
		return this;
	}
	getLongestAxis() {
		let max = 0.0;
		let id = 0;
		let _g = 0;
		let _g1 = this.dim;
		while(_g < _g1) {
			let i = _g++;
			let l = this.getAxisLength(i);
			if(l > max) {
				max = l;
				id = i;
			}
		}
		return id;
	}
	getAxisLength(i) {
		if(i < 0 || i > this.dim - 1) {
			return 0.0;
		}
		return Math.abs(this.min[i] - this.max[i]);
	}
	intersect(bb,tol) {
		if(!this.initialized) {
			return null;
		}
		let a1 = this.min;
		let a2 = this.max;
		let b1 = bb.min;
		let b2 = bb.max;
		if(!this.intersects(bb,tol)) {
			return null;
		}
		let maxbb = [];
		let minbb = [];
		let _g = 0;
		let _g1 = this.dim;
		while(_g < _g1) {
			let i = _g++;
			maxbb.push(Math.min(a2[i],b2[i]));
			minbb.push(Math.max(a1[i],b1[i]));
		}
		return new verb_core_BoundingBox([minbb,maxbb]);
	}
	static intervalsOverlap(a1,a2,b1,b2,tol) {
		if(tol == null) {
			tol = -1;
		}
		let tol1 = tol < -0.5 ? verb_core_Constants.TOLERANCE : tol;
		let x1 = Math.min(a1,a2) - tol1;
		let x2 = Math.max(a1,a2) + tol1;
		let y1 = Math.min(b1,b2) - tol1;
		let y2 = Math.max(b1,b2) + tol1;
		if(!(x1 >= y1 && x1 <= y2 || x2 >= y1 && x2 <= y2 || y1 >= x1 && y1 <= x2)) {
			if(y2 >= x1) {
				return y2 <= x2;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
}
$hxClasses["verb.core.BoundingBox"] = $hx_exports["core"]["BoundingBox"] = verb_core_BoundingBox;
verb_core_BoundingBox.__name__ = "verb.core.BoundingBox";
Object.assign(verb_core_BoundingBox.prototype, {
	__class__: verb_core_BoundingBox
});
class verb_core_Constants {
}
$hxClasses["verb.core.Constants"] = $hx_exports["core"]["Constants"] = verb_core_Constants;
verb_core_Constants.__name__ = "verb.core.Constants";
class verb_core_SerializableBase {
	serialize() {
		let serializer = new haxe_Serializer();
		serializer.serialize(this);
		return serializer.toString();
	}
}
$hxClasses["verb.core.SerializableBase"] = $hx_exports["core"]["SerializableBase"] = verb_core_SerializableBase;
verb_core_SerializableBase.__name__ = "verb.core.SerializableBase";
Object.assign(verb_core_SerializableBase.prototype, {
	__class__: verb_core_SerializableBase
});
class verb_core_Plane extends verb_core_SerializableBase {
	constructor(origin,normal) {
		super();
		this.origin = origin;
		this.normal = normal;
	}
}
$hxClasses["verb.core.Plane"] = $hx_exports["core"]["Plane"] = verb_core_Plane;
verb_core_Plane.__name__ = "verb.core.Plane";
verb_core_Plane.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_Plane.prototype, {
	__class__: verb_core_Plane
});
class verb_core_Ray extends verb_core_SerializableBase {
	constructor(origin,dir) {
		super();
		this.origin = origin;
		this.dir = dir;
	}
}
$hxClasses["verb.core.Ray"] = $hx_exports["core"]["Ray"] = verb_core_Ray;
verb_core_Ray.__name__ = "verb.core.Ray";
verb_core_Ray.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_Ray.prototype, {
	__class__: verb_core_Ray
});
class verb_core_NurbsCurveData extends verb_core_SerializableBase {
	constructor(degree,knots,controlPoints) {
		super();
		this.degree = degree;
		this.controlPoints = controlPoints;
		this.knots = knots;
	}
}
$hxClasses["verb.core.NurbsCurveData"] = $hx_exports["core"]["NurbsCurveData"] = verb_core_NurbsCurveData;
verb_core_NurbsCurveData.__name__ = "verb.core.NurbsCurveData";
verb_core_NurbsCurveData.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_NurbsCurveData.prototype, {
	__class__: verb_core_NurbsCurveData
});
class verb_core_NurbsSurfaceData extends verb_core_SerializableBase {
	constructor(degreeU,degreeV,knotsU,knotsV,controlPoints) {
		super();
		this.degreeU = degreeU;
		this.degreeV = degreeV;
		this.knotsU = knotsU;
		this.knotsV = knotsV;
		this.controlPoints = controlPoints;
	}
}
$hxClasses["verb.core.NurbsSurfaceData"] = $hx_exports["core"]["NurbsSurfaceData"] = verb_core_NurbsSurfaceData;
verb_core_NurbsSurfaceData.__name__ = "verb.core.NurbsSurfaceData";
verb_core_NurbsSurfaceData.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_NurbsSurfaceData.prototype, {
	__class__: verb_core_NurbsSurfaceData
});
class verb_core_MeshData extends verb_core_SerializableBase {
	constructor(faces,points,normals,uvs) {
		super();
		this.faces = faces;
		this.points = points;
		this.normals = normals;
		this.uvs = uvs;
	}
	static empty() {
		return new verb_core_MeshData([],[],[],[]);
	}
}
$hxClasses["verb.core.MeshData"] = $hx_exports["core"]["MeshData"] = verb_core_MeshData;
verb_core_MeshData.__name__ = "verb.core.MeshData";
verb_core_MeshData.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_MeshData.prototype, {
	__class__: verb_core_MeshData
});
class verb_core_PolylineData extends verb_core_SerializableBase {
	constructor(points,params) {
		super();
		this.points = points;
		this.params = params;
	}
}
$hxClasses["verb.core.PolylineData"] = $hx_exports["core"]["PolylineData"] = verb_core_PolylineData;
verb_core_PolylineData.__name__ = "verb.core.PolylineData";
verb_core_PolylineData.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_PolylineData.prototype, {
	__class__: verb_core_PolylineData
});
class verb_core_VolumeData extends verb_core_SerializableBase {
	constructor(degreeU,degreeV,degreeW,knotsU,knotsV,knotsW,controlPoints) {
		super();
		this.degreeU = degreeU;
		this.degreeV = degreeV;
		this.degreeW = degreeW;
		this.knotsU = knotsU;
		this.knotsV = knotsV;
		this.knotsW = knotsW;
		this.controlPoints = controlPoints;
	}
}
$hxClasses["verb.core.VolumeData"] = $hx_exports["core"]["VolumeData"] = verb_core_VolumeData;
verb_core_VolumeData.__name__ = "verb.core.VolumeData";
verb_core_VolumeData.__super__ = verb_core_SerializableBase;
Object.assign(verb_core_VolumeData.prototype, {
	__class__: verb_core_VolumeData
});
class verb_core_Pair {
	constructor(item1,item2) {
		this.item0 = item1;
		this.item1 = item2;
	}
}
$hxClasses["verb.core.Pair"] = $hx_exports["core"]["Pair"] = verb_core_Pair;
verb_core_Pair.__name__ = "verb.core.Pair";
Object.assign(verb_core_Pair.prototype, {
	__class__: verb_core_Pair
});
class verb_core_Interval {
	constructor(min,max) {
		this.min = min;
		this.max = max;
	}
}
$hxClasses["verb.core.Interval"] = $hx_exports["core"]["Interval"] = verb_core_Interval;
verb_core_Interval.__name__ = "verb.core.Interval";
Object.assign(verb_core_Interval.prototype, {
	__class__: verb_core_Interval
});
class verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint {
	constructor(obj,value) {
		this.obj = obj;
		this.value = value;
	}
}
$hxClasses["verb.core.HeapElement_verb_core_KdNode_verb_core_MeshIntersectionPoint"] = verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint;
verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.HeapElement_verb_core_KdNode_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint
});
class verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint {
	constructor(obj,value) {
		this.obj = obj;
		this.value = value;
	}
}
$hxClasses["verb.core.HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint"] = verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint;
verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint
});
class verb_core_CurveCurveIntersection {
	constructor(point0,point1,u0,u1) {
		this.point0 = point0;
		this.point1 = point1;
		this.u0 = u0;
		this.u1 = u1;
	}
}
$hxClasses["verb.core.CurveCurveIntersection"] = $hx_exports["core"]["CurveCurveIntersection"] = verb_core_CurveCurveIntersection;
verb_core_CurveCurveIntersection.__name__ = "verb.core.CurveCurveIntersection";
Object.assign(verb_core_CurveCurveIntersection.prototype, {
	__class__: verb_core_CurveCurveIntersection
});
class verb_core_CurveSurfaceIntersection {
	constructor(u,uv,curvePoint,surfacePoint) {
		this.u = u;
		this.uv = uv;
		this.curvePoint = curvePoint;
		this.surfacePoint = surfacePoint;
	}
}
$hxClasses["verb.core.CurveSurfaceIntersection"] = $hx_exports["core"]["CurveSurfaceIntersection"] = verb_core_CurveSurfaceIntersection;
verb_core_CurveSurfaceIntersection.__name__ = "verb.core.CurveSurfaceIntersection";
Object.assign(verb_core_CurveSurfaceIntersection.prototype, {
	__class__: verb_core_CurveSurfaceIntersection
});
class verb_core_MeshIntersectionPoint {
	constructor(uv0,uv1,point,faceIndex0,faceIndex1) {
		this.visited = false;
		this.adj = null;
		this.opp = null;
		this.uv0 = uv0;
		this.uv1 = uv1;
		this.point = point;
	}
}
$hxClasses["verb.core.MeshIntersectionPoint"] = $hx_exports["core"]["MeshIntersectionPoint"] = verb_core_MeshIntersectionPoint;
verb_core_MeshIntersectionPoint.__name__ = "verb.core.MeshIntersectionPoint";
Object.assign(verb_core_MeshIntersectionPoint.prototype, {
	__class__: verb_core_MeshIntersectionPoint
});
class verb_core_PolylineMeshIntersection {
	constructor(point,u,uv,polylineIndex,faceIndex) {
		this.point = point;
		this.u = u;
		this.uv = uv;
		this.polylineIndex = polylineIndex;
		this.faceIndex = faceIndex;
	}
}
$hxClasses["verb.core.PolylineMeshIntersection"] = $hx_exports["core"]["PolylineMeshIntersection"] = verb_core_PolylineMeshIntersection;
verb_core_PolylineMeshIntersection.__name__ = "verb.core.PolylineMeshIntersection";
Object.assign(verb_core_PolylineMeshIntersection.prototype, {
	__class__: verb_core_PolylineMeshIntersection
});
class verb_core_SurfaceSurfaceIntersectionPoint {
	constructor(uv0,uv1,point,dist) {
		this.uv0 = uv0;
		this.uv1 = uv1;
		this.point = point;
		this.dist = dist;
	}
}
$hxClasses["verb.core.SurfaceSurfaceIntersectionPoint"] = $hx_exports["core"]["SurfaceSurfaceIntersectionPoint"] = verb_core_SurfaceSurfaceIntersectionPoint;
verb_core_SurfaceSurfaceIntersectionPoint.__name__ = "verb.core.SurfaceSurfaceIntersectionPoint";
Object.assign(verb_core_SurfaceSurfaceIntersectionPoint.prototype, {
	__class__: verb_core_SurfaceSurfaceIntersectionPoint
});
class verb_core_TriSegmentIntersection {
	constructor(point,s,t,r) {
		this.point = point;
		this.s = s;
		this.t = t;
		this.p = r;
	}
}
$hxClasses["verb.core.TriSegmentIntersection"] = $hx_exports["core"]["TriSegmentIntersection"] = verb_core_TriSegmentIntersection;
verb_core_TriSegmentIntersection.__name__ = "verb.core.TriSegmentIntersection";
Object.assign(verb_core_TriSegmentIntersection.prototype, {
	__class__: verb_core_TriSegmentIntersection
});
class verb_core_CurveTriPoint {
	constructor(u,point,uv) {
		this.u = u;
		this.point = point;
		this.uv = uv;
	}
}
$hxClasses["verb.core.CurveTriPoint"] = $hx_exports["core"]["CurveTriPoint"] = verb_core_CurveTriPoint;
verb_core_CurveTriPoint.__name__ = "verb.core.CurveTriPoint";
Object.assign(verb_core_CurveTriPoint.prototype, {
	__class__: verb_core_CurveTriPoint
});
class verb_core_SurfacePoint {
	constructor(point,normal,uv,id,degen) {
		if(degen == null) {
			degen = false;
		}
		if(id == null) {
			id = -1;
		}
		this.uv = uv;
		this.point = point;
		this.normal = normal;
		this.id = id;
		this.degen = degen;
	}
	static fromUv(u,v) {
		return new verb_core_SurfacePoint(null,null,[u,v]);
	}
}
$hxClasses["verb.core.SurfacePoint"] = verb_core_SurfacePoint;
verb_core_SurfacePoint.__name__ = "verb.core.SurfacePoint";
Object.assign(verb_core_SurfacePoint.prototype, {
	__class__: verb_core_SurfacePoint
});
class verb_core_CurvePoint {
	constructor(u,pt) {
		this.u = u;
		this.pt = pt;
	}
}
$hxClasses["verb.core.CurvePoint"] = $hx_exports["core"]["CurvePoint"] = verb_core_CurvePoint;
verb_core_CurvePoint.__name__ = "verb.core.CurvePoint";
Object.assign(verb_core_CurvePoint.prototype, {
	__class__: verb_core_CurvePoint
});
class verb_core_KdNode_$verb_$core_$MeshIntersectionPoint {
	constructor(kdPoint,dimension,parent) {
		this.kdPoint = kdPoint;
		this.left = null;
		this.right = null;
		this.parent = parent;
		this.dimension = dimension;
	}
}
$hxClasses["verb.core.KdNode_verb_core_MeshIntersectionPoint"] = verb_core_KdNode_$verb_$core_$MeshIntersectionPoint;
verb_core_KdNode_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.KdNode_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_KdNode_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_KdNode_$verb_$core_$MeshIntersectionPoint
});
class verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint {
	constructor(point,obj) {
		this.point = point;
		this.obj = obj;
	}
}
$hxClasses["verb.core.KdPoint_verb_core_MeshIntersectionPoint"] = verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint;
verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.KdPoint_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint
});
class verb_core_KdTree {
	constructor(points,distanceFunction) {
		this.dim = 3;
		this.points = points;
		this.distanceFunction = distanceFunction;
		this.dim = points[0].point.length;
		this.root = this.buildTree(points,0,null);
	}
	buildTree(points,depth,parent) {
		let dim = depth % this.dim;
		if(points.length == 0) {
			return null;
		}
		if(points.length == 1) {
			return new verb_core_KdNode(points[0],dim,parent);
		}
		points.sort(function(a,b) {
			let diff = a.point[dim] - b.point[dim];
			if(diff == 0.0) {
				return 0;
			} else if(diff > 0) {
				return 1;
			} else {
				return -1;
			}
		});
		let median = Math.floor(points.length / 2);
		let node = new verb_core_KdNode(points[median],dim,parent);
		node.left = this.buildTree(points.slice(0,median),depth + 1,node);
		node.right = this.buildTree(points.slice(median + 1),depth + 1,node);
		return node;
	}
	nearest(point,maxNodes,maxDistance) {
		let _gthis = this;
		let bestNodes = new verb_core_BinaryHeap(function(e) {
			return -e.value;
		});
		let nearestSearch = null;
		nearestSearch = function(node) {
			let bestChild;
			let dimension = node.dimension;
			let ownDistance = _gthis.distanceFunction(point,node.kdPoint.point);
			let _g = [];
			let _g1 = 0;
			let _g2 = _gthis.dim;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(0.0);
			}
			let linearPoint = _g;
			let otherChild;
			let i;
			let saveNode = function(node,distance) {
				bestNodes.push(new verb_core_HeapElement(node,distance));
				if(bestNodes.size() > maxNodes) {
					bestNodes.pop();
				}
			};
			let _g3 = 0;
			let _g4 = _gthis.dim;
			while(_g3 < _g4) {
				let i = _g3++;
				if(i == node.dimension) {
					linearPoint[i] = point[i];
				} else {
					linearPoint[i] = node.kdPoint.point[i];
				}
			}
			let linearDistance = _gthis.distanceFunction(linearPoint,node.kdPoint.point);
			if(node.right == null && node.left == null) {
				if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().value) {
					saveNode(node,ownDistance);
				}
				return;
			}
			if(node.right == null) {
				bestChild = node.left;
			} else if(node.left == null) {
				bestChild = node.right;
			} else if(point[dimension] < node.kdPoint.point[dimension]) {
				bestChild = node.left;
			} else {
				bestChild = node.right;
			}
			nearestSearch(bestChild);
			if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().value) {
				saveNode(node,ownDistance);
			}
			if(bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek().value) {
				if(bestChild == node.left) {
					otherChild = node.right;
				} else {
					otherChild = node.left;
				}
				if(otherChild != null) {
					nearestSearch(otherChild);
				}
			}
		};
		let _g = 0;
		let _g1 = maxNodes;
		while(_g < _g1) {
			let i = _g++;
			bestNodes.push(new verb_core_HeapElement(null,maxDistance));
		}
		nearestSearch(this.root);
		let result = [];
		let _g2 = 0;
		let _g3 = maxNodes;
		while(_g2 < _g3) {
			let i = _g2++;
			if(bestNodes.content[i].obj != null) {
				result.push(new verb_core_HeapElement(bestNodes.content[i].obj.kdPoint,bestNodes.content[i].value));
			}
		}
		return result;
	}
}
$hxClasses["verb.core.KdTree"] = verb_core_KdTree;
verb_core_KdTree.__name__ = "verb.core.KdTree";
Object.assign(verb_core_KdTree.prototype, {
	__class__: verb_core_KdTree
});
class verb_core_BinaryHeap {
	constructor(scoreFunction) {
		this.content = [];
		this.scoreFunction = scoreFunction;
	}
	push(element) {
		this.content.push(element);
		this.bubbleUp(this.content.length - 1);
	}
	pop() {
		let result = this.content[0];
		let end = this.content.pop();
		if(this.content.length > 0) {
			this.content[0] = end;
			this.sinkDown(0);
		}
		return result;
	}
	peek() {
		return this.content[0];
	}
	remove(node) {
		let len = this.content.length;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			if(this.content[i] == node) {
				let end = this.content.pop();
				if(i != len - 1) {
					this.content[i] = end;
					if(this.scoreFunction(end) < this.scoreFunction(node)) {
						this.bubbleUp(i);
					} else {
						this.sinkDown(i);
					}
				}
				return;
			}
		}
		throw haxe_Exception.thrown("Node not found.");
	}
	size() {
		return this.content.length;
	}
	bubbleUp(n) {
		let element = this.content[n];
		while(n > 0) {
			let parentN = Math.floor((n + 1.0) / 2) - 1;
			let parent = this.content[parentN];
			if(this.scoreFunction(element) < this.scoreFunction(parent)) {
				this.content[parentN] = element;
				this.content[n] = parent;
				n = parentN;
			} else {
				break;
			}
		}
	}
	sinkDown(n) {
		let length = this.content.length;
		let element = this.content[n];
		let elemScore = this.scoreFunction(element);
		while(true) {
			let child2N = (n + 1) * 2;
			let child1N = child2N - 1;
			let swap = -1;
			let child1Score = 0.0;
			if(child1N < length) {
				let child1 = this.content[child1N];
				child1Score = this.scoreFunction(child1);
				if(child1Score < elemScore) {
					swap = child1N;
				}
			}
			if(child2N < length) {
				let child2 = this.content[child2N];
				let child2Score = this.scoreFunction(child2);
				if(child2Score < (swap == -1 ? elemScore : child1Score)) {
					swap = child2N;
				}
			}
			if(swap != -1) {
				this.content[n] = this.content[swap];
				this.content[swap] = element;
				n = swap;
			} else {
				break;
			}
		}
	}
}
$hxClasses["verb.core.BinaryHeap"] = verb_core_BinaryHeap;
verb_core_BinaryHeap.__name__ = "verb.core.BinaryHeap";
Object.assign(verb_core_BinaryHeap.prototype, {
	__class__: verb_core_BinaryHeap
});
class verb_core_HeapElement {
	constructor(obj,value) {
		this.obj = obj;
		this.value = value;
	}
}
$hxClasses["verb.core.HeapElement"] = verb_core_HeapElement;
verb_core_HeapElement.__name__ = "verb.core.HeapElement";
Object.assign(verb_core_HeapElement.prototype, {
	__class__: verb_core_HeapElement
});
class verb_core_KdPoint {
	constructor(point,obj) {
		this.point = point;
		this.obj = obj;
	}
}
$hxClasses["verb.core.KdPoint"] = verb_core_KdPoint;
verb_core_KdPoint.__name__ = "verb.core.KdPoint";
Object.assign(verb_core_KdPoint.prototype, {
	__class__: verb_core_KdPoint
});
class verb_core_KdNode {
	constructor(kdPoint,dimension,parent) {
		this.kdPoint = kdPoint;
		this.left = null;
		this.right = null;
		this.parent = parent;
		this.dimension = dimension;
	}
}
$hxClasses["verb.core.KdNode"] = verb_core_KdNode;
verb_core_KdNode.__name__ = "verb.core.KdNode";
Object.assign(verb_core_KdNode.prototype, {
	__class__: verb_core_KdNode
});
class verb_core_KdTree_$verb_$core_$MeshIntersectionPoint {
	constructor(points,distanceFunction) {
		this.dim = 3;
		this.points = points;
		this.distanceFunction = distanceFunction;
		this.dim = points[0].point.length;
		this.root = this.buildTree(points,0,null);
	}
	buildTree(points,depth,parent) {
		let dim = depth % this.dim;
		if(points.length == 0) {
			return null;
		}
		if(points.length == 1) {
			return new verb_core_KdNode_$verb_$core_$MeshIntersectionPoint(points[0],dim,parent);
		}
		points.sort(function(a,b) {
			let diff = a.point[dim] - b.point[dim];
			if(diff == 0.0) {
				return 0;
			} else if(diff > 0) {
				return 1;
			} else {
				return -1;
			}
		});
		let median = Math.floor(points.length / 2);
		let node = new verb_core_KdNode_$verb_$core_$MeshIntersectionPoint(points[median],dim,parent);
		node.left = this.buildTree(points.slice(0,median),depth + 1,node);
		node.right = this.buildTree(points.slice(median + 1),depth + 1,node);
		return node;
	}
	nearest(point,maxNodes,maxDistance) {
		let _gthis = this;
		let bestNodes = new verb_core_BinaryHeap_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint(function(e) {
			return -e.value;
		});
		let nearestSearch = null;
		nearestSearch = function(node) {
			let bestChild;
			let dimension = node.dimension;
			let ownDistance = _gthis.distanceFunction(point,node.kdPoint.point);
			let _g = [];
			let _g1 = 0;
			let _g2 = _gthis.dim;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(0.0);
			}
			let linearPoint = _g;
			let otherChild;
			let i;
			let saveNode = function(node,distance) {
				bestNodes.push(new verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint(node,distance));
				if(bestNodes.size() > maxNodes) {
					bestNodes.pop();
				}
			};
			let _g3 = 0;
			let _g4 = _gthis.dim;
			while(_g3 < _g4) {
				let i = _g3++;
				if(i == node.dimension) {
					linearPoint[i] = point[i];
				} else {
					linearPoint[i] = node.kdPoint.point[i];
				}
			}
			let linearDistance = _gthis.distanceFunction(linearPoint,node.kdPoint.point);
			if(node.right == null && node.left == null) {
				if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().value) {
					saveNode(node,ownDistance);
				}
				return;
			}
			if(node.right == null) {
				bestChild = node.left;
			} else if(node.left == null) {
				bestChild = node.right;
			} else if(point[dimension] < node.kdPoint.point[dimension]) {
				bestChild = node.left;
			} else {
				bestChild = node.right;
			}
			nearestSearch(bestChild);
			if(bestNodes.size() < maxNodes || ownDistance < bestNodes.peek().value) {
				saveNode(node,ownDistance);
			}
			if(bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek().value) {
				if(bestChild == node.left) {
					otherChild = node.right;
				} else {
					otherChild = node.left;
				}
				if(otherChild != null) {
					nearestSearch(otherChild);
				}
			}
		};
		let _g = 0;
		let _g1 = maxNodes;
		while(_g < _g1) {
			let i = _g++;
			bestNodes.push(new verb_core_HeapElement_$verb_$core_$KdNode_$verb_$core_$MeshIntersectionPoint(null,maxDistance));
		}
		nearestSearch(this.root);
		let result = [];
		let _g2 = 0;
		let _g3 = maxNodes;
		while(_g2 < _g3) {
			let i = _g2++;
			if(bestNodes.content[i].obj != null) {
				result.push(new verb_core_HeapElement_$verb_$core_$KdPoint_$verb_$core_$MeshIntersectionPoint(bestNodes.content[i].obj.kdPoint,bestNodes.content[i].value));
			}
		}
		return result;
	}
}
$hxClasses["verb.core.KdTree_verb_core_MeshIntersectionPoint"] = verb_core_KdTree_$verb_$core_$MeshIntersectionPoint;
verb_core_KdTree_$verb_$core_$MeshIntersectionPoint.__name__ = "verb.core.KdTree_verb_core_MeshIntersectionPoint";
Object.assign(verb_core_KdTree_$verb_$core_$MeshIntersectionPoint.prototype, {
	__class__: verb_core_KdTree_$verb_$core_$MeshIntersectionPoint
});
class verb_eval_IBoundingBoxTree {
}
$hxClasses["verb.eval.IBoundingBoxTree"] = verb_eval_IBoundingBoxTree;
verb_eval_IBoundingBoxTree.__name__ = "verb.eval.IBoundingBoxTree";
verb_eval_IBoundingBoxTree.__isInterface__ = true;
Object.assign(verb_eval_IBoundingBoxTree.prototype, {
	__class__: verb_eval_IBoundingBoxTree
});
class verb_core_LazyCurveBoundingBoxTree {
	constructor(curve,knotTol) {
		this._boundingBox = null;
		this._curve = curve;
		if(knotTol == null) {
			let a = this._curve.knots;
			knotTol = (verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a)) / 64;
		}
		this._knotTol = knotTol;
	}
	split() {
		let min = verb_core_ArrayExtensions.first(this._curve.knots);
		let max = verb_core_ArrayExtensions.last(this._curve.knots);
		let dom = max - min;
		let crvs = verb_eval_Divide.curveSplit(this._curve,(max + min) / 2.0 + dom * 0.1 * Math.random());
		return new verb_core_Pair(new verb_core_LazyCurveBoundingBoxTree(crvs[0],this._knotTol),new verb_core_LazyCurveBoundingBoxTree(crvs[1],this._knotTol));
	}
	boundingBox() {
		if(this._boundingBox == null) {
			this._boundingBox = new verb_core_BoundingBox(verb_eval_Eval.dehomogenize1d(this._curve.controlPoints));
		}
		return this._boundingBox;
	}
	yield() {
		return this._curve;
	}
	indivisible(tolerance) {
		let a = this._curve.knots;
		return verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a) < this._knotTol;
	}
	empty() {
		return false;
	}
}
$hxClasses["verb.core.LazyCurveBoundingBoxTree"] = verb_core_LazyCurveBoundingBoxTree;
verb_core_LazyCurveBoundingBoxTree.__name__ = "verb.core.LazyCurveBoundingBoxTree";
verb_core_LazyCurveBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
Object.assign(verb_core_LazyCurveBoundingBoxTree.prototype, {
	__class__: verb_core_LazyCurveBoundingBoxTree
});
class verb_core_LazyMeshBoundingBoxTree {
	constructor(mesh,faceIndices) {
		this._boundingBox = null;
		this._mesh = mesh;
		if(faceIndices == null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = mesh.faces.length;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(i);
			}
			faceIndices = _g;
		}
		this._faceIndices = faceIndices;
	}
	split() {
		let as = verb_core_Mesh.sortTrianglesOnLongestAxis(this.boundingBox(),this._mesh,this._faceIndices);
		let l = verb_core_ArrayExtensions.left(as);
		let r = verb_core_ArrayExtensions.right(as);
		return new verb_core_Pair(new verb_core_LazyMeshBoundingBoxTree(this._mesh,l),new verb_core_LazyMeshBoundingBoxTree(this._mesh,r));
	}
	boundingBox() {
		if(this._boundingBox == null) {
			this._boundingBox = verb_core_Mesh.makeMeshAabb(this._mesh,this._faceIndices);
		}
		return this._boundingBox;
	}
	yield() {
		return this._faceIndices[0];
	}
	indivisible(tolerance) {
		return this._faceIndices.length == 1;
	}
	empty() {
		return this._faceIndices.length == 0;
	}
}
$hxClasses["verb.core.LazyMeshBoundingBoxTree"] = verb_core_LazyMeshBoundingBoxTree;
verb_core_LazyMeshBoundingBoxTree.__name__ = "verb.core.LazyMeshBoundingBoxTree";
verb_core_LazyMeshBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
Object.assign(verb_core_LazyMeshBoundingBoxTree.prototype, {
	__class__: verb_core_LazyMeshBoundingBoxTree
});
class verb_core_LazyPolylineBoundingBoxTree {
	constructor(polyline,interval) {
		this._boundingBox = null;
		this._polyline = polyline;
		if(interval == null) {
			interval = new verb_core_Interval(0,polyline.points.length != 0 ? polyline.points.length - 1 : 0);
		}
		this._interval = interval;
	}
	split() {
		let min = this._interval.min;
		let max = this._interval.max;
		let pivot = min + Math.ceil((max - min) / 2);
		let l = new verb_core_Interval(min,pivot);
		let r = new verb_core_Interval(pivot,max);
		return new verb_core_Pair(new verb_core_LazyPolylineBoundingBoxTree(this._polyline,l),new verb_core_LazyPolylineBoundingBoxTree(this._polyline,r));
	}
	boundingBox() {
		if(this._boundingBox == null) {
			this._boundingBox = new verb_core_BoundingBox(this._polyline.points);
		}
		return this._boundingBox;
	}
	yield() {
		return this._interval.min;
	}
	indivisible(tolerance) {
		return this._interval.max - this._interval.min == 1;
	}
	empty() {
		return this._interval.max - this._interval.min == 0;
	}
}
$hxClasses["verb.core.LazyPolylineBoundingBoxTree"] = verb_core_LazyPolylineBoundingBoxTree;
verb_core_LazyPolylineBoundingBoxTree.__name__ = "verb.core.LazyPolylineBoundingBoxTree";
verb_core_LazyPolylineBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
Object.assign(verb_core_LazyPolylineBoundingBoxTree.prototype, {
	__class__: verb_core_LazyPolylineBoundingBoxTree
});
class verb_core_LazySurfaceBoundingBoxTree {
	constructor(surface,splitV,knotTolU,knotTolV) {
		if(splitV == null) {
			splitV = false;
		}
		this._boundingBox = null;
		this._surface = surface;
		this._splitV = splitV;
		if(knotTolU == null) {
			let a = surface.knotsU;
			knotTolU = (verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a)) / 16;
		}
		if(knotTolV == null) {
			let a = surface.knotsV;
			knotTolV = (verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a)) / 16;
		}
		this._knotTolU = knotTolU;
		this._knotTolV = knotTolV;
	}
	split() {
		let min;
		let max;
		if(this._splitV) {
			min = verb_core_ArrayExtensions.first(this._surface.knotsV);
			max = verb_core_ArrayExtensions.last(this._surface.knotsV);
		} else {
			min = verb_core_ArrayExtensions.first(this._surface.knotsU);
			max = verb_core_ArrayExtensions.last(this._surface.knotsU);
		}
		let dom = max - min;
		let pivot = (min + max) / 2.0;
		let srfs = verb_eval_Divide.surfaceSplit(this._surface,pivot,this._splitV);
		return new verb_core_Pair(new verb_core_LazySurfaceBoundingBoxTree(srfs[0],!this._splitV,this._knotTolU,this._knotTolV),new verb_core_LazySurfaceBoundingBoxTree(srfs[1],!this._splitV,this._knotTolU,this._knotTolV));
	}
	boundingBox() {
		if(this._boundingBox == null) {
			this._boundingBox = new verb_core_BoundingBox();
			let _g = 0;
			let _g1 = this._surface.controlPoints;
			while(_g < _g1.length) {
				let row = _g1[_g];
				++_g;
				this._boundingBox.addRange(verb_eval_Eval.dehomogenize1d(row));
			}
		}
		return this._boundingBox;
	}
	yield() {
		return this._surface;
	}
	indivisible(tolerance) {
		let a = this._surface.knotsV;
		if(verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a) < this._knotTolV) {
			let a = this._surface.knotsU;
			return verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a) < this._knotTolU;
		} else {
			return false;
		}
	}
	empty() {
		return false;
	}
}
$hxClasses["verb.core.LazySurfaceBoundingBoxTree"] = verb_core_LazySurfaceBoundingBoxTree;
verb_core_LazySurfaceBoundingBoxTree.__name__ = "verb.core.LazySurfaceBoundingBoxTree";
verb_core_LazySurfaceBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
Object.assign(verb_core_LazySurfaceBoundingBoxTree.prototype, {
	__class__: verb_core_LazySurfaceBoundingBoxTree
});
class verb_core_Mat {
	static mul(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = b.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.mul(a,b[i]));
		}
		return _g;
	}
	static mult(x,y) {
		let foo;
		let bar;
		let woo;
		let i0;
		let k0;
		let p0;
		let r0;
		let p = x.length;
		let q = y.length;
		let r = y[0].length;
		let ret = [];
		let i = p - 1;
		let j = 0;
		let k = 0;
		while(i >= 0) {
			foo = [];
			bar = x[i];
			k = r - 1;
			while(k >= 0) {
				woo = bar[q - 1] * y[q - 1][k];
				j = q - 2;
				while(j >= 1) {
					i0 = j - 1;
					woo += bar[j] * y[j][k] + bar[i0] * y[i0][k];
					j -= 2;
				}
				if(j == 0) {
					woo += bar[0] * y[0][k];
				}
				foo[k] = woo;
				--k;
			}
			ret[i] = foo;
			--i;
		}
		return ret;
	}
	static add(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.add(a[i],b[i]));
		}
		return _g;
	}
	static div(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.div(a[i],b));
		}
		return _g;
	}
	static sub(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.sub(a[i],b[i]));
		}
		return _g;
	}
	static dot(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.dot(a[i],b));
		}
		return _g;
	}
	static identity(n) {
		let zeros = verb_core_Vec.zeros2d(n,n);
		let _g = 0;
		let _g1 = n;
		while(_g < _g1) {
			let i = _g++;
			zeros[i][i] = 1.0;
		}
		return zeros;
	}
	static transpose(a) {
		if(a.length == 0) {
			return [];
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = a[0].length;
		while(_g1 < _g2) {
			let i = _g1++;
			let _g2 = [];
			let _g3 = 0;
			let _g4 = a.length;
			while(_g3 < _g4) {
				let j = _g3++;
				_g2.push(a[j][i]);
			}
			_g.push(_g2);
		}
		return _g;
	}
	static transposeN(a) {
		if(a.length == 0) {
			return [];
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = a[0].length;
		while(_g1 < _g2) {
			let i = _g1++;
			let _g2 = [];
			let _g3 = 0;
			let _g4 = a.length;
			while(_g3 < _g4) {
				let j = _g3++;
				_g2.push(a[j][i]);
			}
			_g.push(_g2);
		}
		return _g;
	}
	static solve(A,b) {
		return verb_core_Mat.LUsolve(verb_core_Mat.LU(A),b);
	}
	static LUsolve(LUP,b) {
		let j;
		let LU = LUP.LU;
		let n = LU.length;
		let x = b.slice();
		let P = LUP.P;
		let Pi;
		let LUi;
		let LUii;
		let tmp;
		let i = n - 1;
		while(i != -1) {
			x[i] = b[i];
			--i;
		}
		i = 0;
		while(i < n) {
			Pi = P[i];
			if(P[i] != i) {
				tmp = x[i];
				x[i] = x[Pi];
				x[Pi] = tmp;
			}
			LUi = LU[i];
			j = 0;
			while(j < i) {
				x[i] -= x[j] * LUi[j];
				++j;
			}
			++i;
		}
		i = n - 1;
		while(i >= 0) {
			LUi = LU[i];
			j = i + 1;
			while(j < n) {
				x[i] -= x[j] * LUi[j];
				++j;
			}
			x[i] /= LUi[i];
			--i;
		}
		return x;
	}
	static LU(A) {
		let abs = Math.abs;
		let i;
		let j;
		let absAjk;
		let Akk;
		let Ak;
		let Pk;
		let Ai;
		let max;
		let _g = [];
		let _g1 = 0;
		let _g2 = A.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(A[i].slice());
		}
		A = _g;
		let n = A.length;
		let n1 = n - 1;
		let P = [];
		let k = 0;
		while(k < n) {
			Pk = k;
			Ak = A[k];
			max = Math.abs(Ak[k]);
			j = k + 1;
			while(j < n) {
				absAjk = Math.abs(A[j][k]);
				if(max < absAjk) {
					max = absAjk;
					Pk = j;
				}
				++j;
			}
			P[k] = Pk;
			if(Pk != k) {
				A[k] = A[Pk];
				A[Pk] = Ak;
				Ak = A[k];
			}
			Akk = Ak[k];
			i = k + 1;
			while(i < n) {
				A[i][k] /= Akk;
				++i;
			}
			i = k + 1;
			while(i < n) {
				Ai = A[i];
				j = k + 1;
				while(j < n1) {
					Ai[j] -= Ai[k] * Ak[j];
					++j;
					Ai[j] -= Ai[k] * Ak[j];
					++j;
				}
				if(j == n1) {
					Ai[j] -= Ai[k] * Ak[j];
				}
				++i;
			}
			++k;
		}
		return new verb_core__$Mat_LUDecomp(A,P);
	}
}
$hxClasses["verb.core.Mat"] = $hx_exports["core"]["Mat"] = verb_core_Mat;
verb_core_Mat.__name__ = "verb.core.Mat";
class verb_core__$Mat_LUDecomp {
	constructor(lu,p) {
		this.LU = lu;
		this.P = p;
	}
}
$hxClasses["verb.core._Mat.LUDecomp"] = verb_core__$Mat_LUDecomp;
verb_core__$Mat_LUDecomp.__name__ = "verb.core._Mat.LUDecomp";
Object.assign(verb_core__$Mat_LUDecomp.prototype, {
	__class__: verb_core__$Mat_LUDecomp
});
class verb_core_Mesh {
	static getTriangleNorm(points,tri) {
		let v0 = points[tri[0]];
		let v1 = points[tri[1]];
		let v2 = points[tri[2]];
		let u = verb_core_Vec.sub(v1,v0);
		let v = verb_core_Vec.sub(v2,v0);
		let n = verb_core_Vec.cross(u,v);
		return verb_core_Vec.mul(1 / verb_core_Vec.norm(n),n);
	}
	static makeMeshAabb(mesh,faceIndices) {
		let bb = new verb_core_BoundingBox();
		let _g = 0;
		while(_g < faceIndices.length) {
			let x = faceIndices[_g];
			++_g;
			bb.add(mesh.points[mesh.faces[x][0]]);
			bb.add(mesh.points[mesh.faces[x][1]]);
			bb.add(mesh.points[mesh.faces[x][2]]);
		}
		return bb;
	}
	static sortTrianglesOnLongestAxis(bb,mesh,faceIndices) {
		let longAxis = bb.getLongestAxis();
		let minCoordFaceMap = [];
		let _g = 0;
		while(_g < faceIndices.length) {
			let faceIndex = faceIndices[_g];
			++_g;
			let tri_min = verb_core_Mesh.getMinCoordOnAxis(mesh.points,mesh.faces[faceIndex],longAxis);
			minCoordFaceMap.push(new verb_core_Pair(tri_min,faceIndex));
		}
		minCoordFaceMap.sort(function(a,b) {
			let a0 = a.item0;
			let b0 = b.item0;
			if(a0 == b0) {
				return 0;
			} else if(a0 > b0) {
				return 1;
			} else {
				return -1;
			}
		});
		let sortedFaceIndices = [];
		let _g1 = 0;
		let _g2 = minCoordFaceMap.length;
		while(_g1 < _g2) {
			let i = _g1++;
			sortedFaceIndices.push(minCoordFaceMap[i].item1);
		}
		return sortedFaceIndices;
	}
	static getMinCoordOnAxis(points,tri,axis) {
		let min = Infinity;
		let coord = points[tri[0]][axis];
		if(coord < min) {
			min = coord;
		}
		let coord1 = points[tri[1]][axis];
		if(coord1 < min) {
			min = coord1;
		}
		let coord2 = points[tri[2]][axis];
		if(coord2 < min) {
			min = coord2;
		}
		return min;
	}
	static getTriangleCentroid(points,tri) {
		let centroid = [0.0,0.0,0.0];
		centroid[0] += points[tri[0]][0];
		centroid[1] += points[tri[0]][1];
		centroid[2] += points[tri[0]][2];
		centroid[0] += points[tri[1]][0];
		centroid[1] += points[tri[1]][1];
		centroid[2] += points[tri[1]][2];
		centroid[0] += points[tri[2]][0];
		centroid[1] += points[tri[2]][1];
		centroid[2] += points[tri[2]][2];
		centroid[0] /= 3;
		centroid[1] /= 3;
		centroid[2] /= 3;
		return centroid;
	}
	static triangleUVFromPoint(mesh,faceIndex,f) {
		let tri = mesh.faces[faceIndex];
		let p1 = mesh.points[tri[0]];
		let p2 = mesh.points[tri[1]];
		let p3 = mesh.points[tri[2]];
		let uv1 = mesh.uvs[tri[0]];
		let uv2 = mesh.uvs[tri[1]];
		let uv3 = mesh.uvs[tri[2]];
		let f1 = verb_core_Vec.sub(p1,f);
		let f2 = verb_core_Vec.sub(p2,f);
		let f3 = verb_core_Vec.sub(p3,f);
		let a = verb_core_Vec.norm(verb_core_Vec.cross(verb_core_Vec.sub(p1,p2),verb_core_Vec.sub(p1,p3)));
		let a1 = verb_core_Vec.norm(verb_core_Vec.cross(f2,f3)) / a;
		let a2 = verb_core_Vec.norm(verb_core_Vec.cross(f3,f1)) / a;
		let a3 = verb_core_Vec.norm(verb_core_Vec.cross(f1,f2)) / a;
		return verb_core_Vec.add(verb_core_Vec.mul(a1,uv1),verb_core_Vec.add(verb_core_Vec.mul(a2,uv2),verb_core_Vec.mul(a3,uv3)));
	}
}
$hxClasses["verb.core.Mesh"] = $hx_exports["core"]["Mesh"] = verb_core_Mesh;
verb_core_Mesh.__name__ = "verb.core.Mesh";
class verb_core_MeshBoundingBoxTree {
	constructor(mesh,faceIndices) {
		this._empty = false;
		this._face = -1;
		if(faceIndices == null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = mesh.faces.length;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(i);
			}
			faceIndices = _g;
		}
		this._boundingBox = verb_core_Mesh.makeMeshAabb(mesh,faceIndices);
		if(faceIndices.length < 1) {
			this._empty = true;
			return;
		} else if(faceIndices.length < 2) {
			this._face = faceIndices[0];
			return;
		}
		let as = verb_core_Mesh.sortTrianglesOnLongestAxis(this._boundingBox,mesh,faceIndices);
		let l = verb_core_ArrayExtensions.left(as);
		let r = verb_core_ArrayExtensions.right(as);
		this._children = new verb_core_Pair(new verb_core_MeshBoundingBoxTree(mesh,l),new verb_core_MeshBoundingBoxTree(mesh,r));
	}
	split() {
		return this._children;
	}
	boundingBox() {
		return this._boundingBox;
	}
	yield() {
		return this._face;
	}
	indivisible(tolerance) {
		return this._children == null;
	}
	empty() {
		return this._empty;
	}
}
$hxClasses["verb.core.MeshBoundingBoxTree"] = verb_core_MeshBoundingBoxTree;
verb_core_MeshBoundingBoxTree.__name__ = "verb.core.MeshBoundingBoxTree";
verb_core_MeshBoundingBoxTree.__interfaces__ = [verb_eval_IBoundingBoxTree];
Object.assign(verb_core_MeshBoundingBoxTree.prototype, {
	__class__: verb_core_MeshBoundingBoxTree
});
class verb_core_Minimizer {
	static uncmin(f,x0,tol,gradient,maxit) {
		if(tol == null) {
			tol = 1e-8;
		}
		if(gradient == null) {
			gradient = function(x) {
				return verb_core_Minimizer.numericalGradient(f,x);
			};
		}
		if(maxit == null) {
			maxit = 1000;
		}
		x0 = x0.slice(0);
		let n = x0.length;
		let f0 = f(x0);
		let f1 = f0;
		let df0;
		if(isNaN(f0)) {
			throw haxe_Exception.thrown("uncmin: f(x0) is a NaN!");
		}
		tol = Math.max(tol,verb_core_Constants.EPSILON);
		let step;
		let g1;
		let H1 = verb_core_Mat.identity(n);
		let it = 0;
		let i;
		let x1;
		let y;
		let Hy;
		let Hs;
		let ys;
		let i0;
		let t;
		let nstep;
		let t1;
		let t2;
		let s = [];
		let msg = "";
		let g0 = gradient(x0);
		while(it < maxit) {
			if(!verb_core_Vec.all(verb_core_Vec.finite(g0))) {
				msg = "Gradient has Infinity or NaN";
				break;
			}
			step = verb_core_Vec.neg(verb_core_Mat.dot(H1,g0));
			if(!verb_core_Vec.all(verb_core_Vec.finite(step))) {
				msg = "Search direction has Infinity or NaN";
				break;
			}
			nstep = verb_core_Vec.norm(step);
			if(nstep < tol) {
				msg = "Newton step smaller than tol";
				break;
			}
			t = 1.0;
			df0 = verb_core_Vec.dot(g0,step);
			x1 = x0;
			while(it < maxit) {
				if(t * nstep < tol) {
					break;
				}
				s = verb_core_Vec.mul(t,step);
				x1 = verb_core_Vec.add(x0,s);
				f1 = f(x1);
				if(f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {
					t *= 0.5;
					++it;
					continue;
				}
				break;
			}
			if(t * nstep < tol) {
				msg = "Line search step size smaller than tol";
				break;
			}
			if(it == maxit) {
				msg = "maxit reached during line search";
				break;
			}
			g1 = gradient(x1);
			y = verb_core_Vec.sub(g1,g0);
			ys = verb_core_Vec.dot(y,s);
			Hy = verb_core_Mat.dot(H1,y);
			H1 = verb_core_Mat.sub(verb_core_Mat.add(H1,verb_core_Mat.mul((ys + verb_core_Vec.dot(y,Hy)) / (ys * ys),verb_core_Minimizer.tensor(s,s))),verb_core_Mat.div(verb_core_Mat.add(verb_core_Minimizer.tensor(Hy,s),verb_core_Minimizer.tensor(s,Hy)),ys));
			x0 = x1;
			f0 = f1;
			g0 = g1;
			++it;
		}
		return new verb_core_MinimizationResult(x0,f0,g0,H1,it,msg);
	}
	static numericalGradient(f,x) {
		let n = x.length;
		let f0 = f(x);
		if(f0 == NaN) {
			throw haxe_Exception.thrown("gradient: f(x) is a NaN!");
		}
		let i;
		let x0 = x.slice(0);
		let f1;
		let f2;
		let J = [];
		let errest;
		let roundoff;
		let eps = 1e-3;
		let t0;
		let t1;
		let t2;
		let it = 0;
		let d1;
		let d2;
		let N;
		let _g = 0;
		let _g1 = n;
		while(_g < _g1) {
			let i = _g++;
			let h = Math.max(1e-6 * f0,1e-8);
			while(true) {
				++it;
				if(it > 20) {
					throw haxe_Exception.thrown("Numerical gradient fails");
				}
				x0[i] = x[i] + h;
				f1 = f(x0);
				x0[i] = x[i] - h;
				f2 = f(x0);
				x0[i] = x[i];
				if(isNaN(f1) || isNaN(f2)) {
					h /= 16;
					continue;
				}
				J[i] = (f1 - f2) / (2 * h);
				t0 = x[i] - h;
				t1 = x[i];
				t2 = x[i] + h;
				d1 = (f1 - f0) / h;
				d2 = (f0 - f2) / h;
				N = verb_core_Vec.max([Math.abs(J[i]),Math.abs(f0),Math.abs(f1),Math.abs(f2),Math.abs(t0),Math.abs(t1),Math.abs(t2),1e-8]);
				errest = Math.min(verb_core_Vec.max([Math.abs(d1 - J[i]),Math.abs(d2 - J[i]),Math.abs(d1 - d2)]) / N,h / N);
				if(errest > eps) {
					h /= 16;
				} else {
					break;
				}
			}
		}
		return J;
	}
	static tensor(x,y) {
		let m = x.length;
		let n = y.length;
		let Ai;
		let xi;
		let A = [];
		let i = m - 1;
		while(i >= 0) {
			Ai = [];
			xi = x[i];
			let j = n - 1;
			while(j >= 3) {
				Ai[j] = xi * y[j];
				--j;
				Ai[j] = xi * y[j];
				--j;
				Ai[j] = xi * y[j];
				--j;
				Ai[j] = xi * y[j];
				--j;
			}
			while(j >= 0) {
				Ai[j] = xi * y[j];
				--j;
			}
			A[i] = Ai;
			--i;
		}
		return A;
	}
}
$hxClasses["verb.core.Minimizer"] = $hx_exports["core"]["Minimizer"] = verb_core_Minimizer;
verb_core_Minimizer.__name__ = "verb.core.Minimizer";
class verb_core_MinimizationResult {
	constructor(solution,value,gradient,invHessian,iterations,message) {
		this.solution = solution;
		this.value = value;
		this.gradient = gradient;
		this.invHessian = invHessian;
		this.iterations = iterations;
		this.message = message;
	}
}
$hxClasses["verb.core.MinimizationResult"] = verb_core_MinimizationResult;
verb_core_MinimizationResult.__name__ = "verb.core.MinimizationResult";
Object.assign(verb_core_MinimizationResult.prototype, {
	__class__: verb_core_MinimizationResult
});
class verb_core_ISerializable {
}
$hxClasses["verb.core.ISerializable"] = verb_core_ISerializable;
verb_core_ISerializable.__name__ = "verb.core.ISerializable";
verb_core_ISerializable.__isInterface__ = true;
Object.assign(verb_core_ISerializable.prototype, {
	__class__: verb_core_ISerializable
});
class verb_core_Deserializer {
	static deserialize(s) {
		let unserializer = new haxe_Unserializer(s);
		let r = unserializer.unserialize();
		return r;
	}
}
$hxClasses["verb.core.Deserializer"] = $hx_exports["core"]["Deserializer"] = verb_core_Deserializer;
verb_core_Deserializer.__name__ = "verb.core.Deserializer";
class verb_core_Trig {
	static isPointInPlane(pt,p,tol) {
		return Math.abs(verb_core_Vec.dot(verb_core_Vec.sub(pt,p.origin),p.normal)) < tol;
	}
	static distToSegment(a,b,c) {
		let res = verb_core_Trig.segmentClosestPoint(b,a,c,0.0,1.0);
		return verb_core_Vec.dist(b,res.pt);
	}
	static rayClosestPoint(pt,o,r) {
		let o2pt = verb_core_Vec.sub(pt,o);
		let do2ptr = verb_core_Vec.dot(o2pt,r);
		let proj = verb_core_Vec.add(o,verb_core_Vec.mul(do2ptr,r));
		return proj;
	}
	static distToRay(pt,o,r) {
		let d = verb_core_Trig.rayClosestPoint(pt,o,r);
		let dif = verb_core_Vec.sub(d,pt);
		return verb_core_Vec.norm(dif);
	}
	static threePointsAreFlat(p1,p2,p3,tol) {
		let p2mp1 = verb_core_Vec.sub(p2,p1);
		let p3mp1 = verb_core_Vec.sub(p3,p1);
		let norm = verb_core_Vec.cross(p2mp1,p3mp1);
		let area = verb_core_Vec.dot(norm,norm);
		return area < tol;
	}
	static segmentClosestPoint(pt,segpt0,segpt1,u0,u1) {
		let dif = verb_core_Vec.sub(segpt1,segpt0);
		let l = verb_core_Vec.norm(dif);
		if(l < verb_core_Constants.EPSILON) {
			return { u : u0, pt : segpt0};
		}
		let o = segpt0;
		let r = verb_core_Vec.mul(1 / l,dif);
		let o2pt = verb_core_Vec.sub(pt,o);
		let do2ptr = verb_core_Vec.dot(o2pt,r);
		if(do2ptr < 0) {
			return { u : u0, pt : segpt0};
		} else if(do2ptr > l) {
			return { u : u1, pt : segpt1};
		}
		return { u : u0 + (u1 - u0) * do2ptr / l, pt : verb_core_Vec.add(o,verb_core_Vec.mul(do2ptr,r))};
	}
}
$hxClasses["verb.core.Trig"] = $hx_exports["core"]["Trig"] = verb_core_Trig;
verb_core_Trig.__name__ = "verb.core.Trig";
class verb_core_Vec {
	static angleBetween(a,b) {
		return Math.acos(verb_core_Vec.dot(a,b) / (verb_core_Vec.norm(a) * verb_core_Vec.norm(b)));
	}
	static positiveAngleBetween(a,b,n) {
		let nab = verb_core_Vec.cross(a,b);
		let al = verb_core_Vec.norm(a);
		let bl = verb_core_Vec.norm(b);
		let abl = al * bl;
		let adb = verb_core_Vec.dot(a,b);
		let sina = verb_core_Vec.norm(nab) / abl;
		let cosa = adb / abl;
		let w = Math.atan2(sina,cosa);
		let s = verb_core_Vec.dot(n,nab);
		if(Math.abs(s) < verb_core_Constants.EPSILON) {
			return w;
		}
		if(s > 0) {
			return w;
		} else {
			return -w;
		}
	}
	static signedAngleBetween(a,b,n) {
		let nab = verb_core_Vec.cross(a,b);
		let al = verb_core_Vec.norm(a);
		let bl = verb_core_Vec.norm(b);
		let abl = al * bl;
		let adb = verb_core_Vec.dot(a,b);
		let sina = verb_core_Vec.norm(nab) / abl;
		let cosa = adb / abl;
		let w = Math.atan2(sina,cosa);
		let s = verb_core_Vec.dot(n,nab);
		if(s > 0.0) {
			return w;
		} else {
			return 2 * Math.PI - w;
		}
	}
	static angleBetweenNormalized2d(a,b) {
		let perpDot = a[0] * b[1] - a[1] * b[0];
		return Math.atan2(perpDot,verb_core_Vec.dot(a,b));
	}
	static domain(a) {
		return verb_core_ArrayExtensions.last(a) - verb_core_ArrayExtensions.first(a);
	}
	static range(max) {
		let l = [];
		let f = 0.0;
		let _g = 0;
		let _g1 = max;
		while(_g < _g1) {
			let i = _g++;
			l.push(f);
			f += 1.0;
		}
		return l;
	}
	static span(min,max,step) {
		if(step == null) {
			return [];
		}
		if(step < verb_core_Constants.EPSILON) {
			return [];
		}
		if(min > max && step > 0.0) {
			return [];
		}
		if(max > min && step < 0.0) {
			return [];
		}
		let l = [];
		let cur = min;
		while(cur <= max) {
			l.push(cur);
			cur += step;
		}
		return l;
	}
	static neg(arr) {
		let result = new Array(arr.length);
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = -arr[i];
		}
		return result;
	}
	static min(arr) {
		return Lambda.fold(arr,function(x,a) {
			return Math.min(x,a);
		},Infinity);
	}
	static max(arr) {
		return Lambda.fold(arr,function(x,a) {
			return Math.max(x,a);
		},-Infinity);
	}
	static all(arr) {
		return Lambda.fold(arr,function(x,a) {
			if(a) {
				return x;
			} else {
				return false;
			}
		},true);
	}
	static finite(arr) {
		let result = new Array(arr.length);
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = isFinite(arr[i]);
		}
		return result;
	}
	static onRay(origin,dir,u) {
		return verb_core_Vec.add(origin,verb_core_Vec.mul(u,dir));
	}
	static lerp(i,u,v) {
		return verb_core_Vec.add(verb_core_Vec.mul(i,u),verb_core_Vec.mul(1.0 - i,v));
	}
	static normalized(arr) {
		return verb_core_Vec.div(arr,verb_core_Vec.norm(arr));
	}
	static cross(u,v) {
		return [u[1] * v[2] - u[2] * v[1],u[2] * v[0] - u[0] * v[2],u[0] * v[1] - u[1] * v[0]];
	}
	static dist(a,b) {
		return verb_core_Vec.norm(verb_core_Vec.sub(a,b));
	}
	static distSquared(a,b) {
		return verb_core_Vec.normSquared(verb_core_Vec.sub(a,b));
	}
	static sum(a) {
		return Lambda.fold(a,function(x,a) {
			return a + x;
		},0);
	}
	static addAll(a) {
		let i = $getIterator(a);
		if(!i.hasNext()) {
			return null;
		}
		let f = i.next().length;
		return Lambda.fold(a,function(x,a) {
			return verb_core_Vec.add(a,x);
		},verb_core_Vec.rep(f,0.0));
	}
	static addAllMutate(a) {
		let f = a[0];
		let _g = 1;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			verb_core_Vec.addMutate(f,a[i]);
		}
	}
	static addMulMutate(a,s,b) {
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			a[i] += s * b[i];
		}
	}
	static subMulMutate(a,s,b) {
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			a[i] -= s * b[i];
		}
	}
	static addMutate(a,b) {
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			a[i] += b[i];
		}
	}
	static subMutate(a,b) {
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			a[i] -= b[i];
		}
	}
	static mulMutate(a,b) {
		let _g = 0;
		let _g1 = b.length;
		while(_g < _g1) {
			let i = _g++;
			b[i] *= a;
		}
	}
	static norm(a) {
		let norm2 = verb_core_Vec.normSquared(a);
		if(norm2 != 0.0) {
			return Math.sqrt(norm2);
		} else {
			return norm2;
		}
	}
	static normSquared(a) {
		return Lambda.fold(a,function(x,a) {
			return a + x * x;
		},0);
	}
	static rep(num,ele) {
		let _g = [];
		let _g1 = 0;
		let _g2 = num;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(ele);
		}
		return _g;
	}
	static fill(num,ele) {
		let _g = [];
		let _g1 = 0;
		let _g2 = num;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(ele);
		}
		return _g;
	}
	static zeros1d(rows) {
		let _g = [];
		let _g1 = 0;
		let _g2 = rows;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(0.0);
		}
		return _g;
	}
	static zeros2d(rows,cols) {
		let _g = [];
		let _g1 = 0;
		let _g2 = rows;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.zeros1d(cols));
		}
		return _g;
	}
	static zeros3d(rows,cols,depth) {
		let _g = [];
		let _g1 = 0;
		let _g2 = rows;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(verb_core_Vec.zeros2d(cols,depth));
		}
		return _g;
	}
	static dot(a,b) {
		let sum = 0;
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			sum += a[i] * b[i];
		}
		return sum;
	}
	static add(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(a[i] + b[i]);
		}
		return _g;
	}
	static mul(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = b.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(a * b[i]);
		}
		return _g;
	}
	static div(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(a[i] / b);
		}
		return _g;
	}
	static sub(a,b) {
		let _g = [];
		let _g1 = 0;
		let _g2 = a.length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(a[i] - b[i]);
		}
		return _g;
	}
	static isZero(vec) {
		let _g = 0;
		let _g1 = vec.length;
		while(_g < _g1) {
			let i = _g++;
			if(Math.abs(vec[i]) > verb_core_Constants.TOLERANCE) {
				return false;
			}
		}
		return true;
	}
	static sortedSetUnion(a,b) {
		let merged = [];
		let ai = 0;
		let bi = 0;
		while(ai < a.length || bi < b.length) {
			if(ai >= a.length) {
				merged.push(b[bi]);
				++bi;
				continue;
			} else if(bi >= b.length) {
				merged.push(a[ai]);
				++ai;
				continue;
			}
			let diff = a[ai] - b[bi];
			if(Math.abs(diff) < verb_core_Constants.EPSILON) {
				merged.push(a[ai]);
				++ai;
				++bi;
				continue;
			}
			if(diff > 0.0) {
				merged.push(b[bi]);
				++bi;
				continue;
			}
			merged.push(a[ai]);
			++ai;
		}
		return merged;
	}
	static sortedSetSub(a,b) {
		let result = [];
		let ai = 0;
		let bi = 0;
		while(ai < a.length) {
			if(bi >= b.length) {
				result.push(a[ai]);
				++ai;
				continue;
			}
			if(Math.abs(a[ai] - b[bi]) < verb_core_Constants.EPSILON) {
				++ai;
				++bi;
				continue;
			}
			result.push(a[ai]);
			++ai;
		}
		return result;
	}
}
$hxClasses["verb.core.Vec"] = $hx_exports["core"]["Vec"] = verb_core_Vec;
verb_core_Vec.__name__ = "verb.core.Vec";
class verb_eval_Analyze {
	static knotMultiplicities(knots) {
		let mults = [new verb_eval_KnotMultiplicity(knots[0],0)];
		let curr = mults[0];
		let _g = 0;
		while(_g < knots.length) {
			let knot = knots[_g];
			++_g;
			if(Math.abs(knot - curr.knot) > verb_core_Constants.EPSILON) {
				curr = new verb_eval_KnotMultiplicity(knot,0);
				mults.push(curr);
			}
			curr.inc();
		}
		return mults;
	}
	static isRationalSurfaceClosed(surface,uDir) {
		if(uDir == null) {
			uDir = true;
		}
		let cpts = uDir ? surface.controlPoints : verb_core_Mat.transposeN(surface.controlPoints);
		let _g = 0;
		let _g1 = cpts[0].length;
		while(_g < _g1) {
			let i = _g++;
			let test = verb_core_Vec.dist(verb_core_ArrayExtensions.first(cpts)[i],verb_core_ArrayExtensions.last(cpts)[i]) < verb_core_Constants.EPSILON;
			if(!test) {
				return false;
			}
		}
		return true;
	}
	static rationalSurfaceClosestPoint(surface,p) {
		let uv = verb_eval_Analyze.rationalSurfaceClosestParam(surface,p);
		return verb_eval_Eval.rationalSurfacePoint(surface,uv[0],uv[1]);
	}
	static rationalSurfaceClosestParam(surface,p) {
		let maxits = 5;
		let i = 0;
		let e;
		let eps1 = 0.0001;
		let eps2 = 0.0005;
		let dif;
		let minu = surface.knotsU[0];
		let maxu = verb_core_ArrayExtensions.last(surface.knotsU);
		let minv = surface.knotsV[0];
		let maxv = verb_core_ArrayExtensions.last(surface.knotsV);
		let closedu = verb_eval_Analyze.isRationalSurfaceClosed(surface);
		let closedv = verb_eval_Analyze.isRationalSurfaceClosed(surface,false);
		let cuv;
		let tess = verb_eval_Tess.rationalSurfaceAdaptive(surface,new verb_eval_AdaptiveRefinementOptions());
		let dmin = Infinity;
		let _g = 0;
		let _g1 = tess.points.length;
		while(_g < _g1) {
			let i = _g++;
			let x = tess.points[i];
			let d = verb_core_Vec.normSquared(verb_core_Vec.sub(p,x));
			if(d < dmin) {
				dmin = d;
				cuv = tess.uvs[i];
			}
		}
		let f = function(uv) {
			return verb_eval_Eval.rationalSurfaceDerivatives(surface,uv[0],uv[1],2);
		};
		let n = function(uv,e,r) {
			let Su = e[1][0];
			let Sv = e[0][1];
			let Suu = e[2][0];
			let Svv = e[0][2];
			let Suv = e[1][1];
			let Svu = e[1][1];
			let f = verb_core_Vec.dot(Su,r);
			let g = verb_core_Vec.dot(Sv,r);
			let k = [-f,-g];
			let J00 = verb_core_Vec.dot(Su,Su) + verb_core_Vec.dot(Suu,r);
			let J01 = verb_core_Vec.dot(Su,Sv) + verb_core_Vec.dot(Suv,r);
			let J10 = verb_core_Vec.dot(Su,Sv) + verb_core_Vec.dot(Svu,r);
			let J11 = verb_core_Vec.dot(Sv,Sv) + verb_core_Vec.dot(Svv,r);
			let J = [[J00,J01],[J10,J11]];
			let d = verb_core_Mat.solve(J,k);
			return verb_core_Vec.add(d,uv);
		};
		while(i < maxits) {
			e = f(cuv);
			dif = verb_core_Vec.sub(e[0][0],p);
			let c1v = verb_core_Vec.norm(dif);
			let c2an = verb_core_Vec.dot(e[1][0],dif);
			let c2ad = verb_core_Vec.norm(e[1][0]) * c1v;
			let c2bn = verb_core_Vec.dot(e[0][1],dif);
			let c2bd = verb_core_Vec.norm(e[0][1]) * c1v;
			let c2av = c2an / c2ad;
			let c2bv = c2bn / c2bd;
			let c1 = c1v < eps1;
			let c2a = c2av < eps2;
			let c2b = c2bv < eps2;
			if(c1 && c2a && c2b) {
				return cuv;
			}
			let ct = n(cuv,e,dif);
			if(ct[0] < minu) {
				ct = closedu ? [maxu - (ct[0] - minu),ct[1]] : [minu + verb_core_Constants.EPSILON,ct[1]];
			} else if(ct[0] > maxu) {
				ct = closedu ? [minu + (ct[0] - maxu),ct[1]] : [maxu - verb_core_Constants.EPSILON,ct[1]];
			}
			if(ct[1] < minv) {
				ct = closedv ? [ct[0],maxv - (ct[1] - minv)] : [ct[0],minv + verb_core_Constants.EPSILON];
			} else if(ct[1] > maxv) {
				ct = closedv ? [ct[0],minv + (ct[0] - maxv)] : [ct[0],maxv - verb_core_Constants.EPSILON];
			}
			let c3v0 = verb_core_Vec.norm(verb_core_Vec.mul(ct[0] - cuv[0],e[1][0]));
			let c3v1 = verb_core_Vec.norm(verb_core_Vec.mul(ct[1] - cuv[1],e[0][1]));
			if(c3v0 + c3v1 < eps1) {
				return cuv;
			}
			cuv = ct;
			++i;
		}
		return cuv;
	}
	static rationalCurveClosestPoint(curve,p) {
		return verb_eval_Eval.rationalCurvePoint(curve,verb_eval_Analyze.rationalCurveClosestParam(curve,p));
	}
	static rationalCurveClosestParam(curve,p) {
		let min = Infinity;
		let u = 0.0;
		let pts = verb_eval_Tess.rationalCurveRegularSample(curve,curve.controlPoints.length * curve.degree,true);
		let _g = 0;
		let _g1 = pts.length - 1;
		while(_g < _g1) {
			let i = _g++;
			let u0 = pts[i][0];
			let u1 = pts[i + 1][0];
			let p0 = pts[i].slice(1);
			let p1 = pts[i + 1].slice(1);
			let proj = verb_core_Trig.segmentClosestPoint(p,p0,p1,u0,u1);
			let d = verb_core_Vec.norm(verb_core_Vec.sub(p,proj.pt));
			if(d < min) {
				min = d;
				u = proj.u;
			}
		}
		let maxits = 5;
		let i = 0;
		let e;
		let eps1 = 0.0001;
		let eps2 = 0.0005;
		let dif;
		let minu = curve.knots[0];
		let maxu = verb_core_ArrayExtensions.last(curve.knots);
		let closed = verb_core_Vec.normSquared(verb_core_Vec.sub(curve.controlPoints[0],verb_core_ArrayExtensions.last(curve.controlPoints))) < verb_core_Constants.EPSILON;
		let cu = u;
		let f = function(u) {
			return verb_eval_Eval.rationalCurveDerivatives(curve,u,2);
		};
		let n = function(u,e,d) {
			let f = verb_core_Vec.dot(e[1],d);
			let s0 = verb_core_Vec.dot(e[2],d);
			let s1 = verb_core_Vec.dot(e[1],e[1]);
			let df = s0 + s1;
			return u - f / df;
		};
		while(i < maxits) {
			e = f(cu);
			dif = verb_core_Vec.sub(e[0],p);
			let c1v = verb_core_Vec.norm(dif);
			let c2n = verb_core_Vec.dot(e[1],dif);
			let c2d = verb_core_Vec.norm(e[1]) * c1v;
			let c2v = c2n / c2d;
			let c1 = c1v < eps1;
			let c2 = Math.abs(c2v) < eps2;
			if(c1 && c2) {
				return cu;
			}
			let ct = n(cu,e,dif);
			if(ct < minu) {
				ct = closed ? maxu - (ct - minu) : minu;
			} else if(ct > maxu) {
				ct = closed ? minu + (ct - maxu) : maxu;
			}
			let c3v = verb_core_Vec.norm(verb_core_Vec.mul(ct - cu,e[1]));
			if(c3v < eps1) {
				return cu;
			}
			cu = ct;
			++i;
		}
		return cu;
	}
	static rationalCurveParamAtArcLength(curve,len,tol,beziers,bezierLengths) {
		if(tol == null) {
			tol = 1e-3;
		}
		if(len < verb_core_Constants.EPSILON) {
			return curve.knots[0];
		}
		let crvs = beziers != null ? beziers : verb_eval_Modify.decomposeCurveIntoBeziers(curve);
		let i = 0;
		let cc = crvs[i];
		let cl = -verb_core_Constants.EPSILON;
		let bezier_lengths = bezierLengths != null ? bezierLengths : [];
		while(cl < len && i < crvs.length) {
			bezier_lengths[i] = i < bezier_lengths.length ? bezier_lengths[i] : verb_eval_Analyze.rationalBezierCurveArcLength(curve);
			cl += bezier_lengths[i];
			if(len < cl + verb_core_Constants.EPSILON) {
				return verb_eval_Analyze.rationalBezierCurveParamAtArcLength(curve,len,tol,bezier_lengths[i]);
			}
			++i;
		}
		return -1;
	}
	static rationalBezierCurveParamAtArcLength(curve,len,tol,totalLength) {
		if(len < 0) {
			return curve.knots[0];
		}
		let totalLen = totalLength != null ? totalLength : verb_eval_Analyze.rationalBezierCurveArcLength(curve);
		if(len > totalLen) {
			return verb_core_ArrayExtensions.last(curve.knots);
		}
		let start_p = curve.knots[0];
		let start_l = 0.0;
		let end_p = verb_core_ArrayExtensions.last(curve.knots);
		let end_l = totalLen;
		let mid_p = 0.0;
		let mid_l = 0.0;
		let tol1 = tol != null ? tol : verb_core_Constants.TOLERANCE * 2;
		while(end_l - start_l > tol1) {
			mid_p = (start_p + end_p) / 2;
			mid_l = verb_eval_Analyze.rationalBezierCurveArcLength(curve,mid_p);
			if(mid_l > len) {
				end_p = mid_p;
				end_l = mid_l;
			} else {
				start_p = mid_p;
				start_l = mid_l;
			}
		}
		return (start_p + end_p) / 2;
	}
	static rationalCurveArcLength(curve,u,gaussDegIncrease) {
		if(gaussDegIncrease == null) {
			gaussDegIncrease = 16;
		}
		if(u == null) {
			u = verb_core_ArrayExtensions.last(curve.knots);
		}
		let crvs = verb_eval_Modify.decomposeCurveIntoBeziers(curve);
		let i = 0;
		let cc = crvs[0];
		let sum = 0.0;
		while(i < crvs.length && cc.knots[0] + verb_core_Constants.EPSILON < u) {
			let param = Math.min(verb_core_ArrayExtensions.last(cc.knots),u);
			sum += verb_eval_Analyze.rationalBezierCurveArcLength(cc,param,gaussDegIncrease);
			cc = crvs[++i];
		}
		return sum;
	}
	static rationalBezierCurveArcLength(curve,u,gaussDegIncrease) {
		if(gaussDegIncrease == null) {
			gaussDegIncrease = 16;
		}
		let u1 = u == null ? verb_core_ArrayExtensions.last(curve.knots) : u;
		let z = (u1 - curve.knots[0]) / 2;
		let sum = 0.0;
		let gaussDeg = curve.degree + gaussDegIncrease;
		let cu;
		let tan;
		let _g = 0;
		let _g1 = gaussDeg;
		while(_g < _g1) {
			let i = _g++;
			cu = z * verb_eval_Analyze.Tvalues[gaussDeg][i] + z + curve.knots[0];
			tan = verb_eval_Eval.rationalCurveDerivatives(curve,cu,1);
			sum += verb_eval_Analyze.Cvalues[gaussDeg][i] * verb_core_Vec.norm(tan[1]);
		}
		return z * sum;
	}
}
$hxClasses["verb.eval.Analyze"] = $hx_exports["eval"]["Analyze"] = verb_eval_Analyze;
verb_eval_Analyze.__name__ = "verb.eval.Analyze";
class verb_eval_KnotMultiplicity {
	constructor(knot,mult) {
		this.knot = knot;
		this.mult = mult;
	}
	inc() {
		this.mult++;
	}
}
$hxClasses["verb.eval.KnotMultiplicity"] = $hx_exports["eval"]["KnotMultiplicity"] = verb_eval_KnotMultiplicity;
verb_eval_KnotMultiplicity.__name__ = "verb.eval.KnotMultiplicity";
Object.assign(verb_eval_KnotMultiplicity.prototype, {
	__class__: verb_eval_KnotMultiplicity
});
class verb_eval_Check {
	static isValidKnotVector(vec,degree) {
		if(vec.length == 0) {
			return false;
		}
		if(vec.length < (degree + 1) * 2) {
			return false;
		}
		let rep = verb_core_ArrayExtensions.first(vec);
		let _g = 0;
		let _g1 = degree + 1;
		while(_g < _g1) {
			let i = _g++;
			if(Math.abs(vec[i] - rep) > verb_core_Constants.EPSILON) {
				return false;
			}
		}
		rep = verb_core_ArrayExtensions.last(vec);
		let _g2 = vec.length - degree - 1;
		let _g3 = vec.length;
		while(_g2 < _g3) {
			let i = _g2++;
			if(Math.abs(vec[i] - rep) > verb_core_Constants.EPSILON) {
				return false;
			}
		}
		return verb_eval_Check.isNonDecreasing(vec);
	}
	static isNonDecreasing(vec) {
		let rep = verb_core_ArrayExtensions.first(vec);
		let _g = 0;
		let _g1 = vec.length;
		while(_g < _g1) {
			let i = _g++;
			if(vec[i] < rep - verb_core_Constants.EPSILON) {
				return false;
			}
			rep = vec[i];
		}
		return true;
	}
	static isValidNurbsCurveData(data) {
		if(data.controlPoints == null) {
			throw haxe_Exception.thrown("Control points array cannot be null!");
		}
		if(data.degree == null) {
			throw haxe_Exception.thrown("Degree cannot be null!");
		}
		if(data.degree < 1) {
			throw haxe_Exception.thrown("Degree must be greater than 1!");
		}
		if(data.knots == null) {
			throw haxe_Exception.thrown("Knots cannot be null!");
		}
		if(data.knots.length != data.controlPoints.length + data.degree + 1) {
			throw haxe_Exception.thrown("controlPoints.length + degree + 1 must equal knots.length!");
		}
		if(!verb_eval_Check.isValidKnotVector(data.knots,data.degree)) {
			throw haxe_Exception.thrown("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
		}
		return data;
	}
	static isValidNurbsSurfaceData(data) {
		if(data.controlPoints == null) {
			throw haxe_Exception.thrown("Control points array cannot be null!");
		}
		if(data.degreeU == null) {
			throw haxe_Exception.thrown("DegreeU cannot be null!");
		}
		if(data.degreeV == null) {
			throw haxe_Exception.thrown("DegreeV cannot be null!");
		}
		if(data.degreeU < 1) {
			throw haxe_Exception.thrown("DegreeU must be greater than 1!");
		}
		if(data.degreeV < 1) {
			throw haxe_Exception.thrown("DegreeV must be greater than 1!");
		}
		if(data.knotsU == null) {
			throw haxe_Exception.thrown("KnotsU cannot be null!");
		}
		if(data.knotsV == null) {
			throw haxe_Exception.thrown("KnotsV cannot be null!");
		}
		if(data.knotsU.length != data.controlPoints.length + data.degreeU + 1) {
			throw haxe_Exception.thrown("controlPointsU.length + degreeU + 1 must equal knotsU.length!");
		}
		if(data.knotsV.length != data.controlPoints[0].length + data.degreeV + 1) {
			throw haxe_Exception.thrown("controlPointsV.length + degreeV + 1 must equal knotsV.length!");
		}
		if(!verb_eval_Check.isValidKnotVector(data.knotsU,data.degreeU) || !verb_eval_Check.isValidKnotVector(data.knotsV,data.degreeV)) {
			throw haxe_Exception.thrown("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!");
		}
		return data;
	}
}
$hxClasses["verb.eval.Check"] = $hx_exports["eval"]["Check"] = verb_eval_Check;
verb_eval_Check.__name__ = "verb.eval.Check";
class verb_eval_Divide {
	static surfaceSplit(surface,u,useV) {
		if(useV == null) {
			useV = false;
		}
		let knots;
		let degree;
		let controlPoints;
		if(!useV) {
			controlPoints = verb_core_Mat.transposeN(surface.controlPoints);
			knots = surface.knotsU;
			degree = surface.degreeU;
		} else {
			controlPoints = surface.controlPoints;
			knots = surface.knotsV;
			degree = surface.degreeV;
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = degree + 1;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(u);
		}
		let knots_to_insert = _g;
		let newpts0 = [];
		let newpts1 = [];
		let s = verb_eval_Eval.knotSpan(degree,u,knots);
		let res = null;
		let _g3 = 0;
		while(_g3 < controlPoints.length) {
			let cps = controlPoints[_g3];
			++_g3;
			res = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,cps),knots_to_insert);
			newpts0.push(res.controlPoints.slice(0,s + 1));
			newpts1.push(res.controlPoints.slice(s + 1));
		}
		let knots0 = res.knots.slice(0,s + degree + 2);
		let knots1 = res.knots.slice(s + 1);
		if(!useV) {
			newpts0 = verb_core_Mat.transposeN(newpts0);
			newpts1 = verb_core_Mat.transposeN(newpts1);
			return [new verb_core_NurbsSurfaceData(degree,surface.degreeV,knots0,surface.knotsV.slice(),newpts0),new verb_core_NurbsSurfaceData(degree,surface.degreeV,knots1,surface.knotsV.slice(),newpts1)];
		}
		return [new verb_core_NurbsSurfaceData(surface.degreeU,degree,surface.knotsU.slice(),knots0,newpts0),new verb_core_NurbsSurfaceData(surface.degreeU,degree,surface.knotsU.slice(),knots1,newpts1)];
	}
	static curveSplit(curve,u) {
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		let _g = [];
		let _g1 = 0;
		let _g2 = degree + 1;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(u);
		}
		let knots_to_insert = _g;
		let res = verb_eval_Modify.curveKnotRefine(curve,knots_to_insert);
		let s = verb_eval_Eval.knotSpan(degree,u,knots);
		let knots0 = res.knots.slice(0,s + degree + 2);
		let knots1 = res.knots.slice(s + 1);
		let cpts0 = res.controlPoints.slice(0,s + 1);
		let cpts1 = res.controlPoints.slice(s + 1);
		return [new verb_core_NurbsCurveData(degree,knots0,cpts0),new verb_core_NurbsCurveData(degree,knots1,cpts1)];
	}
	static rationalCurveByEqualArcLength(curve,num) {
		let tlen = verb_eval_Analyze.rationalCurveArcLength(curve);
		let inc = tlen / num;
		return verb_eval_Divide.rationalCurveByArcLength(curve,inc);
	}
	static rationalCurveByArcLength(curve,l) {
		let crvs = verb_eval_Modify.decomposeCurveIntoBeziers(curve);
		let result = new Array(crvs.length);
		let _g = 0;
		let _g1 = crvs.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = verb_eval_Analyze.rationalBezierCurveArcLength(crvs[i]);
		}
		let crvlens = result;
		let totlen = verb_core_Vec.sum(crvlens);
		let pts = [new verb_eval_CurveLengthSample(curve.knots[0],0.0)];
		if(l > totlen) {
			return pts;
		}
		let inc = l;
		let i = 0;
		let lc = inc;
		let runsum = 0.0;
		let runsum1 = 0.0;
		let u;
		while(i < crvs.length) {
			runsum += crvlens[i];
			while(lc < runsum + verb_core_Constants.EPSILON) {
				u = verb_eval_Analyze.rationalBezierCurveParamAtArcLength(crvs[i],lc - runsum1,verb_core_Constants.TOLERANCE,crvlens[i]);
				pts.push(new verb_eval_CurveLengthSample(u,lc));
				lc += inc;
			}
			runsum1 += crvlens[i];
			++i;
		}
		return pts;
	}
}
$hxClasses["verb.eval.Divide"] = $hx_exports["eval"]["Divide"] = verb_eval_Divide;
verb_eval_Divide.__name__ = "verb.eval.Divide";
class verb_eval_CurveLengthSample {
	constructor(u,len) {
		this.u = u;
		this.len = len;
	}
}
$hxClasses["verb.eval.CurveLengthSample"] = $hx_exports["eval"]["CurveLengthSample"] = verb_eval_CurveLengthSample;
verb_eval_CurveLengthSample.__name__ = "verb.eval.CurveLengthSample";
Object.assign(verb_eval_CurveLengthSample.prototype, {
	__class__: verb_eval_CurveLengthSample
});
class verb_eval_Eval {
	static rationalCurveTangent(curve,u) {
		let derivs = verb_eval_Eval.rationalCurveDerivatives(curve,u,1);
		return derivs[1];
	}
	static rationalSurfaceNormal(surface,u,v) {
		let derivs = verb_eval_Eval.rationalSurfaceDerivatives(surface,u,v,1);
		return verb_core_Vec.cross(derivs[1][0],derivs[0][1]);
	}
	static rationalSurfaceDerivatives(surface,u,v,numDerivs) {
		if(numDerivs == null) {
			numDerivs = 1;
		}
		let ders = verb_eval_Eval.surfaceDerivatives(surface,u,v,numDerivs);
		let Aders = verb_eval_Eval.rational2d(ders);
		let wders = verb_eval_Eval.weight2d(ders);
		let SKL = [];
		let dim = Aders[0][0].length;
		let _g = 0;
		let _g1 = numDerivs + 1;
		while(_g < _g1) {
			let k = _g++;
			SKL.push([]);
			let _g1 = 0;
			let _g2 = numDerivs - k + 1;
			while(_g1 < _g2) {
				let l = _g1++;
				let v = Aders[k][l];
				let _g = 1;
				let _g2 = l + 1;
				while(_g < _g2) {
					let j = _g++;
					verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(l,j) * wders[0][j],SKL[k][l - j]);
				}
				let _g3 = 1;
				let _g4 = k + 1;
				while(_g3 < _g4) {
					let i = _g3++;
					verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i) * wders[i][0],SKL[k - i][l]);
					let v2 = verb_core_Vec.zeros1d(dim);
					let _g = 1;
					let _g1 = l + 1;
					while(_g < _g1) {
						let j = _g++;
						verb_core_Vec.addMulMutate(v2,verb_core_Binomial.get(l,j) * wders[i][j],SKL[k - i][l - j]);
					}
					verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i),v2);
				}
				verb_core_Vec.mulMutate(1 / wders[0][0],v);
				SKL[k].push(v);
			}
		}
		return SKL;
	}
	static rationalSurfacePoint(surface,u,v) {
		return verb_eval_Eval.dehomogenize(verb_eval_Eval.surfacePoint(surface,u,v));
	}
	static rationalCurveDerivatives(curve,u,numDerivs) {
		if(numDerivs == null) {
			numDerivs = 1;
		}
		let ders = verb_eval_Eval.curveDerivatives(curve,u,numDerivs);
		let Aders = verb_eval_Eval.rational1d(ders);
		let wders = verb_eval_Eval.weight1d(ders);
		let k = 0;
		let i = 0;
		let CK = [];
		let _g = 0;
		let _g1 = numDerivs + 1;
		while(_g < _g1) {
			let k = _g++;
			let v = Aders[k];
			let _g1 = 1;
			let _g2 = k + 1;
			while(_g1 < _g2) {
				let i = _g1++;
				verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i) * wders[i],CK[k - i]);
			}
			verb_core_Vec.mulMutate(1 / wders[0],v);
			CK.push(v);
		}
		return CK;
	}
	static rationalCurvePoint(curve,u) {
		return verb_eval_Eval.dehomogenize(verb_eval_Eval.curvePoint(curve,u));
	}
	static surfaceDerivatives(surface,u,v,numDerivs) {
		let n = surface.knotsU.length - surface.degreeU - 2;
		let m = surface.knotsV.length - surface.degreeV - 2;
		return verb_eval_Eval.surfaceDerivativesGivenNM(n,m,surface,u,v,numDerivs);
	}
	static surfaceDerivativesGivenNM(n,m,surface,u,v,numDerivs) {
		let degreeU = surface.degreeU;
		let degreeV = surface.degreeV;
		let controlPoints = surface.controlPoints;
		let knotsU = surface.knotsU;
		let knotsV = surface.knotsV;
		if(!verb_eval_Eval.areValidRelations(degreeU,controlPoints.length,knotsU.length) || !verb_eval_Eval.areValidRelations(degreeV,controlPoints[0].length,knotsV.length)) {
			throw haxe_Exception.thrown("Invalid relations between control points, knot vector, and n");
		}
		let dim = controlPoints[0][0].length;
		let du = numDerivs < degreeU ? numDerivs : degreeU;
		let dv = numDerivs < degreeV ? numDerivs : degreeV;
		let SKL = verb_core_Vec.zeros3d(numDerivs + 1,numDerivs + 1,dim);
		let knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
		let knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
		let uders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index_u,u,degreeU,n,knotsU);
		let vders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index_v,v,degreeV,m,knotsV);
		let temp = verb_core_Vec.zeros2d(degreeV + 1,dim);
		let dd = 0;
		let _g = 0;
		let _g1 = du + 1;
		while(_g < _g1) {
			let k = _g++;
			let _g1 = 0;
			let _g2 = degreeV + 1;
			while(_g1 < _g2) {
				let s = _g1++;
				temp[s] = verb_core_Vec.zeros1d(dim);
				let _g = 0;
				let _g2 = degreeU + 1;
				while(_g < _g2) {
					let r = _g++;
					verb_core_Vec.addMulMutate(temp[s],uders[k][r],controlPoints[knotSpan_index_u - degreeU + r][knotSpan_index_v - degreeV + s]);
				}
			}
			let nk = numDerivs - k;
			dd = nk < dv ? nk : dv;
			let _g3 = 0;
			let _g4 = dd + 1;
			while(_g3 < _g4) {
				let l = _g3++;
				SKL[k][l] = verb_core_Vec.zeros1d(dim);
				let _g = 0;
				let _g1 = degreeV + 1;
				while(_g < _g1) {
					let s = _g++;
					verb_core_Vec.addMulMutate(SKL[k][l],vders[l][s],temp[s]);
				}
			}
		}
		return SKL;
	}
	static surfacePoint(surface,u,v) {
		let n = surface.knotsU.length - surface.degreeU - 2;
		let m = surface.knotsV.length - surface.degreeV - 2;
		return verb_eval_Eval.surfacePointGivenNM(n,m,surface,u,v);
	}
	static surfacePointGivenNM(n,m,surface,u,v) {
		let degreeU = surface.degreeU;
		let degreeV = surface.degreeV;
		let controlPoints = surface.controlPoints;
		let knotsU = surface.knotsU;
		let knotsV = surface.knotsV;
		if(!verb_eval_Eval.areValidRelations(degreeU,controlPoints.length,knotsU.length) || !verb_eval_Eval.areValidRelations(degreeV,controlPoints[0].length,knotsV.length)) {
			throw haxe_Exception.thrown("Invalid relations between control points, knot vector, and n");
		}
		let dim = controlPoints[0][0].length;
		let knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
		let knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
		let u_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
		let v_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
		let uind = knotSpan_index_u - degreeU;
		let vind = knotSpan_index_v;
		let position = verb_core_Vec.zeros1d(dim);
		let temp = verb_core_Vec.zeros1d(dim);
		let _g = 0;
		let _g1 = degreeV + 1;
		while(_g < _g1) {
			let l = _g++;
			temp = verb_core_Vec.zeros1d(dim);
			vind = knotSpan_index_v - degreeV + l;
			let _g1 = 0;
			let _g2 = degreeU + 1;
			while(_g1 < _g2) {
				let k = _g1++;
				verb_core_Vec.addMulMutate(temp,u_basis_vals[k],controlPoints[uind + k][vind]);
			}
			verb_core_Vec.addMulMutate(position,v_basis_vals[l],temp);
		}
		return position;
	}
	static curveRegularSamplePoints(crv,divs) {
		let derivs = verb_eval_Eval.curveDerivatives(crv,crv.knots[0],crv.degree);
		let t = 1.0 / divs;
		let temp = t * t;
		let f = derivs[0];
		let fd = verb_core_Vec.mul(t,derivs[1]);
		let fdd_per2 = verb_core_Vec.mul(temp * 0.5,derivs[2]);
		let fddd_per2 = verb_core_Vec.mul(temp * t * 0.5,derivs[3]);
		let fdd = verb_core_Vec.add(fdd_per2,fdd_per2);
		let fddd = verb_core_Vec.add(fddd_per2,fddd_per2);
		let fddd_per6 = verb_core_Vec.mul(0.33333333333333331,fddd_per2);
		let pts = [];
		let _g = 0;
		let _g1 = divs + 1;
		while(_g < _g1) {
			let i = _g++;
			pts.push(verb_eval_Eval.dehomogenize(f));
			verb_core_Vec.addAllMutate([f,fd,fdd_per2,fddd_per6]);
			verb_core_Vec.addAllMutate([fd,fdd,fddd_per2]);
			verb_core_Vec.addAllMutate([fdd,fddd]);
			verb_core_Vec.addAllMutate([fdd_per2,fddd_per2]);
		}
		return pts;
	}
	static curveRegularSamplePoints2(crv,divs) {
		let derivs = verb_eval_Eval.curveDerivatives(crv,crv.knots[0],crv.degree);
		let t = 1.0 / divs;
		let temp = t * t;
		let f = derivs[0];
		let fd = verb_core_Vec.mul(t,derivs[1]);
		let fdd_per2 = verb_core_Vec.mul(temp * 0.5,derivs[2]);
		let fddd_per2 = verb_core_Vec.mul(temp * t * 0.5,derivs[3]);
		let fdd = verb_core_Vec.add(fdd_per2,fdd_per2);
		let fddd = verb_core_Vec.add(fddd_per2,fddd_per2);
		let fddd_per6 = verb_core_Vec.mul(0.33333333333333331,fddd_per2);
		let pts = [];
		let _g = 0;
		let _g1 = divs + 1;
		while(_g < _g1) {
			let i = _g++;
			pts.push(verb_eval_Eval.dehomogenize(f));
			verb_core_Vec.addAllMutate([f,fd,fdd_per2,fddd_per6]);
			verb_core_Vec.addAllMutate([fd,fdd,fddd_per2]);
			verb_core_Vec.addAllMutate([fdd,fddd]);
			verb_core_Vec.addAllMutate([fdd_per2,fddd_per2]);
		}
		return pts;
	}
	static rationalSurfaceRegularSampleDerivatives(surface,divsU,divsV,numDerivs) {
		let allders = verb_eval_Eval.surfaceRegularSampleDerivatives(surface,divsU,divsV,numDerivs);
		let allratders = [];
		let divsU1 = divsU + 1;
		let divsV1 = divsV + 1;
		let numDerivs1 = numDerivs + 1;
		let _g = 0;
		let _g1 = divsU1;
		while(_g < _g1) {
			let i = _g++;
			let rowders = [];
			allratders.push(rowders);
			let _g1 = 0;
			let _g2 = divsV1;
			while(_g1 < _g2) {
				let j = _g1++;
				let ders = allders[i][j];
				let Aders = verb_eval_Eval.rational2d(ders);
				let wders = verb_eval_Eval.weight2d(ders);
				let SKL = [];
				let dim = Aders[0][0].length;
				let _g = 0;
				let _g2 = numDerivs1;
				while(_g < _g2) {
					let k = _g++;
					SKL.push([]);
					let _g1 = 0;
					let _g2 = numDerivs1 - k;
					while(_g1 < _g2) {
						let l = _g1++;
						let v = Aders[k][l];
						let _g = 1;
						let _g2 = l + 1;
						while(_g < _g2) {
							let j = _g++;
							verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(l,j) * wders[0][j],SKL[k][l - j]);
						}
						let _g3 = 1;
						let _g4 = k + 1;
						while(_g3 < _g4) {
							let i = _g3++;
							verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i) * wders[i][0],SKL[k - i][l]);
							let v2 = verb_core_Vec.zeros1d(dim);
							let _g = 1;
							let _g1 = l + 1;
							while(_g < _g1) {
								let j = _g++;
								verb_core_Vec.addMulMutate(v2,verb_core_Binomial.get(l,j) * wders[i][j],SKL[k - i][l - j]);
							}
							verb_core_Vec.subMulMutate(v,verb_core_Binomial.get(k,i),v2);
						}
						verb_core_Vec.mulMutate(1 / wders[0][0],v);
						SKL[k].push(v);
					}
				}
				rowders.push(SKL);
			}
		}
		return allratders;
	}
	static surfaceRegularSampleDerivatives(surface,divsU,divsV,numDerivs) {
		let degreeU = surface.degreeU;
		let degreeV = surface.degreeV;
		let controlPoints = surface.controlPoints;
		let knotsU = surface.knotsU;
		let knotsV = surface.knotsV;
		let dim = controlPoints[0][0].length;
		let spanU = (verb_core_ArrayExtensions.last(knotsU) - knotsU[0]) / divsU;
		let spanV = (verb_core_ArrayExtensions.last(knotsV) - knotsV[0]) / divsV;
		let knotSpansBasesU = verb_eval_Eval.regularlySpacedDerivativeBasisFunctions(degreeU,knotsU,divsU);
		let knotSpansU = knotSpansBasesU.item0;
		let basesU = knotSpansBasesU.item1;
		let knotSpansBasesV = verb_eval_Eval.regularlySpacedDerivativeBasisFunctions(degreeV,knotsV,divsV);
		let knotSpansV = knotSpansBasesV.item0;
		let basesV = knotSpansBasesV.item1;
		let pts = [];
		let divsU1 = divsU + 1;
		let divsV1 = divsV + 1;
		let _g = 0;
		let _g1 = divsU1;
		while(_g < _g1) {
			let i = _g++;
			let ptsi = [];
			pts.push(ptsi);
			let _g1 = 0;
			let _g2 = divsV1;
			while(_g1 < _g2) {
				let j = _g1++;
				ptsi.push(verb_eval_Eval.surfaceDerivativesGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU[i],knotSpansV[j],basesU[i],basesV[j],dim,numDerivs));
			}
		}
		return pts;
	}
	static rationalSurfaceRegularSamplePoints(surface,divsU,divsV) {
		return verb_eval_Eval.dehomogenize2d(verb_eval_Eval.surfaceRegularSamplePoints(surface,divsU,divsV));
	}
	static surfaceRegularSamplePoints(surface,divsU,divsV) {
		let degreeU = surface.degreeU;
		let degreeV = surface.degreeV;
		let controlPoints = surface.controlPoints;
		let knotsU = surface.knotsU;
		let knotsV = surface.knotsV;
		let dim = controlPoints[0][0].length;
		let spanU = (verb_core_ArrayExtensions.last(knotsU) - knotsU[0]) / divsU;
		let spanV = (verb_core_ArrayExtensions.last(knotsV) - knotsV[0]) / divsV;
		let knotSpansBasesU = verb_eval_Eval.regularlySpacedBasisFunctions(degreeU,knotsU,divsU);
		let knotSpansU = knotSpansBasesU.item0;
		let basesU = knotSpansBasesU.item1;
		let knotSpansBasesV = verb_eval_Eval.regularlySpacedBasisFunctions(degreeV,knotsV,divsV);
		let knotSpansV = knotSpansBasesV.item0;
		let basesV = knotSpansBasesV.item1;
		let pts = [];
		let divsU1 = divsU + 1;
		let divsV1 = divsV + 1;
		let _g = 0;
		let _g1 = divsU1;
		while(_g < _g1) {
			let i = _g++;
			let ptsi = [];
			pts.push(ptsi);
			let _g1 = 0;
			let _g2 = divsV1;
			while(_g1 < _g2) {
				let j = _g1++;
				ptsi.push(verb_eval_Eval.surfacePointGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU[i],knotSpansV[j],basesU[i],basesV[j],dim));
			}
		}
		return pts;
	}
	static regularlySpacedBasisFunctions(degree,knots,divs) {
		let n = knots.length - degree - 2;
		let span = (verb_core_ArrayExtensions.last(knots) - knots[0]) / divs;
		let bases = [];
		let knotspans = [];
		let u = knots[0];
		let knotIndex = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
		let div1 = divs + 1;
		let _g = 0;
		let _g1 = div1;
		while(_g < _g1) {
			let i = _g++;
			while(u >= knots[knotIndex + 1]) ++knotIndex;
			knotspans.push(knotIndex);
			bases.push(verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotIndex,u,degree,knots));
			u += span;
		}
		return new verb_core_Pair(knotspans,bases);
	}
	static regularlySpacedDerivativeBasisFunctions(degree,knots,divs) {
		let n = knots.length - degree - 2;
		let span = (verb_core_ArrayExtensions.last(knots) - knots[0]) / divs;
		let bases = [];
		let knotspans = [];
		let u = knots[0];
		let knotIndex = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
		let div1 = divs + 1;
		let _g = 0;
		let _g1 = div1;
		while(_g < _g1) {
			let i = _g++;
			while(u >= knots[knotIndex + 1]) ++knotIndex;
			knotspans.push(knotIndex);
			bases.push(verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotIndex,u,degree,n,knots));
			u += span;
		}
		return new verb_core_Pair(knotspans,bases);
	}
	static surfacePointGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpanU,knotSpanV,basesU,basesV,dim) {
		let position = verb_core_Vec.zeros1d(dim);
		let temp;
		let uind = knotSpanU - degreeU;
		let vind = knotSpanV - degreeV;
		let _g = 0;
		let _g1 = degreeV + 1;
		while(_g < _g1) {
			let l = _g++;
			temp = verb_core_Vec.zeros1d(dim);
			let _g1 = 0;
			let _g2 = degreeU + 1;
			while(_g1 < _g2) {
				let k = _g1++;
				verb_core_Vec.addMulMutate(temp,basesU[k],controlPoints[uind + k][vind]);
			}
			++vind;
			verb_core_Vec.addMulMutate(position,basesV[l],temp);
		}
		return position;
	}
	static surfaceDerivativesGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpanU,knotSpanV,basesU,basesV,dim,numDerivs) {
		let dim1 = controlPoints[0][0].length;
		let du = numDerivs < degreeU ? numDerivs : degreeU;
		let dv = numDerivs < degreeV ? numDerivs : degreeV;
		let SKL = verb_core_Vec.zeros3d(du + 1,dv + 1,dim1);
		let temp = verb_core_Vec.zeros2d(degreeV + 1,dim1);
		let dd = 0;
		let _g = 0;
		let _g1 = du + 1;
		while(_g < _g1) {
			let k = _g++;
			let _g1 = 0;
			let _g2 = degreeV + 1;
			while(_g1 < _g2) {
				let s = _g1++;
				temp[s] = verb_core_Vec.zeros1d(dim1);
				let _g = 0;
				let _g2 = degreeU + 1;
				while(_g < _g2) {
					let r = _g++;
					verb_core_Vec.addMulMutate(temp[s],basesU[k][r],controlPoints[knotSpanU - degreeU + r][knotSpanV - degreeV + s]);
				}
			}
			let nk = numDerivs - k;
			dd = nk < dv ? nk : dv;
			let _g3 = 0;
			let _g4 = dd + 1;
			while(_g3 < _g4) {
				let l = _g3++;
				SKL[k][l] = verb_core_Vec.zeros1d(dim1);
				let _g = 0;
				let _g1 = degreeV + 1;
				while(_g < _g1) {
					let s = _g++;
					verb_core_Vec.addMulMutate(SKL[k][l],basesV[l][s],temp[s]);
				}
			}
		}
		return SKL;
	}
	static curveDerivatives(crv,u,numDerivs) {
		let n = crv.knots.length - crv.degree - 2;
		return verb_eval_Eval.curveDerivativesGivenN(n,crv,u,numDerivs);
	}
	static curveDerivativesGivenN(n,curve,u,numDerivs) {
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		if(!verb_eval_Eval.areValidRelations(degree,controlPoints.length,knots.length)) {
			throw haxe_Exception.thrown("Invalid relations between control points, knot vector, and n");
		}
		let dim = controlPoints[0].length;
		let du = numDerivs < degree ? numDerivs : degree;
		let CK = verb_core_Vec.zeros2d(numDerivs + 1,dim);
		let knotSpan_index = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
		let nders = verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,du,knots);
		let k = 0;
		let j = 0;
		let _g = 0;
		let _g1 = du + 1;
		while(_g < _g1) {
			let k = _g++;
			let _g1 = 0;
			let _g2 = degree + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				verb_core_Vec.addMulMutate(CK[k],nders[k][j],controlPoints[knotSpan_index - degree + j]);
			}
		}
		return CK;
	}
	static curvePoint(curve,u) {
		let n = curve.knots.length - curve.degree - 2;
		return verb_eval_Eval.curvePointGivenN(n,curve,u);
	}
	static areValidRelations(degree,num_controlPoints,knots_length) {
		return num_controlPoints + degree + 1 - knots_length == 0;
	}
	static curvePointGivenN(n,curve,u) {
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		if(!verb_eval_Eval.areValidRelations(degree,controlPoints.length,knots.length)) {
			throw haxe_Exception.thrown("Invalid relations between control points, knot Array, and n");
		}
		let knotSpan_index = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
		let basis_values = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
		let position = verb_core_Vec.zeros1d(controlPoints[0].length);
		let _g = 0;
		let _g1 = degree + 1;
		while(_g < _g1) {
			let j = _g++;
			verb_core_Vec.addMulMutate(position,basis_values[j],controlPoints[knotSpan_index - degree + j]);
		}
		return position;
	}
	static volumePoint(volume,u,v,w) {
		let n = volume.knotsU.length - volume.degreeU - 2;
		let m = volume.knotsV.length - volume.degreeV - 2;
		let l = volume.knotsW.length - volume.degreeW - 2;
		return verb_eval_Eval.volumePointGivenNML(volume,n,m,l,u,v,w);
	}
	static volumePointGivenNML(volume,n,m,l,u,v,w) {
		if(!verb_eval_Eval.areValidRelations(volume.degreeU,volume.controlPoints.length,volume.knotsU.length) || !verb_eval_Eval.areValidRelations(volume.degreeV,volume.controlPoints[0].length,volume.knotsV.length) || !verb_eval_Eval.areValidRelations(volume.degreeW,volume.controlPoints[0][0].length,volume.knotsW.length)) {
			throw haxe_Exception.thrown("Invalid relations between control points and knot vector");
		}
		let controlPoints = volume.controlPoints;
		let degreeU = volume.degreeU;
		let degreeV = volume.degreeV;
		let degreeW = volume.degreeW;
		let knotsU = volume.knotsU;
		let knotsV = volume.knotsV;
		let knotsW = volume.knotsW;
		let dim = controlPoints[0][0][0].length;
		let knotSpan_index_u = verb_eval_Eval.knotSpanGivenN(n,degreeU,u,knotsU);
		let knotSpan_index_v = verb_eval_Eval.knotSpanGivenN(m,degreeV,v,knotsV);
		let knotSpan_index_w = verb_eval_Eval.knotSpanGivenN(l,degreeW,w,knotsW);
		let u_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
		let v_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
		let w_basis_vals = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index_w,w,degreeW,knotsW);
		let uind = knotSpan_index_u - degreeU;
		let position = verb_core_Vec.zeros1d(dim);
		let temp = verb_core_Vec.zeros1d(dim);
		let temp2 = verb_core_Vec.zeros1d(dim);
		let _g = 0;
		let _g1 = degreeW + 1;
		while(_g < _g1) {
			let i = _g++;
			temp2 = verb_core_Vec.zeros1d(dim);
			let wind = knotSpan_index_w - degreeW + i;
			let _g1 = 0;
			let _g2 = degreeV + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				temp = verb_core_Vec.zeros1d(dim);
				let vind = knotSpan_index_v - degreeV + j;
				let _g = 0;
				let _g2 = degreeU + 1;
				while(_g < _g2) {
					let k = _g++;
					verb_core_Vec.addMulMutate(temp,u_basis_vals[k],controlPoints[uind + k][vind][wind]);
				}
				verb_core_Vec.addMulMutate(temp2,v_basis_vals[j],temp);
			}
			verb_core_Vec.addMulMutate(position,w_basis_vals[i],temp2);
		}
		return position;
	}
	static derivativeBasisFunctions(u,degree,knots) {
		let knotSpan_index = verb_eval_Eval.knotSpan(degree,u,knots);
		let m = knots.length - 1;
		let n = m - degree - 1;
		return verb_eval_Eval.derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,n,knots);
	}
	static derivativeBasisFunctionsGivenNI(knotIndex,u,p,n,knots) {
		let ndu = verb_core_Vec.zeros2d(p + 1,p + 1);
		let left = verb_core_Vec.zeros1d(p + 1);
		let right = verb_core_Vec.zeros1d(p + 1);
		let saved = 0.0;
		let temp = 0.0;
		ndu[0][0] = 1.0;
		let _g = 1;
		let _g1 = p + 1;
		while(_g < _g1) {
			let j = _g++;
			left[j] = u - knots[knotIndex + 1 - j];
			right[j] = knots[knotIndex + j] - u;
			saved = 0.0;
			let _g1 = 0;
			let _g2 = j;
			while(_g1 < _g2) {
				let r = _g1++;
				ndu[j][r] = right[r + 1] + left[j - r];
				temp = ndu[r][j - 1] / ndu[j][r];
				ndu[r][j] = saved + right[r + 1] * temp;
				saved = left[j - r] * temp;
			}
			ndu[j][j] = saved;
		}
		let ders = verb_core_Vec.zeros2d(n + 1,p + 1);
		let a = verb_core_Vec.zeros2d(2,p + 1);
		let s1 = 0;
		let s2 = 1;
		let d = 0.0;
		let rk = 0;
		let pk = 0;
		let j1 = 0;
		let j2 = 0;
		let _g2 = 0;
		let _g3 = p + 1;
		while(_g2 < _g3) {
			let j = _g2++;
			ders[0][j] = ndu[j][p];
		}
		let _g4 = 0;
		let _g5 = p + 1;
		while(_g4 < _g5) {
			let r = _g4++;
			s1 = 0;
			s2 = 1;
			a[0][0] = 1.0;
			let _g = 1;
			let _g1 = n + 1;
			while(_g < _g1) {
				let k = _g++;
				d = 0.0;
				rk = r - k;
				pk = p - k;
				if(r >= k) {
					a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
					d = a[s2][0] * ndu[rk][pk];
				}
				if(rk >= -1) {
					j1 = 1;
				} else {
					j1 = -rk;
				}
				if(r - 1 <= pk) {
					j2 = k - 1;
				} else {
					j2 = p - r;
				}
				let _g1 = j1;
				let _g2 = j2 + 1;
				while(_g1 < _g2) {
					let j = _g1++;
					a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];
					d += a[s2][j] * ndu[rk + j][pk];
				}
				if(r <= pk) {
					a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];
					d += a[s2][k] * ndu[r][pk];
				}
				ders[k][r] = d;
				let temp = s1;
				s1 = s2;
				s2 = temp;
			}
		}
		let acc = p;
		let _g6 = 1;
		let _g7 = n + 1;
		while(_g6 < _g7) {
			let k = _g6++;
			let _g = 0;
			let _g1 = p + 1;
			while(_g < _g1) {
				let j = _g++;
				ders[k][j] *= acc;
			}
			acc *= p - k;
		}
		return ders;
	}
	static basisFunctions(u,degree,knots) {
		let knotSpan_index = verb_eval_Eval.knotSpan(degree,u,knots);
		return verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
	}
	static basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots) {
		let basisFunctions = verb_core_Vec.zeros1d(degree + 1);
		let left = verb_core_Vec.zeros1d(degree + 1);
		let right = verb_core_Vec.zeros1d(degree + 1);
		let saved = 0;
		let temp = 0;
		basisFunctions[0] = 1.0;
		let _g = 1;
		let _g1 = degree + 1;
		while(_g < _g1) {
			let j = _g++;
			left[j] = u - knots[knotSpan_index + 1 - j];
			right[j] = knots[knotSpan_index + j] - u;
			saved = 0.0;
			let _g1 = 0;
			let _g2 = j;
			while(_g1 < _g2) {
				let r = _g1++;
				temp = basisFunctions[r] / (right[r + 1] + left[j - r]);
				basisFunctions[r] = saved + right[r + 1] * temp;
				saved = left[j - r] * temp;
			}
			basisFunctions[j] = saved;
		}
		return basisFunctions;
	}
	static knotSpan(degree,u,knots) {
		return verb_eval_Eval.knotSpanGivenN(knots.length - degree - 2,degree,u,knots);
	}
	static knotSpanGivenN(n,degree,u,knots) {
		if(u > knots[n + 1] - verb_core_Constants.EPSILON) {
			return n;
		}
		if(u < knots[degree] + verb_core_Constants.EPSILON) {
			return degree;
		}
		let low = degree;
		let high = n + 1;
		let mid = Math.floor((low + high) / 2);
		while(u < knots[mid] || u >= knots[mid + 1]) {
			if(u < knots[mid]) {
				high = mid;
			} else {
				low = mid;
			}
			mid = Math.floor((low + high) / 2);
		}
		return mid;
	}
	static dehomogenize(homoPoint) {
		let dim = homoPoint.length;
		let point = [];
		let wt = homoPoint[dim - 1];
		let l = homoPoint.length - 1;
		let _g = 0;
		let _g1 = l;
		while(_g < _g1) {
			let i = _g++;
			point.push(homoPoint[i] / wt);
		}
		return point;
	}
	static rational1d(homoPoints) {
		let dim = homoPoints[0].length - 1;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = homoPoints[i].slice(0,dim);
		}
		return result;
	}
	static rational2d(homoPoints) {
		let f = verb_eval_Eval.rational1d;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(homoPoints[i]);
		}
		return result;
	}
	static weight1d(homoPoints) {
		let dim = homoPoints[0].length - 1;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = homoPoints[i][dim];
		}
		return result;
	}
	static weight2d(homoPoints) {
		let f = verb_eval_Eval.weight1d;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(homoPoints[i]);
		}
		return result;
	}
	static dehomogenize1d(homoPoints) {
		let f = verb_eval_Eval.dehomogenize;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(homoPoints[i]);
		}
		return result;
	}
	static dehomogenize2d(homoPoints) {
		let f = verb_eval_Eval.dehomogenize1d;
		let result = new Array(homoPoints.length);
		let _g = 0;
		let _g1 = homoPoints.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(homoPoints[i]);
		}
		return result;
	}
	static homogenize1d(controlPoints,weights) {
		let rows = controlPoints.length;
		let dim = controlPoints[0].length;
		let homo_controlPoints = [];
		let wt = 0.0;
		let ref_pt = [];
		let weights1 = weights != null ? weights : verb_core_Vec.fill(controlPoints.length,1.0);
		let _g = 0;
		let _g1 = rows;
		while(_g < _g1) {
			let i = _g++;
			let pt = [];
			ref_pt = controlPoints[i];
			wt = weights1[i];
			let _g1 = 0;
			let _g2 = dim;
			while(_g1 < _g2) {
				let k = _g1++;
				pt.push(ref_pt[k] * wt);
			}
			pt.push(wt);
			homo_controlPoints.push(pt);
		}
		return homo_controlPoints;
	}
	static homogenize2d(controlPoints,weights) {
		let rows = controlPoints.length;
		let homo_controlPoints = [];
		let weights1;
		if(weights != null) {
			weights1 = weights;
		} else {
			let _g = [];
			let _g1 = 0;
			let _g2 = rows;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(verb_core_Vec.fill(controlPoints[0].length,1.0));
			}
			weights1 = _g;
		}
		let _g = 0;
		let _g1 = rows;
		while(_g < _g1) {
			let i = _g++;
			homo_controlPoints.push(verb_eval_Eval.homogenize1d(controlPoints[i],weights1[i]));
		}
		return homo_controlPoints;
	}
}
$hxClasses["verb.eval.Eval"] = $hx_exports["eval"]["Eval"] = verb_eval_Eval;
verb_eval_Eval.__name__ = "verb.eval.Eval";
class verb_eval_Intersect {
	static surfaces(surface0,surface1,tol) {
		let tess1 = verb_eval_Tess.rationalSurfaceAdaptive(surface0);
		let tess2 = verb_eval_Tess.rationalSurfaceAdaptive(surface1);
		let resApprox = verb_eval_Intersect.meshes(tess1,tess2);
		let result = new Array(resApprox.length);
		let _g = 0;
		let _g1 = resApprox.length;
		while(_g < _g1) {
			let i = _g++;
			let pl = resApprox[i];
			let result1 = new Array(pl.length);
			let _g1 = 0;
			let _g2 = pl.length;
			while(_g1 < _g2) {
				let i = _g1++;
				let inter = pl[i];
				result1[i] = verb_eval_Intersect.surfacesAtPointWithEstimate(surface0,surface1,inter.uv0,inter.uv1,tol);
			}
			result[i] = result1;
		}
		let exactPls = result;
		let result1 = new Array(exactPls.length);
		let _g2 = 0;
		let _g3 = exactPls.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let x = exactPls[i];
			let result = new Array(x.length);
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = x[i].point;
			}
			result1[i] = verb_eval_Make.rationalInterpCurve(result,3);
		}
		return result1;
	}
	static surfacesAtPointWithEstimate(surface0,surface1,uv1,uv2,tol) {
		let pds;
		let p;
		let pn;
		let pu;
		let pv;
		let pd;
		let qds;
		let q;
		let qn;
		let qu;
		let qv;
		let qd;
		let dist;
		let maxits = 5;
		let its = 0;
		while(true) {
			pds = verb_eval_Eval.rationalSurfaceDerivatives(surface0,uv1[0],uv1[1],1);
			p = pds[0][0];
			pu = pds[1][0];
			pv = pds[0][1];
			pn = verb_core_Vec.normalized(verb_core_Vec.cross(pu,pv));
			pd = verb_core_Vec.dot(pn,p);
			qds = verb_eval_Eval.rationalSurfaceDerivatives(surface1,uv2[0],uv2[1],1);
			q = qds[0][0];
			qu = qds[1][0];
			qv = qds[0][1];
			qn = verb_core_Vec.normalized(verb_core_Vec.cross(qu,qv));
			qd = verb_core_Vec.dot(qn,q);
			dist = verb_core_Vec.distSquared(p,q);
			if(dist < tol * tol) {
				break;
			}
			let fn = verb_core_Vec.normalized(verb_core_Vec.cross(pn,qn));
			let fd = verb_core_Vec.dot(fn,p);
			let x = verb_eval_Intersect.threePlanes(pn,pd,qn,qd,fn,fd);
			if(x == null) {
				throw haxe_Exception.thrown("panic!");
			}
			let pdif = verb_core_Vec.sub(x,p);
			let qdif = verb_core_Vec.sub(x,q);
			let rw = verb_core_Vec.cross(pu,pn);
			let rt = verb_core_Vec.cross(pv,pn);
			let su = verb_core_Vec.cross(qu,qn);
			let sv = verb_core_Vec.cross(qv,qn);
			let dw = verb_core_Vec.dot(rt,pdif) / verb_core_Vec.dot(rt,pu);
			let dt = verb_core_Vec.dot(rw,pdif) / verb_core_Vec.dot(rw,pv);
			let du = verb_core_Vec.dot(sv,qdif) / verb_core_Vec.dot(sv,qu);
			let dv = verb_core_Vec.dot(su,qdif) / verb_core_Vec.dot(su,qv);
			uv1 = verb_core_Vec.add([dw,dt],uv1);
			uv2 = verb_core_Vec.add([du,dv],uv2);
			++its;
			if(!(its < maxits)) {
				break;
			}
		}
		return new verb_core_SurfaceSurfaceIntersectionPoint(uv1,uv2,p,dist);
	}
	static meshes(mesh0,mesh1,bbtree0,bbtree1) {
		if(bbtree0 == null) {
			bbtree0 = new verb_core_LazyMeshBoundingBoxTree(mesh0);
		}
		if(bbtree1 == null) {
			bbtree1 = new verb_core_LazyMeshBoundingBoxTree(mesh1);
		}
		let bbints = verb_eval_Intersect.boundingBoxTrees(bbtree0,bbtree1,0);
		let result = new Array(bbints.length);
		let _g = 0;
		let _g1 = bbints.length;
		while(_g < _g1) {
			let i = _g++;
			let ids = bbints[i];
			result[i] = verb_eval_Intersect.triangles(mesh0,ids.item0,mesh1,ids.item1);
		}
		let _g2 = [];
		let _g3 = 0;
		let _g4 = result;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(v != null) {
				_g2.push(v);
			}
		}
		let _g5 = [];
		let _g6 = 0;
		let _g7 = _g2;
		while(_g6 < _g7.length) {
			let v = _g7[_g6];
			++_g6;
			if(verb_core_Vec.distSquared(v.min.point,v.max.point) > verb_core_Constants.EPSILON) {
				_g5.push(v);
			}
		}
		let segments = verb_core_ArrayExtensions.unique(_g5,function(a,b) {
			let s1 = verb_core_Vec.sub(a.min.uv0,b.min.uv0);
			let d1 = verb_core_Vec.dot(s1,s1);
			let s2 = verb_core_Vec.sub(a.max.uv0,b.max.uv0);
			let d2 = verb_core_Vec.dot(s2,s2);
			let s3 = verb_core_Vec.sub(a.min.uv0,b.max.uv0);
			let d3 = verb_core_Vec.dot(s3,s3);
			let s4 = verb_core_Vec.sub(a.max.uv0,b.min.uv0);
			let d4 = verb_core_Vec.dot(s4,s4);
			if(!(d1 < verb_core_Constants.EPSILON && d2 < verb_core_Constants.EPSILON)) {
				if(d3 < verb_core_Constants.EPSILON) {
					return d4 < verb_core_Constants.EPSILON;
				} else {
					return false;
				}
			} else {
				return true;
			}
		});
		return verb_eval_Intersect.makeMeshIntersectionPolylines(segments);
	}
	static meshSlices(mesh,min,max,step) {
		let bbtree = new verb_core_MeshBoundingBoxTree(mesh);
		let bb = bbtree.boundingBox();
		let x0 = bb.min[0];
		let y0 = bb.min[1];
		let x1 = bb.max[0];
		let y1 = bb.max[1];
		let span = verb_core_Vec.span(min,max,step);
		let slices = [];
		let _g = 0;
		while(_g < span.length) {
			let z = span[_g];
			++_g;
			let pts = [[x0,y0,z],[x1,y0,z],[x1,y1,z],[x0,y1,z]];
			let uvs = [[0.0,0.0],[1.0,0.0],[1.0,1.0],[0.0,1.0]];
			let faces = [[0,1,2],[0,2,3]];
			let plane = new verb_core_MeshData(faces,pts,null,uvs);
			slices.push(verb_eval_Intersect.meshes(mesh,plane,bbtree));
		}
		return slices;
	}
	static makeMeshIntersectionPolylines(segments) {
		if(segments.length == 0) {
			return [];
		}
		let _g = 0;
		while(_g < segments.length) {
			let s = segments[_g];
			++_g;
			s.max.opp = s.min;
			s.min.opp = s.max;
		}
		let tree = verb_eval_Intersect.kdTreeFromSegments(segments);
		let ends = [];
		let _g1 = 0;
		while(_g1 < segments.length) {
			let seg = segments[_g1];
			++_g1;
			ends.push(seg.min);
			ends.push(seg.max);
		}
		let _g2 = 0;
		while(_g2 < ends.length) {
			let segEnd = ends[_g2];
			++_g2;
			if(segEnd.adj != null) {
				continue;
			}
			let adjEnd = verb_eval_Intersect.lookupAdjacentSegment(segEnd,tree,segments.length);
			if(adjEnd != null && adjEnd.adj == null) {
				segEnd.adj = adjEnd;
				adjEnd.adj = segEnd;
			}
		}
		let _g3 = [];
		let _g4 = 0;
		let _g5 = ends;
		while(_g4 < _g5.length) {
			let v = _g5[_g4];
			++_g4;
			if(v.adj == null) {
				_g3.push(v);
			}
		}
		let freeEnds = _g3;
		if(freeEnds.length == 0) {
			freeEnds = ends;
		}
		let pls = [];
		let numVisitedEnds = 0;
		let loopDetected = false;
		while(freeEnds.length != 0) {
			let end = freeEnds.pop();
			if(!end.visited) {
				let pl = [];
				let curEnd = end;
				while(curEnd != null) {
					if(curEnd.visited) {
						break;
					}
					curEnd.visited = true;
					curEnd.opp.visited = true;
					pl.push(curEnd);
					numVisitedEnds += 2;
					curEnd = curEnd.opp.adj;
					if(curEnd == end) {
						break;
					}
				}
				if(pl.length > 0) {
					pl.push(pl[pl.length - 1].opp);
					pls.push(pl);
				}
			}
			if(freeEnds.length == 0 && ends.length > 0 && (loopDetected || numVisitedEnds < ends.length)) {
				loopDetected = true;
				let e = ends.pop();
				freeEnds.push(e);
			}
		}
		return pls;
	}
	static kdTreeFromSegments(segments) {
		let treePoints = [];
		let _g = 0;
		while(_g < segments.length) {
			let seg = segments[_g];
			++_g;
			treePoints.push(new verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint(seg.min.point,seg.min));
			treePoints.push(new verb_core_KdPoint_$verb_$core_$MeshIntersectionPoint(seg.max.point,seg.max));
		}
		return new verb_core_KdTree_$verb_$core_$MeshIntersectionPoint(treePoints,verb_core_Vec.distSquared);
	}
	static lookupAdjacentSegment(segEnd,tree,numResults) {
		let _g = [];
		let _g1 = 0;
		let _g2 = tree.nearest(segEnd.point,numResults,verb_core_Constants.EPSILON);
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(segEnd != v.obj.obj) {
				_g.push(v);
			}
		}
		let _this = _g;
		let result = new Array(_this.length);
		let _g3 = 0;
		let _g4 = _this.length;
		while(_g3 < _g4) {
			let i = _g3++;
			result[i] = _this[i].obj.obj;
		}
		let adj = result;
		if(adj.length == 1) {
			return adj[0];
		} else {
			return null;
		}
	}
	static curveAndSurface(curve,surface,tol,crvBbTree,srfBbTree) {
		if(tol == null) {
			tol = 1e-3;
		}
		if(crvBbTree == null) {
			crvBbTree = new verb_core_LazyCurveBoundingBoxTree(curve);
		}
		if(srfBbTree == null) {
			srfBbTree = new verb_core_LazySurfaceBoundingBoxTree(surface);
		}
		let ints = verb_eval_Intersect.boundingBoxTrees(crvBbTree,srfBbTree,tol);
		let result = new Array(ints.length);
		let _g = 0;
		let _g1 = ints.length;
		while(_g < _g1) {
			let i = _g++;
			let inter = ints[i];
			let crvSeg = inter.item0;
			let srfPart = inter.item1;
			let min = verb_core_ArrayExtensions.first(crvSeg.knots);
			let max = verb_core_ArrayExtensions.last(crvSeg.knots);
			let u = (min + max) / 2.0;
			let minu = verb_core_ArrayExtensions.first(srfPart.knotsU);
			let maxu = verb_core_ArrayExtensions.last(srfPart.knotsU);
			let minv = verb_core_ArrayExtensions.first(srfPart.knotsV);
			let maxv = verb_core_ArrayExtensions.last(srfPart.knotsV);
			let uv = [(minu + maxu) / 2.0,(minv + maxv) / 2.0];
			result[i] = verb_eval_Intersect.curveAndSurfaceWithEstimate(crvSeg,srfPart,[u].concat(uv),tol);
		}
		let _g2 = [];
		let _g3 = 0;
		let _g4 = result;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(verb_core_Vec.distSquared(v.curvePoint,v.surfacePoint) < tol * tol) {
				_g2.push(v);
			}
		}
		return verb_core_ArrayExtensions.unique(_g2,function(a,b) {
			return Math.abs(a.u - b.u) < 0.5 * tol;
		});
	}
	static curveAndSurfaceWithEstimate(curve,surface,start_params,tol) {
		if(tol == null) {
			tol = 1e-3;
		}
		let objective = function(x) {
			let p1 = verb_eval_Eval.rationalCurvePoint(curve,x[0]);
			let p2 = verb_eval_Eval.rationalSurfacePoint(surface,x[1],x[2]);
			let p1_p2 = verb_core_Vec.sub(p1,p2);
			return verb_core_Vec.dot(p1_p2,p1_p2);
		};
		let grad = function(x) {
			let dc = verb_eval_Eval.rationalCurveDerivatives(curve,x[0],1);
			let ds = verb_eval_Eval.rationalSurfaceDerivatives(surface,x[1],x[2],1);
			let r = verb_core_Vec.sub(ds[0][0],dc[0]);
			let drdt = verb_core_Vec.mul(-1.0,dc[1]);
			let drdu = ds[1][0];
			let drdv = ds[0][1];
			return [2.0 * verb_core_Vec.dot(drdt,r),2.0 * verb_core_Vec.dot(drdu,r),2.0 * verb_core_Vec.dot(drdv,r)];
		};
		let sol_obj = verb_core_Minimizer.uncmin(objective,start_params,tol * tol,grad);
		let finalSolution = sol_obj.solution;
		return new verb_core_CurveSurfaceIntersection(finalSolution[0],[finalSolution[1],finalSolution[2]],verb_eval_Eval.rationalCurvePoint(curve,finalSolution[0]),verb_eval_Eval.rationalSurfacePoint(surface,finalSolution[1],finalSolution[2]));
	}
	static polylineAndMesh(polyline,mesh,tol) {
		let res = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyPolylineBoundingBoxTree(polyline),new verb_core_LazyMeshBoundingBoxTree(mesh),tol);
		let finalResults = [];
		let _g = 0;
		while(_g < res.length) {
			let event = res[_g];
			++_g;
			let polid = event.item0;
			let faceid = event.item1;
			let inter = verb_eval_Intersect.segmentWithTriangle(polyline.points[polid],polyline.points[polid + 1],mesh.points,mesh.faces[faceid]);
			if(inter == null) {
				continue;
			}
			let pt = inter.point;
			let u = verb_core_Vec.lerp(inter.p,[polyline.params[polid]],[polyline.params[polid + 1]])[0];
			let uv = verb_core_Mesh.triangleUVFromPoint(mesh,faceid,pt);
			finalResults.push(new verb_core_PolylineMeshIntersection(pt,u,uv,polid,faceid));
		}
		return finalResults;
	}
	static boundingBoxTrees(ai,bi,tol) {
		if(tol == null) {
			tol = 1e-9;
		}
		let atrees = [];
		let btrees = [];
		atrees.push(ai);
		btrees.push(bi);
		let results = [];
		while(atrees.length > 0) {
			let a = atrees.pop();
			let b = btrees.pop();
			if(a.empty() || b.empty()) {
				continue;
			}
			if(!a.boundingBox().intersects(b.boundingBox(),tol)) {
				continue;
			}
			let ai = a.indivisible(tol);
			let bi = b.indivisible(tol);
			if(ai && bi) {
				results.push(new verb_core_Pair(a.yield(),b.yield()));
				continue;
			} else if(ai && !bi) {
				let bs = b.split();
				atrees.push(a);
				btrees.push(bs.item1);
				atrees.push(a);
				btrees.push(bs.item0);
				continue;
			} else if(!ai && bi) {
				let as = a.split();
				atrees.push(as.item1);
				btrees.push(b);
				atrees.push(as.item0);
				btrees.push(b);
				continue;
			}
			let as = a.split();
			let bs = b.split();
			atrees.push(as.item1);
			btrees.push(bs.item1);
			atrees.push(as.item1);
			btrees.push(bs.item0);
			atrees.push(as.item0);
			btrees.push(bs.item1);
			atrees.push(as.item0);
			btrees.push(bs.item0);
		}
		return results;
	}
	static curves(curve1,curve2,tolerance) {
		let ints = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyCurveBoundingBoxTree(curve1),new verb_core_LazyCurveBoundingBoxTree(curve2),0);
		let result = new Array(ints.length);
		let _g = 0;
		let _g1 = ints.length;
		while(_g < _g1) {
			let i = _g++;
			let x = ints[i];
			result[i] = verb_eval_Intersect.curvesWithEstimate(curve1,curve2,verb_core_ArrayExtensions.first(x.item0.knots),verb_core_ArrayExtensions.first(x.item1.knots),tolerance);
		}
		let _g2 = [];
		let _g3 = 0;
		let _g4 = result;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(verb_core_Vec.distSquared(v.point0,v.point1) < tolerance) {
				_g2.push(v);
			}
		}
		return verb_core_ArrayExtensions.unique(_g2,function(a,b) {
			return Math.abs(a.u0 - b.u0) < tolerance * 5;
		});
	}
	static curvesWithEstimate(curve0,curve1,u0,u1,tolerance) {
		let objective = function(x) {
			let p1 = verb_eval_Eval.rationalCurvePoint(curve0,x[0]);
			let p2 = verb_eval_Eval.rationalCurvePoint(curve1,x[1]);
			let p1_p2 = verb_core_Vec.sub(p1,p2);
			return verb_core_Vec.dot(p1_p2,p1_p2);
		};
		let grad = function(x) {
			let dc0 = verb_eval_Eval.rationalCurveDerivatives(curve0,x[0],1);
			let dc1 = verb_eval_Eval.rationalCurveDerivatives(curve1,x[1],1);
			let r = verb_core_Vec.sub(dc0[0],dc1[0]);
			let drdu = dc0[1];
			let drdt = verb_core_Vec.mul(-1.0,dc1[1]);
			return [2.0 * verb_core_Vec.dot(drdu,r),2.0 * verb_core_Vec.dot(drdt,r)];
		};
		let sol_obj = verb_core_Minimizer.uncmin(objective,[u0,u1],tolerance * tolerance,grad);
		let u11 = sol_obj.solution[0];
		let u2 = sol_obj.solution[1];
		let p1 = verb_eval_Eval.rationalCurvePoint(curve0,u11);
		let p2 = verb_eval_Eval.rationalCurvePoint(curve1,u2);
		return new verb_core_CurveCurveIntersection(p1,p2,u11,u2);
	}
	static triangles(mesh0,faceIndex0,mesh1,faceIndex1) {
		let tri0 = mesh0.faces[faceIndex0];
		let tri1 = mesh1.faces[faceIndex1];
		let n0 = verb_core_Mesh.getTriangleNorm(mesh0.points,tri0);
		let n1 = verb_core_Mesh.getTriangleNorm(mesh1.points,tri1);
		let o0 = mesh0.points[tri0[0]];
		let o1 = mesh1.points[tri1[0]];
		let ray = verb_eval_Intersect.planes(o0,n0,o1,n1);
		if(ray == null) {
			return null;
		}
		let clip1 = verb_eval_Intersect.clipRayInCoplanarTriangle(ray,mesh0,faceIndex0);
		if(clip1 == null) {
			return null;
		}
		let clip2 = verb_eval_Intersect.clipRayInCoplanarTriangle(ray,mesh1,faceIndex1);
		if(clip2 == null) {
			return null;
		}
		let merged = verb_eval_Intersect.mergeTriangleClipIntervals(clip1,clip2,mesh0,faceIndex0,mesh1,faceIndex1);
		if(merged == null) {
			return null;
		}
		return new verb_core_Interval(new verb_core_MeshIntersectionPoint(merged.min.uv0,merged.min.uv1,merged.min.point,faceIndex0,faceIndex1),new verb_core_MeshIntersectionPoint(merged.max.uv0,merged.max.uv1,merged.max.point,faceIndex0,faceIndex1));
	}
	static clipRayInCoplanarTriangle(ray,mesh,faceIndex) {
		let tri = mesh.faces[faceIndex];
		let o = [mesh.points[tri[0]],mesh.points[tri[1]],mesh.points[tri[2]]];
		let uvs = [mesh.uvs[tri[0]],mesh.uvs[tri[1]],mesh.uvs[tri[2]]];
		let uvd = [verb_core_Vec.sub(uvs[1],uvs[0]),verb_core_Vec.sub(uvs[2],uvs[1]),verb_core_Vec.sub(uvs[0],uvs[2])];
		let s = [verb_core_Vec.sub(o[1],o[0]),verb_core_Vec.sub(o[2],o[1]),verb_core_Vec.sub(o[0],o[2])];
		let f = verb_core_Vec.normalized;
		let result = new Array(s.length);
		let _g = 0;
		let _g1 = s.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(s[i]);
		}
		let d = result;
		let f1 = verb_core_Vec.norm;
		let result1 = new Array(s.length);
		let _g2 = 0;
		let _g3 = s.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = f1(s[i]);
		}
		let l = result1;
		let minU = null;
		let maxU = null;
		let _g4 = 0;
		while(_g4 < 3) {
			let i = _g4++;
			let o0 = o[i];
			let d0 = d[i];
			let res = verb_eval_Intersect.rays(o0,d0,ray.origin,ray.dir);
			if(res == null) {
				continue;
			}
			let useg = res.u0;
			let uray = res.u1;
			if(useg < -verb_core_Constants.EPSILON || useg > l[i] + verb_core_Constants.EPSILON) {
				continue;
			}
			if(minU == null || uray < minU.u) {
				minU = new verb_core_CurveTriPoint(uray,verb_core_Vec.onRay(ray.origin,ray.dir,uray),verb_core_Vec.onRay(uvs[i],uvd[i],useg / l[i]));
			}
			if(maxU == null || uray > maxU.u) {
				maxU = new verb_core_CurveTriPoint(uray,verb_core_Vec.onRay(ray.origin,ray.dir,uray),verb_core_Vec.onRay(uvs[i],uvd[i],useg / l[i]));
			}
		}
		if(maxU == null || minU == null) {
			return null;
		}
		return new verb_core_Interval(minU,maxU);
	}
	static mergeTriangleClipIntervals(clip1,clip2,mesh1,faceIndex1,mesh2,faceIndex2) {
		if(clip2.min.u > clip1.max.u + verb_core_Constants.EPSILON || clip1.min.u > clip2.max.u + verb_core_Constants.EPSILON) {
			return null;
		}
		let min = clip1.min.u > clip2.min.u ? new verb_core_Pair(clip1.min,0) : new verb_core_Pair(clip2.min,1);
		let max = clip1.max.u < clip2.max.u ? new verb_core_Pair(clip1.max,0) : new verb_core_Pair(clip2.max,1);
		let res = new verb_core_Interval(new verb_core_MeshIntersectionPoint(null,null,min.item0.point,faceIndex1,faceIndex2),new verb_core_MeshIntersectionPoint(null,null,max.item0.point,faceIndex1,faceIndex2));
		if(min.item1 == 0) {
			res.min.uv0 = min.item0.uv;
			res.min.uv1 = verb_core_Mesh.triangleUVFromPoint(mesh2,faceIndex2,min.item0.point);
		} else {
			res.min.uv0 = verb_core_Mesh.triangleUVFromPoint(mesh1,faceIndex1,min.item0.point);
			res.min.uv1 = min.item0.uv;
		}
		if(max.item1 == 0) {
			res.max.uv0 = max.item0.uv;
			res.max.uv1 = verb_core_Mesh.triangleUVFromPoint(mesh2,faceIndex2,max.item0.point);
		} else {
			res.max.uv0 = verb_core_Mesh.triangleUVFromPoint(mesh1,faceIndex1,max.item0.point);
			res.max.uv1 = max.item0.uv;
		}
		return res;
	}
	static planes(origin0,normal0,origin1,normal1) {
		let d = verb_core_Vec.cross(normal0,normal1);
		if(verb_core_Vec.dot(d,d) < verb_core_Constants.EPSILON) {
			return null;
		}
		let li = 0;
		let mi = Math.abs(d[0]);
		let m1 = Math.abs(d[1]);
		let m2 = Math.abs(d[2]);
		if(m1 > mi) {
			li = 1;
			mi = m1;
		}
		if(m2 > mi) {
			li = 2;
			mi = m2;
		}
		let a1;
		let b1;
		let a2;
		let b2;
		if(li == 0) {
			a1 = normal0[1];
			b1 = normal0[2];
			a2 = normal1[1];
			b2 = normal1[2];
		} else if(li == 1) {
			a1 = normal0[0];
			b1 = normal0[2];
			a2 = normal1[0];
			b2 = normal1[2];
		} else {
			a1 = normal0[0];
			b1 = normal0[1];
			a2 = normal1[0];
			b2 = normal1[1];
		}
		let d1 = -verb_core_Vec.dot(origin0,normal0);
		let d2 = -verb_core_Vec.dot(origin1,normal1);
		let den = a1 * b2 - b1 * a2;
		let x = (b1 * d2 - d1 * b2) / den;
		let y = (d1 * a2 - a1 * d2) / den;
		let p;
		if(li == 0) {
			p = [0,x,y];
		} else if(li == 1) {
			p = [x,0,y];
		} else {
			p = [x,y,0];
		}
		return new verb_core_Ray(p,verb_core_Vec.normalized(d));
	}
	static threePlanes(n0,d0,n1,d1,n2,d2) {
		let u = verb_core_Vec.cross(n1,n2);
		let den = verb_core_Vec.dot(n0,u);
		if(Math.abs(den) < verb_core_Constants.EPSILON) {
			return null;
		}
		let diff = verb_core_Vec.sub(verb_core_Vec.mul(d2,n1),verb_core_Vec.mul(d1,n2));
		let num = verb_core_Vec.add(verb_core_Vec.mul(d0,u),verb_core_Vec.cross(n0,diff));
		return verb_core_Vec.mul(1 / den,num);
	}
	static polylines(polyline0,polyline1,tol) {
		let res = verb_eval_Intersect.boundingBoxTrees(new verb_core_LazyPolylineBoundingBoxTree(polyline0),new verb_core_LazyPolylineBoundingBoxTree(polyline1),tol);
		let finalResults = [];
		let _g = 0;
		while(_g < res.length) {
			let event = res[_g];
			++_g;
			let polid0 = event.item0;
			let polid1 = event.item1;
			let inter = verb_eval_Intersect.segments(polyline0.points[polid0],polyline0.points[polid0 + 1],polyline1.points[polid1],polyline1.points[polid1 + 1],tol);
			if(inter == null) {
				continue;
			}
			inter.u0 = verb_core_Vec.lerp(inter.u0,[polyline0.params[polid0]],[polyline0.params[polid0 + 1]])[0];
			inter.u1 = verb_core_Vec.lerp(inter.u1,[polyline1.params[polid1]],[polyline1.params[polid1 + 1]])[0];
			finalResults.push(inter);
		}
		return finalResults;
	}
	static segments(a0,a1,b0,b1,tol) {
		let a1ma0 = verb_core_Vec.sub(a1,a0);
		let aN = Math.sqrt(verb_core_Vec.dot(a1ma0,a1ma0));
		let a = verb_core_Vec.mul(1 / aN,a1ma0);
		let b1mb0 = verb_core_Vec.sub(b1,b0);
		let bN = Math.sqrt(verb_core_Vec.dot(b1mb0,b1mb0));
		let b = verb_core_Vec.mul(1 / bN,b1mb0);
		let int_params = verb_eval_Intersect.rays(a0,a,b0,b);
		if(int_params != null) {
			let u0 = Math.min(Math.max(0,int_params.u0 / aN),1.0);
			let u1 = Math.min(Math.max(0,int_params.u1 / bN),1.0);
			let point0 = verb_core_Vec.onRay(a0,a1ma0,u0);
			let point1 = verb_core_Vec.onRay(b0,b1mb0,u1);
			let dist = verb_core_Vec.distSquared(point0,point1);
			if(dist < tol * tol) {
				return new verb_core_CurveCurveIntersection(point0,point1,u0,u1);
			}
		}
		return null;
	}
	static rays(a0,a,b0,b) {
		let dab = verb_core_Vec.dot(a,b);
		let dab0 = verb_core_Vec.dot(a,b0);
		let daa0 = verb_core_Vec.dot(a,a0);
		let dbb0 = verb_core_Vec.dot(b,b0);
		let dba0 = verb_core_Vec.dot(b,a0);
		let daa = verb_core_Vec.dot(a,a);
		let dbb = verb_core_Vec.dot(b,b);
		let div = daa * dbb - dab * dab;
		if(Math.abs(div) < verb_core_Constants.EPSILON) {
			return null;
		}
		let num = dab * (dab0 - daa0) - daa * (dbb0 - dba0);
		let w = num / div;
		let t = (dab0 - daa0 + w * dab) / daa;
		let p0 = verb_core_Vec.onRay(a0,a,t);
		let p1 = verb_core_Vec.onRay(b0,b,w);
		return new verb_core_CurveCurveIntersection(p0,p1,t,w);
	}
	static segmentWithTriangle(p0,p1,points,tri) {
		let v0 = points[tri[0]];
		let v1 = points[tri[1]];
		let v2 = points[tri[2]];
		let u = verb_core_Vec.sub(v1,v0);
		let v = verb_core_Vec.sub(v2,v0);
		let n = verb_core_Vec.cross(u,v);
		let dir = verb_core_Vec.sub(p1,p0);
		let w0 = verb_core_Vec.sub(p0,v0);
		let a = -verb_core_Vec.dot(n,w0);
		let b = verb_core_Vec.dot(n,dir);
		if(Math.abs(b) < verb_core_Constants.EPSILON) {
			return null;
		}
		let r = a / b;
		if(r < 0 || r > 1) {
			return null;
		}
		let pt = verb_core_Vec.add(p0,verb_core_Vec.mul(r,dir));
		let uv = verb_core_Vec.dot(u,v);
		let uu = verb_core_Vec.dot(u,u);
		let vv = verb_core_Vec.dot(v,v);
		let w = verb_core_Vec.sub(pt,v0);
		let wu = verb_core_Vec.dot(w,u);
		let wv = verb_core_Vec.dot(w,v);
		let denom = uv * uv - uu * vv;
		if(Math.abs(denom) < verb_core_Constants.EPSILON) {
			return null;
		}
		let s = (uv * wv - vv * wu) / denom;
		let t = (uv * wu - uu * wv) / denom;
		if(s > 1.0 + verb_core_Constants.EPSILON || t > 1.0 + verb_core_Constants.EPSILON || t < -verb_core_Constants.EPSILON || s < -verb_core_Constants.EPSILON || s + t > 1.0 + verb_core_Constants.EPSILON) {
			return null;
		}
		return new verb_core_TriSegmentIntersection(pt,s,t,r);
	}
	static segmentAndPlane(p0,p1,v0,n) {
		let denom = verb_core_Vec.dot(n,verb_core_Vec.sub(p1,p0));
		if(Math.abs(denom) < verb_core_Constants.EPSILON) {
			return null;
		}
		let numer = verb_core_Vec.dot(n,verb_core_Vec.sub(v0,p0));
		let p = numer / denom;
		if(p > 1.0 + verb_core_Constants.EPSILON || p < -verb_core_Constants.EPSILON) {
			return null;
		}
		return { p : p};
	}
}
$hxClasses["verb.eval.Intersect"] = $hx_exports["eval"]["Intersect"] = verb_eval_Intersect;
verb_eval_Intersect.__name__ = "verb.eval.Intersect";
class verb_eval_Make {
	static rationalTranslationalSurface(profile,rail) {
		let pt0 = verb_eval_Eval.rationalCurvePoint(rail,verb_core_ArrayExtensions.first(rail.knots));
		let startu = verb_core_ArrayExtensions.first(rail.knots);
		let endu = verb_core_ArrayExtensions.last(rail.knots);
		let numSamples = 2 * rail.controlPoints.length;
		let span = (endu - startu) / (numSamples - 1);
		let crvs = [];
		let _g = 0;
		let _g1 = numSamples;
		while(_g < _g1) {
			let i = _g++;
			let pt = verb_core_Vec.sub(verb_eval_Eval.rationalCurvePoint(rail,startu + i * span),pt0);
			let crv = verb_eval_Modify.rationalCurveTransform(profile,[[1,0,0,pt[0]],[0,1,0,pt[1]],[0,0,1,pt[2]],[0,0,0,1]]);
			crvs.push(crv);
		}
		return verb_eval_Make.loftedSurface(crvs);
	}
	static surfaceBoundaryCurves(surface) {
		let c0 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.first(surface.knotsU),false);
		let c1 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.last(surface.knotsU),false);
		let c2 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.first(surface.knotsV),true);
		let c3 = verb_eval_Make.surfaceIsocurve(surface,verb_core_ArrayExtensions.last(surface.knotsV),true);
		return [c0,c1,c2,c3];
	}
	static surfaceIsocurve(surface,u,useV) {
		if(useV == null) {
			useV = false;
		}
		let knots = useV ? surface.knotsV : surface.knotsU;
		let degree = useV ? surface.degreeV : surface.degreeU;
		let knotMults = verb_eval_Analyze.knotMultiplicities(knots);
		let reqKnotIndex = -1;
		let _g = 0;
		let _g1 = knotMults.length;
		while(_g < _g1) {
			let i = _g++;
			if(Math.abs(u - knotMults[i].knot) < verb_core_Constants.EPSILON) {
				reqKnotIndex = i;
				break;
			}
		}
		let numKnotsToInsert = degree + 1;
		if(reqKnotIndex >= 0) {
			numKnotsToInsert -= knotMults[reqKnotIndex].mult;
		}
		let newSrf = numKnotsToInsert > 0 ? verb_eval_Modify.surfaceKnotRefine(surface,verb_core_Vec.rep(numKnotsToInsert,u),useV) : surface;
		let span = verb_eval_Eval.knotSpan(degree,u,knots);
		if(Math.abs(u - verb_core_ArrayExtensions.first(knots)) < verb_core_Constants.EPSILON) {
			span = 0;
		} else if(Math.abs(u - verb_core_ArrayExtensions.last(knots)) < verb_core_Constants.EPSILON) {
			span = (useV ? newSrf.controlPoints[0].length : newSrf.controlPoints.length) - 1;
		}
		if(useV) {
			let newSrf1 = newSrf.degreeU;
			let newSrf2 = newSrf.knotsU;
			let _g = [];
			let _g1 = 0;
			let _g2 = newSrf.controlPoints;
			while(_g1 < _g2.length) {
				let row = _g2[_g1];
				++_g1;
				_g.push(row[span]);
			}
			return new verb_core_NurbsCurveData(newSrf1,newSrf2,_g);
		}
		return new verb_core_NurbsCurveData(newSrf.degreeV,newSrf.knotsV,newSrf.controlPoints[span]);
	}
	static loftedSurface(curves,degreeV) {
		curves = verb_eval_Modify.unifyCurveKnotVectors(curves);
		let degreeU = curves[0].degree;
		if(degreeV == null) {
			degreeV = 3;
		}
		if(degreeV > curves.length - 1) {
			degreeV = curves.length - 1;
		}
		let knotsU = curves[0].knots;
		let knotsV = [];
		let controlPoints = [];
		let _g = 0;
		let _g1 = curves[0].controlPoints.length;
		while(_g < _g1) {
			let i = _g++;
			let result = new Array(curves.length);
			let _g1 = 0;
			let _g2 = curves.length;
			while(_g1 < _g2) {
				let i1 = _g1++;
				result[i1] = curves[i1].controlPoints[i];
			}
			let points = result;
			let c = verb_eval_Make.rationalInterpCurve(points,degreeV,true);
			controlPoints.push(c.controlPoints);
			knotsV = c.knots;
		}
		return new verb_core_NurbsSurfaceData(degreeU,degreeV,knotsU,knotsV,controlPoints);
	}
	static clonedCurve(curve) {
		let curve1 = curve.degree;
		let tmp = curve.knots.slice();
		let _this = curve.controlPoints;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].slice();
		}
		return new verb_core_NurbsCurveData(curve1,tmp,result);
	}
	static rationalBezierCurve(controlPoints,weights) {
		let degree = controlPoints.length - 1;
		let knots = [];
		let _g = 0;
		let _g1 = degree + 1;
		while(_g < _g1) {
			let i = _g++;
			knots.push(0.0);
		}
		let _g2 = 0;
		let _g3 = degree + 1;
		while(_g2 < _g3) {
			let i = _g2++;
			knots.push(1.0);
		}
		if(weights == null) {
			weights = verb_core_Vec.rep(controlPoints.length,1.0);
		}
		return new verb_core_NurbsCurveData(degree,knots,verb_eval_Eval.homogenize1d(controlPoints,weights));
	}
	static fourPointSurface(p1,p2,p3,p4,degree) {
		if(degree == null) {
			degree = 3;
		}
		let degreeFloat = degree;
		let pts = [];
		let _g = 0;
		let _g1 = degree + 1;
		while(_g < _g1) {
			let i = _g++;
			let row = [];
			let _g1 = 0;
			let _g2 = degree + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				let l = 1.0 - i / degreeFloat;
				let p1p2 = verb_core_Vec.lerp(l,p1,p2);
				let p4p3 = verb_core_Vec.lerp(l,p4,p3);
				let res = verb_core_Vec.lerp(1.0 - j / degreeFloat,p1p2,p4p3);
				res.push(1.0);
				row.push(res);
			}
			pts.push(row);
		}
		let zeros = verb_core_Vec.rep(degree + 1,0.0);
		let ones = verb_core_Vec.rep(degree + 1,1.0);
		return new verb_core_NurbsSurfaceData(degree,degree,zeros.concat(ones),zeros.concat(ones),pts);
	}
	static ellipseArc(center,xaxis,yaxis,startAngle,endAngle) {
		let xradius = verb_core_Vec.norm(xaxis);
		let yradius = verb_core_Vec.norm(yaxis);
		xaxis = verb_core_Vec.normalized(xaxis);
		yaxis = verb_core_Vec.normalized(yaxis);
		if(endAngle < startAngle) {
			endAngle = 2.0 * Math.PI + startAngle;
		}
		let theta = endAngle - startAngle;
		let numArcs = 0;
		if(theta <= Math.PI / 2) {
			numArcs = 1;
		} else if(theta <= Math.PI) {
			numArcs = 2;
		} else if(theta <= 3 * Math.PI / 2) {
			numArcs = 3;
		} else {
			numArcs = 4;
		}
		let dtheta = theta / numArcs;
		let n = 2 * numArcs;
		let w1 = Math.cos(dtheta / 2);
		let P0 = verb_core_Vec.add(center,verb_core_Vec.add(verb_core_Vec.mul(xradius * Math.cos(startAngle),xaxis),verb_core_Vec.mul(yradius * Math.sin(startAngle),yaxis)));
		let T0 = verb_core_Vec.sub(verb_core_Vec.mul(Math.cos(startAngle),yaxis),verb_core_Vec.mul(Math.sin(startAngle),xaxis));
		let controlPoints = [];
		let knots = verb_core_Vec.zeros1d(2 * numArcs + 3);
		let index = 0;
		let angle = startAngle;
		let weights = verb_core_Vec.zeros1d(numArcs * 2);
		controlPoints[0] = P0;
		weights[0] = 1.0;
		let _g = 1;
		let _g1 = numArcs + 1;
		while(_g < _g1) {
			let i = _g++;
			angle += dtheta;
			let P2 = verb_core_Vec.add(center,verb_core_Vec.add(verb_core_Vec.mul(xradius * Math.cos(angle),xaxis),verb_core_Vec.mul(yradius * Math.sin(angle),yaxis)));
			weights[index + 2] = 1;
			controlPoints[index + 2] = P2;
			let T2 = verb_core_Vec.sub(verb_core_Vec.mul(Math.cos(angle),yaxis),verb_core_Vec.mul(Math.sin(angle),xaxis));
			let inters = verb_eval_Intersect.rays(P0,verb_core_Vec.mul(1 / verb_core_Vec.norm(T0),T0),P2,verb_core_Vec.mul(1 / verb_core_Vec.norm(T2),T2));
			let P1 = verb_core_Vec.add(P0,verb_core_Vec.mul(inters.u0,T0));
			weights[index + 1] = w1;
			controlPoints[index + 1] = P1;
			index += 2;
			if(i < numArcs) {
				P0 = P2;
				T0 = T2;
			}
		}
		let j = 2 * numArcs + 1;
		knots[0] = 0.0;
		knots[j] = 1.0;
		knots[1] = 0.0;
		knots[1 + j] = 1.0;
		knots[2] = 0.0;
		knots[2 + j] = 1.0;
		switch(numArcs) {
		case 2:
			knots[3] = knots[4] = 0.5;
			break;
		case 3:
			knots[3] = knots[4] = 0.33333333333333331;
			knots[5] = knots[6] = 0.66666666666666663;
			break;
		case 4:
			knots[3] = knots[4] = 0.25;
			knots[5] = knots[6] = 0.5;
			knots[7] = knots[8] = 0.75;
			break;
		}
		return new verb_core_NurbsCurveData(2,knots,verb_eval_Eval.homogenize1d(controlPoints,weights));
	}
	static arc(center,xaxis,yaxis,radius,startAngle,endAngle) {
		return verb_eval_Make.ellipseArc(center,verb_core_Vec.mul(radius,verb_core_Vec.normalized(xaxis)),verb_core_Vec.mul(radius,verb_core_Vec.normalized(yaxis)),startAngle,endAngle);
	}
	static polyline(pts) {
		let knots = [0.0,0.0];
		let lsum = 0.0;
		let _g = 0;
		let _g1 = pts.length - 1;
		while(_g < _g1) {
			let i = _g++;
			lsum += verb_core_Vec.dist(pts[i],pts[i + 1]);
			knots.push(lsum);
		}
		knots.push(lsum);
		knots = verb_core_Vec.mul(1 / lsum,knots);
		let _g2 = [];
		let _g3 = 0;
		let _g4 = pts.length;
		while(_g3 < _g4) {
			let i = _g3++;
			_g2.push(1.0);
		}
		let weights = _g2;
		return new verb_core_NurbsCurveData(1,knots,verb_eval_Eval.homogenize1d(pts.slice(0),weights));
	}
	static extrudedSurface(axis,length,profile) {
		let controlPoints = [[],[],[]];
		let weights = [[],[],[]];
		let prof_controlPoints = verb_eval_Eval.dehomogenize1d(profile.controlPoints);
		let prof_weights = verb_eval_Eval.weight1d(profile.controlPoints);
		let translation = verb_core_Vec.mul(length,axis);
		let halfTranslation = verb_core_Vec.mul(0.5 * length,axis);
		let _g = 0;
		let _g1 = prof_controlPoints.length;
		while(_g < _g1) {
			let j = _g++;
			controlPoints[2][j] = prof_controlPoints[j];
			controlPoints[1][j] = verb_core_Vec.add(halfTranslation,prof_controlPoints[j]);
			controlPoints[0][j] = verb_core_Vec.add(translation,prof_controlPoints[j]);
			weights[0][j] = prof_weights[j];
			weights[1][j] = prof_weights[j];
			weights[2][j] = prof_weights[j];
		}
		return new verb_core_NurbsSurfaceData(2,profile.degree,[0,0,0,1,1,1],profile.knots,verb_eval_Eval.homogenize2d(controlPoints,weights));
	}
	static cylindricalSurface(axis,xaxis,base,height,radius) {
		let yaxis = verb_core_Vec.cross(axis,xaxis);
		let angle = 2.0 * Math.PI;
		let circ = verb_eval_Make.arc(base,xaxis,yaxis,radius,0.0,2 * Math.PI);
		return verb_eval_Make.extrudedSurface(axis,height,circ);
	}
	static revolvedSurface(profile,center,axis,theta) {
		let prof_controlPoints = verb_eval_Eval.dehomogenize1d(profile.controlPoints);
		let prof_weights = verb_eval_Eval.weight1d(profile.controlPoints);
		let narcs;
		let knotsU;
		let controlPoints;
		let weights;
		if(theta <= Math.PI / 2) {
			narcs = 1;
			knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
		} else if(theta <= Math.PI) {
			narcs = 2;
			knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
			knotsU[3] = knotsU[4] = 0.5;
		} else if(theta <= 3 * Math.PI / 2) {
			narcs = 3;
			knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
			knotsU[3] = knotsU[4] = 0.33333333333333331;
			knotsU[5] = knotsU[6] = 0.66666666666666663;
		} else {
			narcs = 4;
			knotsU = verb_core_Vec.zeros1d(6 + 2 * (narcs - 1));
			knotsU[3] = knotsU[4] = 0.25;
			knotsU[5] = knotsU[6] = 0.5;
			knotsU[7] = knotsU[8] = 0.75;
		}
		let dtheta = theta / narcs;
		let j = 3 + 2 * (narcs - 1);
		knotsU[0] = 0.0;
		knotsU[j] = 1.0;
		knotsU[1] = 0.0;
		knotsU[j + 1] = 1.0;
		knotsU[2] = 0.0;
		knotsU[j + 2] = 1.0;
		let n = 2 * narcs;
		let wm = Math.cos(dtheta / 2.0);
		let angle = 0.0;
		let sines = verb_core_Vec.zeros1d(narcs + 1);
		let cosines = verb_core_Vec.zeros1d(narcs + 1);
		let controlPoints1 = verb_core_Vec.zeros3d(2 * narcs + 1,prof_controlPoints.length,3);
		let weights1 = verb_core_Vec.zeros2d(2 * narcs + 1,prof_controlPoints.length);
		let _g = 1;
		let _g1 = narcs + 1;
		while(_g < _g1) {
			let i = _g++;
			angle += dtheta;
			cosines[i] = Math.cos(angle);
			sines[i] = Math.sin(angle);
		}
		let _g2 = 0;
		let _g3 = prof_controlPoints.length;
		while(_g2 < _g3) {
			let j = _g2++;
			let O = verb_core_Trig.rayClosestPoint(prof_controlPoints[j],center,axis);
			let X = verb_core_Vec.sub(prof_controlPoints[j],O);
			let r = verb_core_Vec.norm(X);
			let Y = verb_core_Vec.cross(axis,X);
			if(r > verb_core_Constants.EPSILON) {
				X = verb_core_Vec.mul(1 / r,X);
				Y = verb_core_Vec.mul(1 / r,Y);
			}
			controlPoints1[0][j] = prof_controlPoints[j];
			let P0 = prof_controlPoints[j];
			weights1[0][j] = prof_weights[j];
			let T0 = Y;
			let index = 0;
			let angle = 0.0;
			let _g = 1;
			let _g1 = narcs + 1;
			while(_g < _g1) {
				let i = _g++;
				let P2 = r == 0 ? O : verb_core_Vec.add(O,verb_core_Vec.add(verb_core_Vec.mul(r * cosines[i],X),verb_core_Vec.mul(r * sines[i],Y)));
				controlPoints1[index + 2][j] = P2;
				weights1[index + 2][j] = prof_weights[j];
				let T2 = verb_core_Vec.sub(verb_core_Vec.mul(cosines[i],Y),verb_core_Vec.mul(sines[i],X));
				if(r == 0) {
					controlPoints1[index + 1][j] = O;
				} else {
					let inters = verb_eval_Intersect.rays(P0,verb_core_Vec.mul(1 / verb_core_Vec.norm(T0),T0),P2,verb_core_Vec.mul(1 / verb_core_Vec.norm(T2),T2));
					let P1 = verb_core_Vec.add(P0,verb_core_Vec.mul(inters.u0,T0));
					controlPoints1[index + 1][j] = P1;
				}
				weights1[index + 1][j] = wm * prof_weights[j];
				index += 2;
				if(i < narcs) {
					P0 = P2;
					T0 = T2;
				}
			}
		}
		return new verb_core_NurbsSurfaceData(2,profile.degree,knotsU,profile.knots,verb_eval_Eval.homogenize2d(controlPoints1,weights1));
	}
	static sphericalSurface(center,axis,xaxis,radius) {
		let arc = verb_eval_Make.arc(center,verb_core_Vec.mul(-1.0,axis),xaxis,radius,0.0,Math.PI);
		return verb_eval_Make.revolvedSurface(arc,center,axis,2 * Math.PI);
	}
	static conicalSurface(axis,xaxis,base,height,radius) {
		let angle = 2 * Math.PI;
		let prof_degree = 1;
		let prof_ctrl_pts = [verb_core_Vec.add(base,verb_core_Vec.mul(height,axis)),verb_core_Vec.add(base,verb_core_Vec.mul(radius,xaxis))];
		let prof_knots = [0.0,0.0,1.0,1.0];
		let prof_weights = [1.0,1.0];
		let prof = new verb_core_NurbsCurveData(prof_degree,prof_knots,verb_eval_Eval.homogenize1d(prof_ctrl_pts,prof_weights));
		return verb_eval_Make.revolvedSurface(prof,base,axis,angle);
	}
	static rationalInterpCurve(points,degree,homogeneousPoints,start_tangent,end_tangent) {
		if(homogeneousPoints == null) {
			homogeneousPoints = false;
		}
		if(degree == null) {
			degree = 3;
		}
		if(points.length < degree + 1) {
			throw haxe_Exception.thrown("You need to supply at least degree + 1 points! You only supplied " + points.length + " points.");
		}
		let us = [0.0];
		let _g = 1;
		let _g1 = points.length;
		while(_g < _g1) {
			let i = _g++;
			let chord = verb_core_Vec.norm(verb_core_Vec.sub(points[i],points[i - 1]));
			let last = us[us.length - 1];
			us.push(last + chord);
		}
		let max = us[us.length - 1];
		let _g2 = 0;
		let _g3 = us.length;
		while(_g2 < _g3) {
			let i = _g2++;
			us[i] /= max;
		}
		let knotsStart = verb_core_Vec.rep(degree + 1,0.0);
		let hasTangents = start_tangent != null && end_tangent != null;
		let start = hasTangents ? 0 : 1;
		let end = hasTangents ? us.length - degree + 1 : us.length - degree;
		let _g4 = start;
		let _g5 = end;
		while(_g4 < _g5) {
			let i = _g4++;
			let weightSums = 0.0;
			let _g = 0;
			let _g1 = degree;
			while(_g < _g1) {
				let j = _g++;
				weightSums += us[i + j];
			}
			knotsStart.push(1 / degree * weightSums);
		}
		let knots = knotsStart.concat(verb_core_Vec.rep(degree + 1,1.0));
		let A = [];
		let n = hasTangents ? points.length + 1 : points.length - 1;
		let lst = hasTangents ? 1 : 0;
		let ld = hasTangents ? points.length - (degree - 1) : points.length - (degree + 1);
		let _g6 = 0;
		while(_g6 < us.length) {
			let u = us[_g6];
			++_g6;
			let span = verb_eval_Eval.knotSpanGivenN(n,degree,u,knots);
			let basisFuncs = verb_eval_Eval.basisFunctionsGivenKnotSpanIndex(span,u,degree,knots);
			let ls = span - degree;
			let rowstart = verb_core_Vec.zeros1d(ls);
			let rowend = verb_core_Vec.zeros1d(ld - ls);
			A.push(rowstart.concat(basisFuncs).concat(rowend));
		}
		if(hasTangents) {
			let ln = A[0].length - 2;
			let tanRow0 = [-1.0,1.0].concat(verb_core_Vec.zeros1d(ln));
			let tanRow1 = verb_core_Vec.zeros1d(ln).concat([-1.0,1.0]);
			verb_core_ArrayExtensions.spliceAndInsert(A,1,0,tanRow0);
			verb_core_ArrayExtensions.spliceAndInsert(A,A.length - 1,0,tanRow1);
		}
		let dim = points[0].length;
		let xs = [];
		let mult1 = (1 - knots[knots.length - degree - 2]) / degree;
		let mult0 = knots[degree + 1] / degree;
		let _g7 = 0;
		let _g8 = dim;
		while(_g7 < _g8) {
			let i = _g7++;
			let b;
			if(!hasTangents) {
				let result = new Array(points.length);
				let _g = 0;
				let _g1 = points.length;
				while(_g < _g1) {
					let i1 = _g++;
					result[i1] = points[i1][i];
				}
				b = result;
			} else {
				b = [points[0][i]];
				b.push(mult0 * start_tangent[i]);
				let _g = 1;
				let _g1 = points.length - 1;
				while(_g < _g1) {
					let j = _g++;
					b.push(points[j][i]);
				}
				b.push(mult1 * end_tangent[i]);
				b.push(verb_core_ArrayExtensions.last(points)[i]);
			}
			let x = verb_core_Mat.solve(A,b);
			xs.push(x);
		}
		let controlPts = verb_core_Mat.transpose(xs);
		if(!homogeneousPoints) {
			let weights = verb_core_Vec.rep(controlPts.length,1.0);
			controlPts = verb_eval_Eval.homogenize1d(controlPts,weights);
		}
		return new verb_core_NurbsCurveData(degree,knots,controlPts);
	}
}
$hxClasses["verb.eval.Make"] = $hx_exports["eval"]["Make"] = verb_eval_Make;
verb_eval_Make.__name__ = "verb.eval.Make";
class verb_eval_Modify {
	static curveReverse(curve) {
		return new verb_core_NurbsCurveData(curve.degree,verb_eval_Modify.knotsReverse(curve.knots),verb_core_ArrayExtensions.reversed(curve.controlPoints));
	}
	static surfaceReverse(surface,useV) {
		if(useV == null) {
			useV = false;
		}
		if(useV) {
			let surface1 = surface.degreeU;
			let surface2 = surface.degreeV;
			let surface3 = surface.knotsU;
			let tmp = verb_eval_Modify.knotsReverse(surface.knotsV);
			let _g = [];
			let _g1 = 0;
			let _g2 = surface.controlPoints;
			while(_g1 < _g2.length) {
				let row = _g2[_g1];
				++_g1;
				_g.push(verb_core_ArrayExtensions.reversed(row));
			}
			return new verb_core_NurbsSurfaceData(surface1,surface2,surface3,tmp,_g);
		}
		return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,verb_eval_Modify.knotsReverse(surface.knotsU),surface.knotsV,verb_core_ArrayExtensions.reversed(surface.controlPoints));
	}
	static knotsReverse(knots) {
		let min = verb_core_ArrayExtensions.first(knots);
		let max = verb_core_ArrayExtensions.last(knots);
		let l = [min];
		let len = knots.length;
		let _g = 1;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			l.push(l[i - 1] + (knots[len - i] - knots[len - i - 1]));
		}
		return l;
	}
	static unifyCurveKnotVectors(curves) {
		let f = verb_eval_Make.clonedCurve;
		let result = new Array(curves.length);
		let _g = 0;
		let _g1 = curves.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(curves[i]);
		}
		curves = result;
		let maxDegree = Lambda.fold(curves,function(x,a) {
			return verb_eval_Modify.imax(x.degree,a);
		},0);
		let _g2 = 0;
		let _g3 = curves.length;
		while(_g2 < _g3) {
			let i = _g2++;
			if(curves[i].degree < maxDegree) {
				curves[i] = verb_eval_Modify.curveElevateDegree(curves[i],maxDegree);
			}
		}
		let _g4 = [];
		let _g5 = 0;
		while(_g5 < curves.length) {
			let c = curves[_g5];
			++_g5;
			_g4.push(new verb_core_Interval(verb_core_ArrayExtensions.first(c.knots),verb_core_ArrayExtensions.last(c.knots)));
		}
		let knotIntervals = _g4;
		let _g6 = 0;
		let _g7 = curves.length;
		while(_g6 < _g7) {
			let i = _g6++;
			let min = knotIntervals[i].min;
			let _this = curves[i].knots;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i] - min;
			}
			curves[i].knots = result;
		}
		let result1 = new Array(knotIntervals.length);
		let _g8 = 0;
		let _g9 = knotIntervals.length;
		while(_g8 < _g9) {
			let i = _g8++;
			let x = knotIntervals[i];
			result1[i] = x.max - x.min;
		}
		let knotSpans = result1;
		let maxKnotSpan = Lambda.fold(knotSpans,function(x,a) {
			return Math.max(x,a);
		},0.0);
		let _g10 = 0;
		let _g11 = curves.length;
		while(_g10 < _g11) {
			let i = _g10++;
			let scale = maxKnotSpan / knotSpans[i];
			let _this = curves[i].knots;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i] * scale;
			}
			curves[i].knots = result;
		}
		let mergedKnots = Lambda.fold(curves,function(x,a) {
			return verb_core_Vec.sortedSetUnion(x.knots,a);
		},[]);
		let _g12 = 0;
		let _g13 = curves.length;
		while(_g12 < _g13) {
			let i = _g12++;
			let rem = verb_core_Vec.sortedSetSub(mergedKnots,curves[i].knots);
			if(rem.length == 0) {
				curves[i] = curves[i];
			}
			curves[i] = verb_eval_Modify.curveKnotRefine(curves[i],rem);
		}
		return curves;
	}
	static imin(a,b) {
		if(a < b) {
			return a;
		} else {
			return b;
		}
	}
	static imax(a,b) {
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
	static curveElevateDegree(curve,finalDegree) {
		if(finalDegree <= curve.degree) {
			return curve;
		}
		let n = curve.knots.length - curve.degree - 2;
		let newDegree = curve.degree;
		let knots = curve.knots;
		let controlPoints = curve.controlPoints;
		let degreeInc = finalDegree - curve.degree;
		let dim = curve.controlPoints[0].length;
		let bezalfs = verb_core_Vec.zeros2d(newDegree + degreeInc + 1,newDegree + 1);
		let bpts = [];
		let ebpts = [];
		let Nextbpts = [];
		let m = n + newDegree + 1;
		let ph = finalDegree;
		let ph2 = Math.floor(ph / 2);
		let Qw = [];
		let Uh = [];
		bezalfs[0][0] = 1.0;
		bezalfs[ph][newDegree] = 1.0;
		let _g = 1;
		let _g1 = ph2 + 1;
		while(_g < _g1) {
			let i = _g++;
			let inv = 1.0 / verb_core_Binomial.get(ph,i);
			let mpi = verb_eval_Modify.imin(newDegree,i);
			let _g1 = verb_eval_Modify.imax(0,i - degreeInc);
			let _g2 = mpi + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				bezalfs[i][j] = inv * verb_core_Binomial.get(newDegree,j) * verb_core_Binomial.get(degreeInc,i - j);
			}
		}
		let _g2 = ph2 + 1;
		let _g3 = ph;
		while(_g2 < _g3) {
			let i = _g2++;
			let mpi = verb_eval_Modify.imin(newDegree,i);
			let _g = verb_eval_Modify.imax(0,i - degreeInc);
			let _g1 = mpi + 1;
			while(_g < _g1) {
				let j = _g++;
				bezalfs[i][j] = bezalfs[ph - i][newDegree - j];
			}
		}
		let mh = ph;
		let kind = ph + 1;
		let r = -1;
		let a = newDegree;
		let b = newDegree + 1;
		let cind = 1;
		let ua = knots[0];
		Qw[0] = controlPoints[0];
		let _g4 = 0;
		let _g5 = ph + 1;
		while(_g4 < _g5) {
			let i = _g4++;
			Uh[i] = ua;
		}
		let _g6 = 0;
		let _g7 = newDegree + 1;
		while(_g6 < _g7) {
			let i = _g6++;
			bpts[i] = controlPoints[i];
		}
		while(b < m) {
			let i = b;
			while(b < m && knots[b] == knots[b + 1]) ++b;
			let mul = b - i + 1;
			let mh1 = mh + mul + degreeInc;
			let ub = knots[b];
			let oldr = r;
			r = newDegree - mul;
			let lbz = oldr > 0 ? Math.floor((oldr + 2) / 2) : 1;
			let rbz = r > 0 ? Math.floor(ph - (r + 1) / 2) : ph;
			if(r > 0) {
				let numer = ub - ua;
				let alfs = [];
				let k = newDegree;
				while(k > mul) {
					alfs[k - mul - 1] = numer / (knots[a + k] - ua);
					--k;
				}
				let _g = 1;
				let _g1 = r + 1;
				while(_g < _g1) {
					let j = _g++;
					let save = r - j;
					let s = mul + j;
					let k = newDegree;
					while(k >= s) {
						bpts[k] = verb_core_Vec.add(verb_core_Vec.mul(alfs[k - s],bpts[k]),verb_core_Vec.mul(1.0 - alfs[k - s],bpts[k - 1]));
						--k;
					}
					Nextbpts[save] = bpts[newDegree];
				}
			}
			let _g = lbz;
			let _g1 = ph + 1;
			while(_g < _g1) {
				let i = _g++;
				ebpts[i] = verb_core_Vec.zeros1d(dim);
				let mpi = verb_eval_Modify.imin(newDegree,i);
				let _g1 = verb_eval_Modify.imax(0,i - degreeInc);
				let _g2 = mpi + 1;
				while(_g1 < _g2) {
					let j = _g1++;
					ebpts[i] = verb_core_Vec.add(ebpts[i],verb_core_Vec.mul(bezalfs[i][j],bpts[j]));
				}
			}
			if(oldr > 1) {
				let first = kind - 2;
				let last = kind;
				let den = ub - ua;
				let bet = (ub - Uh[kind - 1]) / den;
				let _g = 1;
				let _g1 = oldr;
				while(_g < _g1) {
					let tr = _g++;
					let i = first;
					let j = last;
					let kj = j - kind + 1;
					while(j - i > tr) {
						if(i < cind) {
							let alf = (ub - Uh[i]) / (ua - Uh[i]);
							Qw[i] = verb_core_Vec.lerp(alf,Qw[i],Qw[i - 1]);
						}
						if(j >= lbz) {
							if(j - tr <= kind - ph + oldr) {
								let gam = (ub - Uh[j - tr]) / den;
								ebpts[kj] = verb_core_Vec.lerp(gam,ebpts[kj],ebpts[kj + 1]);
							}
						} else {
							ebpts[kj] = verb_core_Vec.lerp(bet,ebpts[kj],ebpts[kj + 1]);
						}
						++i;
						--j;
						--kj;
					}
					--first;
					++last;
				}
			}
			if(a != newDegree) {
				let _g = 0;
				let _g1 = ph - oldr;
				while(_g < _g1) {
					let i = _g++;
					Uh[kind] = ua;
					++kind;
				}
			}
			let _g2 = lbz;
			let _g3 = rbz + 1;
			while(_g2 < _g3) {
				let j = _g2++;
				Qw[cind] = ebpts[j];
				++cind;
			}
			if(b < m) {
				let _g = 0;
				let _g1 = r;
				while(_g < _g1) {
					let j = _g++;
					bpts[j] = Nextbpts[j];
				}
				let _g2 = r;
				let _g3 = newDegree + 1;
				while(_g2 < _g3) {
					let j = _g2++;
					bpts[j] = controlPoints[b - newDegree + j];
				}
				a = b;
				++b;
				ua = ub;
			} else {
				let _g = 0;
				let _g1 = ph + 1;
				while(_g < _g1) {
					let i = _g++;
					Uh[kind + i] = ub;
				}
			}
		}
		let nh = mh - ph - 1;
		return new verb_core_NurbsCurveData(finalDegree,Uh,Qw);
	}
	static rationalSurfaceTransform(surface,mat) {
		let pts = verb_eval_Eval.dehomogenize2d(surface.controlPoints);
		let _g = 0;
		let _g1 = pts.length;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = 0;
			let _g2 = pts[i].length;
			while(_g1 < _g2) {
				let j = _g1++;
				let homoPt = pts[i][j];
				homoPt.push(1.0);
				pts[i][j] = verb_core_Mat.dot(mat,homoPt).slice(0,homoPt.length - 1);
			}
		}
		return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,surface.knotsU.slice(),surface.knotsV.slice(),verb_eval_Eval.homogenize2d(pts,verb_eval_Eval.weight2d(surface.controlPoints)));
	}
	static rationalCurveTransform(curve,mat) {
		let pts = verb_eval_Eval.dehomogenize1d(curve.controlPoints);
		let _g = 0;
		let _g1 = pts.length;
		while(_g < _g1) {
			let i = _g++;
			let homoPt = pts[i];
			homoPt.push(1.0);
			pts[i] = verb_core_Mat.dot(mat,homoPt).slice(0,homoPt.length - 1);
		}
		return new verb_core_NurbsCurveData(curve.degree,curve.knots.slice(),verb_eval_Eval.homogenize1d(pts,verb_eval_Eval.weight1d(curve.controlPoints)));
	}
	static surfaceKnotRefine(surface,knotsToInsert,useV) {
		let newPts = [];
		let knots;
		let degree;
		let ctrlPts;
		if(!useV) {
			ctrlPts = verb_core_Mat.transposeN(surface.controlPoints);
			knots = surface.knotsU;
			degree = surface.degreeU;
		} else {
			ctrlPts = surface.controlPoints;
			knots = surface.knotsV;
			degree = surface.degreeV;
		}
		let c = null;
		let _g = 0;
		while(_g < ctrlPts.length) {
			let cptrow = ctrlPts[_g];
			++_g;
			c = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,cptrow),knotsToInsert);
			newPts.push(c.controlPoints);
		}
		let newknots = c.knots;
		if(!useV) {
			newPts = verb_core_Mat.transposeN(newPts);
			return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,newknots,surface.knotsV.slice(),newPts);
		} else {
			return new verb_core_NurbsSurfaceData(surface.degreeU,surface.degreeV,surface.knotsU.slice(),newknots,newPts);
		}
	}
	static decomposeCurveIntoBeziers(curve) {
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		let knotmults = verb_eval_Analyze.knotMultiplicities(knots);
		let reqMult = degree + 1;
		let _g = 0;
		while(_g < knotmults.length) {
			let knotmult = knotmults[_g];
			++_g;
			if(knotmult.mult < reqMult) {
				let knotsInsert = verb_core_Vec.rep(reqMult - knotmult.mult,knotmult.knot);
				let res = verb_eval_Modify.curveKnotRefine(new verb_core_NurbsCurveData(degree,knots,controlPoints),knotsInsert);
				knots = res.knots;
				controlPoints = res.controlPoints;
			}
		}
		let numCrvs = knots.length / reqMult - 1;
		let crvKnotLength = reqMult * 2;
		let crvs = [];
		let i = 0;
		while(i < controlPoints.length) {
			let kts = knots.slice(i,i + crvKnotLength);
			let pts = controlPoints.slice(i,i + reqMult);
			crvs.push(new verb_core_NurbsCurveData(degree,kts,pts));
			i += reqMult;
		}
		return crvs;
	}
	static curveKnotRefine(curve,knotsToInsert) {
		if(knotsToInsert.length == 0) {
			return verb_eval_Make.clonedCurve(curve);
		}
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		let n = controlPoints.length - 1;
		let m = n + degree + 1;
		let r = knotsToInsert.length - 1;
		let a = verb_eval_Eval.knotSpan(degree,knotsToInsert[0],knots);
		let b = verb_eval_Eval.knotSpan(degree,knotsToInsert[r],knots);
		let controlPoints_post = [];
		let knots_post = [];
		let _g = 0;
		let _g1 = a - degree + 1;
		while(_g < _g1) {
			let i = _g++;
			controlPoints_post[i] = controlPoints[i];
		}
		let _g2 = b - 1;
		let _g3 = n + 1;
		while(_g2 < _g3) {
			let i = _g2++;
			controlPoints_post[i + r + 1] = controlPoints[i];
		}
		let _g4 = 0;
		let _g5 = a + 1;
		while(_g4 < _g5) {
			let i = _g4++;
			knots_post[i] = knots[i];
		}
		let _g6 = b + degree;
		let _g7 = m + 1;
		while(_g6 < _g7) {
			let i = _g6++;
			knots_post[i + r + 1] = knots[i];
		}
		let i = b + degree - 1;
		let k = b + degree + r;
		let j = r;
		while(j >= 0) {
			while(knotsToInsert[j] <= knots[i] && i > a) {
				controlPoints_post[k - degree - 1] = controlPoints[i - degree - 1];
				knots_post[k] = knots[i];
				--k;
				--i;
			}
			controlPoints_post[k - degree - 1] = controlPoints_post[k - degree];
			let _g = 1;
			let _g1 = degree + 1;
			while(_g < _g1) {
				let l = _g++;
				let ind = k - degree + l;
				let alfa = knots_post[k + l] - knotsToInsert[j];
				if(Math.abs(alfa) < verb_core_Constants.EPSILON) {
					controlPoints_post[ind - 1] = controlPoints_post[ind];
				} else {
					alfa /= knots_post[k + l] - knots[i - degree + l];
					controlPoints_post[ind - 1] = verb_core_Vec.add(verb_core_Vec.mul(alfa,controlPoints_post[ind - 1]),verb_core_Vec.mul(1.0 - alfa,controlPoints_post[ind]));
				}
			}
			knots_post[k] = knotsToInsert[j];
			--k;
			--j;
		}
		return new verb_core_NurbsCurveData(degree,knots_post,controlPoints_post);
	}
	static curveKnotInsert(curve,u,r) {
		let degree = curve.degree;
		let controlPoints = curve.controlPoints;
		let knots = curve.knots;
		let s = 0;
		let num_pts = controlPoints.length;
		let k = verb_eval_Eval.knotSpan(degree,u,knots);
		let num_pts_post = num_pts + r;
		let controlPoints_temp = [];
		let knots_post = [];
		let controlPoints_post = [];
		let i = 0;
		let _g = 1;
		let _g1 = k + 1;
		while(_g < _g1) {
			let i = _g++;
			knots_post[i] = knots[i];
		}
		let _g2 = 1;
		let _g3 = r + 1;
		while(_g2 < _g3) {
			let i = _g2++;
			knots_post[k + i] = u;
		}
		let _g4 = k + 1;
		let _g5 = knots.length;
		while(_g4 < _g5) {
			let i = _g4++;
			knots_post[i + r] = knots[i];
		}
		let _g6 = 0;
		let _g7 = k - degree + 1;
		while(_g6 < _g7) {
			let i = _g6++;
			controlPoints_post[i] = controlPoints[i];
		}
		let _g8 = k - s;
		let _g9 = num_pts;
		while(_g8 < _g9) {
			let i = _g8++;
			controlPoints_post[i + r] = controlPoints[i];
		}
		let _g10 = 0;
		let _g11 = degree - s + 1;
		while(_g10 < _g11) {
			let i = _g10++;
			controlPoints_temp[i] = controlPoints[k - degree + i];
		}
		let L = 0;
		let alpha = 0;
		let _g12 = 1;
		let _g13 = r + 1;
		while(_g12 < _g13) {
			let j = _g12++;
			L = k - degree + j;
			let _g = 0;
			let _g1 = degree - j - s + 1;
			while(_g < _g1) {
				let i = _g++;
				alpha = (u - knots[L + i]) / (knots[i + k + 1] - knots[L + i]);
				controlPoints_temp[i] = verb_core_Vec.add(verb_core_Vec.mul(alpha,controlPoints_temp[i + 1]),verb_core_Vec.mul(1.0 - alpha,controlPoints_temp[i]));
			}
			controlPoints_post[L] = controlPoints_temp[0];
			controlPoints_post[k + r - j - s] = controlPoints_temp[degree - j - s];
		}
		let _g14 = L + 1;
		let _g15 = k - s;
		while(_g14 < _g15) {
			let i = _g14++;
			controlPoints_post[i] = controlPoints_temp[i - L];
		}
		return new verb_core_NurbsCurveData(degree,knots_post,controlPoints_post);
	}
}
$hxClasses["verb.eval.Modify"] = $hx_exports["eval"]["Modify"] = verb_eval_Modify;
verb_eval_Modify.__name__ = "verb.eval.Modify";
class verb_eval_Tess {
	static rationalCurveRegularSample(curve,numSamples,includeU) {
		return verb_eval_Tess.rationalCurveRegularSampleRange(curve,curve.knots[0],verb_core_ArrayExtensions.last(curve.knots),numSamples,includeU);
	}
	static rationalCurveRegularSampleRange(curve,start,end,numSamples,includeU) {
		if(numSamples < 1) {
			numSamples = 2;
		}
		let p = [];
		let span = (end - start) / (numSamples - 1);
		let u = 0;
		let _g = 0;
		let _g1 = numSamples;
		while(_g < _g1) {
			let i = _g++;
			u = start + span * i;
			if(includeU) {
				let uVec = [u];
				p.push(uVec.concat(verb_eval_Eval.rationalCurvePoint(curve,u)));
			} else {
				p.push(verb_eval_Eval.rationalCurvePoint(curve,u));
			}
		}
		return p;
	}
	static rationalCurveAdaptiveSample(curve,tol,includeU) {
		if(includeU == null) {
			includeU = false;
		}
		if(tol == null) {
			tol = 1e-6;
		}
		if(curve.degree == 1) {
			if(!includeU) {
				let _this = curve.controlPoints;
				let f = verb_eval_Eval.dehomogenize;
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = f(_this[i]);
				}
				return result;
			} else {
				let _g = [];
				let _g1 = 0;
				let _g2 = curve.controlPoints.length;
				while(_g1 < _g2) {
					let i = _g1++;
					_g.push([curve.knots[i + 1]].concat(verb_eval_Eval.dehomogenize(curve.controlPoints[i])));
				}
				return _g;
			}
		}
		return verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,curve.knots[0],verb_core_ArrayExtensions.last(curve.knots),tol,includeU);
	}
	static rationalCurveAdaptiveSampleRange(curve,start,end,tol,includeU) {
		let p1 = verb_eval_Eval.rationalCurvePoint(curve,start);
		let p3 = verb_eval_Eval.rationalCurvePoint(curve,end);
		let t = 0.5 + 0.2 * Math.random();
		let mid = start + (end - start) * t;
		let p2 = verb_eval_Eval.rationalCurvePoint(curve,mid);
		let diff = verb_core_Vec.sub(p1,p3);
		let diff2 = verb_core_Vec.sub(p1,p2);
		if(verb_core_Vec.dot(diff,diff) < tol && verb_core_Vec.dot(diff2,diff2) > tol || !verb_core_Trig.threePointsAreFlat(p1,p2,p3,tol)) {
			let exact_mid = start + (end - start) * 0.5;
			let left_pts = verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,start,exact_mid,tol,includeU);
			let right_pts = verb_eval_Tess.rationalCurveAdaptiveSampleRange(curve,exact_mid,end,tol,includeU);
			return left_pts.slice(0,-1).concat(right_pts);
		} else if(includeU) {
			return [[start].concat(p1),[end].concat(p3)];
		} else {
			return [p1,p3];
		}
	}
	static rationalSurfaceNaive(surface,divs_u,divs_v) {
		if(divs_u < 1) {
			divs_u = 1;
		}
		if(divs_v < 1) {
			divs_v = 1;
		}
		let degreeU = surface.degreeU;
		let degreeV = surface.degreeV;
		let controlPoints = surface.controlPoints;
		let knotsU = surface.knotsU;
		let knotsV = surface.knotsV;
		let u_span = verb_core_ArrayExtensions.last(knotsU) - knotsU[0];
		let v_span = verb_core_ArrayExtensions.last(knotsV) - knotsV[0];
		let span_u = u_span / divs_u;
		let span_v = v_span / divs_v;
		let points = [];
		let uvs = [];
		let normals = [];
		let _g = 0;
		let _g1 = divs_u + 1;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = 0;
			let _g2 = divs_v + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				let pt_u = i * span_u;
				let pt_v = j * span_v;
				uvs.push([pt_u,pt_v]);
				let derivs = verb_eval_Eval.rationalSurfaceDerivatives(surface,pt_u,pt_v,1);
				let pt = derivs[0][0];
				points.push(pt);
				let normal = verb_core_Vec.normalized(verb_core_Vec.cross(derivs[1][0],derivs[0][1]));
				normals.push(normal);
			}
		}
		let faces = [];
		let _g2 = 0;
		let _g3 = divs_u;
		while(_g2 < _g3) {
			let i = _g2++;
			let _g = 0;
			let _g1 = divs_v;
			while(_g < _g1) {
				let j = _g++;
				let a_i = i * (divs_v + 1) + j;
				let b_i = (i + 1) * (divs_v + 1) + j;
				let c_i = b_i + 1;
				let d_i = a_i + 1;
				let abc = [a_i,b_i,c_i];
				let acd = [a_i,c_i,d_i];
				faces.push(abc);
				faces.push(acd);
			}
		}
		return new verb_core_MeshData(faces,points,normals,uvs);
	}
	static divideRationalSurfaceAdaptive(surface,options) {
		if(options == null) {
			options = new verb_eval_AdaptiveRefinementOptions();
		}
		options.minDivsU = options.minDivsU != null ? options.minDivsU : 1;
		options.minDivsU = options.minDivsV != null ? options.minDivsV : 1;
		options.refine = options.refine != null ? options.refine : true;
		let minU = (surface.controlPoints.length - 1) * 2;
		let minV = (surface.controlPoints[0].length - 1) * 2;
		let divsU = options.minDivsU = options.minDivsU > minU ? options.minDivsU : minU;
		let divsV = options.minDivsV = options.minDivsV > minV ? options.minDivsV : minV;
		let umax = verb_core_ArrayExtensions.last(surface.knotsU);
		let umin = surface.knotsU[0];
		let vmax = verb_core_ArrayExtensions.last(surface.knotsV);
		let vmin = surface.knotsV[0];
		let du = (umax - umin) / divsU;
		let dv = (vmax - vmin) / divsV;
		let divs = [];
		let pts = [];
		let _g = 0;
		let _g1 = divsV + 1;
		while(_g < _g1) {
			let i = _g++;
			let ptrow = [];
			let _g1 = 0;
			let _g2 = divsU + 1;
			while(_g1 < _g2) {
				let j = _g1++;
				let u = umin + du * j;
				let v = vmin + dv * i;
				let ds = verb_eval_Eval.rationalSurfaceDerivatives(surface,u,v,1);
				let norm = verb_core_Vec.normalized(verb_core_Vec.cross(ds[0][1],ds[1][0]));
				ptrow.push(new verb_core_SurfacePoint(ds[0][0],norm,[u,v],-1,verb_core_Vec.isZero(norm)));
			}
			pts.push(ptrow);
		}
		let _g2 = 0;
		let _g3 = divsV;
		while(_g2 < _g3) {
			let i = _g2++;
			let _g = 0;
			let _g1 = divsU;
			while(_g < _g1) {
				let j = _g++;
				let corners = [pts[divsV - i - 1][j],pts[divsV - i - 1][j + 1],pts[divsV - i][j + 1],pts[divsV - i][j]];
				divs.push(new verb_eval_AdaptiveRefinementNode(surface,corners));
			}
		}
		if(!options.refine) {
			return divs;
		}
		let _g4 = 0;
		let _g5 = divsV;
		while(_g4 < _g5) {
			let i = _g4++;
			let _g = 0;
			let _g1 = divsU;
			while(_g < _g1) {
				let j = _g++;
				let ci = i * divsU + j;
				let n = verb_eval_Tess.north(ci,i,j,divsU,divsV,divs);
				let e = verb_eval_Tess.east(ci,i,j,divsU,divsV,divs);
				let s = verb_eval_Tess.south(ci,i,j,divsU,divsV,divs);
				let w = verb_eval_Tess.west(ci,i,j,divsU,divsV,divs);
				divs[ci].neighbors = [s,e,n,w];
				divs[ci].divide(options);
			}
		}
		return divs;
	}
	static north(index,i,j,divsU,divsV,divs) {
		if(i == 0) {
			return null;
		}
		return divs[index - divsU];
	}
	static south(index,i,j,divsU,divsV,divs) {
		if(i == divsV - 1) {
			return null;
		}
		return divs[index + divsU];
	}
	static east(index,i,j,divsU,divsV,divs) {
		if(j == divsU - 1) {
			return null;
		}
		return divs[index + 1];
	}
	static west(index,i,j,divsU,divsV,divs) {
		if(j == 0) {
			return null;
		}
		return divs[index - 1];
	}
	static triangulateAdaptiveRefinementNodeTree(arrTree) {
		let mesh = verb_core_MeshData.empty();
		let _g = 0;
		while(_g < arrTree.length) {
			let x = arrTree[_g];
			++_g;
			x.triangulate(mesh);
		}
		return mesh;
	}
	static rationalSurfaceAdaptive(surface,options) {
		if(options == null) {
			options = new verb_eval_AdaptiveRefinementOptions();
		}
		let arrTrees = verb_eval_Tess.divideRationalSurfaceAdaptive(surface,options);
		return verb_eval_Tess.triangulateAdaptiveRefinementNodeTree(arrTrees);
	}
}
$hxClasses["verb.eval.Tess"] = $hx_exports["eval"]["Tess"] = verb_eval_Tess;
verb_eval_Tess.__name__ = "verb.eval.Tess";
class verb_eval_AdaptiveRefinementOptions {
	constructor() {
		this.minDivsV = 1;
		this.minDivsU = 1;
		this.refine = true;
		this.maxDepth = 10;
		this.minDepth = 0;
		this.normTol = 2.5e-2;
	}
}
$hxClasses["verb.eval.AdaptiveRefinementOptions"] = $hx_exports["core"]["AdaptiveRefinementOptions"] = verb_eval_AdaptiveRefinementOptions;
verb_eval_AdaptiveRefinementOptions.__name__ = "verb.eval.AdaptiveRefinementOptions";
Object.assign(verb_eval_AdaptiveRefinementOptions.prototype, {
	__class__: verb_eval_AdaptiveRefinementOptions
});
class verb_eval_AdaptiveRefinementNode {
	constructor(srf,corners,neighbors) {
		this.srf = srf;
		this.neighbors = neighbors == null ? [null,null,null,null] : neighbors;
		this.corners = corners;
		if(this.corners == null) {
			let u0 = srf.knotsU[0];
			let u1 = verb_core_ArrayExtensions.last(srf.knotsU);
			let v0 = srf.knotsV[0];
			let v1 = verb_core_ArrayExtensions.last(srf.knotsV);
			this.corners = [verb_core_SurfacePoint.fromUv(u0,v0),verb_core_SurfacePoint.fromUv(u1,v0),verb_core_SurfacePoint.fromUv(u1,v1),verb_core_SurfacePoint.fromUv(u0,v1)];
		}
	}
	isLeaf() {
		return this.children == null;
	}
	center() {
		if(this.centerPoint != null) {
			return this.centerPoint;
		} else {
			return this.evalSrf(this.u05,this.v05);
		}
	}
	evalCorners() {
		this.u05 = (this.corners[0].uv[0] + this.corners[2].uv[0]) / 2;
		this.v05 = (this.corners[0].uv[1] + this.corners[2].uv[1]) / 2;
		if(this.corners[0].point == null) {
			let c = this.corners[0];
			this.evalSrf(c.uv[0],c.uv[1],c);
		}
		if(this.corners[1].point == null) {
			let c = this.corners[1];
			this.evalSrf(c.uv[0],c.uv[1],c);
		}
		if(this.corners[2].point == null) {
			let c = this.corners[2];
			this.evalSrf(c.uv[0],c.uv[1],c);
		}
		if(this.corners[3].point == null) {
			let c = this.corners[3];
			this.evalSrf(c.uv[0],c.uv[1],c);
		}
	}
	evalSrf(u,v,srfPt) {
		let derivs = verb_eval_Eval.rationalSurfaceDerivatives(this.srf,u,v,1);
		let pt = derivs[0][0];
		let norm = verb_core_Vec.cross(derivs[0][1],derivs[1][0]);
		let degen = verb_core_Vec.isZero(norm);
		if(!degen) {
			norm = verb_core_Vec.normalized(norm);
		}
		if(srfPt != null) {
			srfPt.degen = degen;
			srfPt.point = pt;
			srfPt.normal = norm;
			return srfPt;
		} else {
			return new verb_core_SurfacePoint(pt,norm,[u,v],-1,degen);
		}
	}
	getEdgeCorners(edgeIndex) {
		if(this.isLeaf()) {
			return [this.corners[edgeIndex]];
		}
		if(this.horizontal) {
			switch(edgeIndex) {
			case 0:
				return this.children[0].getEdgeCorners(0);
			case 1:
				return this.children[0].getEdgeCorners(1).concat(this.children[1].getEdgeCorners(1));
			case 2:
				return this.children[1].getEdgeCorners(2);
			case 3:
				return this.children[1].getEdgeCorners(3).concat(this.children[0].getEdgeCorners(3));
			}
		}
		switch(edgeIndex) {
		case 0:
			return this.children[0].getEdgeCorners(0).concat(this.children[1].getEdgeCorners(0));
		case 1:
			return this.children[1].getEdgeCorners(1);
		case 2:
			return this.children[1].getEdgeCorners(2).concat(this.children[0].getEdgeCorners(2));
		case 3:
			return this.children[0].getEdgeCorners(3);
		}
		return null;
	}
	getAllCorners(edgeIndex) {
		let baseArr = [this.corners[edgeIndex]];
		if(this.neighbors[edgeIndex] == null) {
			return baseArr;
		}
		let corners = this.neighbors[edgeIndex].getEdgeCorners((edgeIndex + 2) % 4);
		let funcIndex = edgeIndex % 2;
		let e = verb_core_Constants.EPSILON;
		let that = this;
		let rangeFuncMap = [function(c) {
			if(c.uv[0] > that.corners[0].uv[0] + e) {
				return c.uv[0] < that.corners[2].uv[0] - e;
			} else {
				return false;
			}
		},function(c) {
			if(c.uv[1] > that.corners[0].uv[1] + e) {
				return c.uv[1] < that.corners[2].uv[1] - e;
			} else {
				return false;
			}
		}];
		let f = rangeFuncMap[funcIndex];
		let _g = [];
		let _g1 = 0;
		let _g2 = corners;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(f(v)) {
				_g.push(v);
			}
		}
		let cornercopy = _g;
		cornercopy.reverse();
		return baseArr.concat(cornercopy);
	}
	midpoint(index) {
		if(this.midPoints == null) {
			this.midPoints = [null,null,null,null];
		}
		if(this.midPoints[index] != null) {
			return this.midPoints[index];
		}
		switch(index) {
		case 0:
			this.midPoints[0] = this.evalSrf(this.u05,this.corners[0].uv[1]);
			break;
		case 1:
			this.midPoints[1] = this.evalSrf(this.corners[1].uv[0],this.v05);
			break;
		case 2:
			this.midPoints[2] = this.evalSrf(this.u05,this.corners[2].uv[1]);
			break;
		case 3:
			this.midPoints[3] = this.evalSrf(this.corners[0].uv[0],this.v05);
			break;
		}
		return this.midPoints[index];
	}
	hasBadNormals() {
		if(!(this.corners[0].degen || this.corners[1].degen || this.corners[2].degen)) {
			return this.corners[3].degen;
		} else {
			return true;
		}
	}
	fixNormals() {
		let l = this.corners.length;
		let _g = 0;
		let _g1 = l;
		while(_g < _g1) {
			let i = _g++;
			let corn = this.corners[i];
			if(this.corners[i].degen) {
				let v1 = this.corners[(i + 1) % l];
				let v2 = this.corners[(i + 3) % l];
				this.corners[i].normal = v1.degen ? v2.normal : v1.normal;
			}
		}
	}
	shouldDivide(options,currentDepth) {
		if(currentDepth < options.minDepth) {
			return true;
		}
		if(currentDepth >= options.maxDepth) {
			return false;
		}
		if(this.hasBadNormals()) {
			this.fixNormals();
			return false;
		}
		this.splitVert = verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[0].normal,this.corners[1].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[2].normal,this.corners[3].normal)) > options.normTol;
		this.splitHoriz = verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[1].normal,this.corners[2].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(this.corners[3].normal,this.corners[0].normal)) > options.normTol;
		if(this.splitVert || this.splitHoriz) {
			return true;
		}
		let center = this.center();
		if(!(verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[0].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[1].normal)) > options.normTol || verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[2].normal)) > options.normTol)) {
			return verb_core_Vec.normSquared(verb_core_Vec.sub(center.normal,this.corners[3].normal)) > options.normTol;
		} else {
			return true;
		}
	}
	divide(options) {
		if(options == null) {
			options = new verb_eval_AdaptiveRefinementOptions();
		}
		if(options.normTol == null) {
			options.normTol = 8.5e-2;
		}
		if(options.minDepth == null) {
			options.minDepth = 0;
		}
		if(options.maxDepth == null) {
			options.maxDepth = 10;
		}
		this._divide(options,0,true);
	}
	_divide(options,currentDepth,horiz) {
		this.evalCorners();
		if(!this.shouldDivide(options,currentDepth)) {
			return;
		}
		++currentDepth;
		if(this.splitVert && !this.splitHoriz) {
			horiz = false;
		} else if(!this.splitVert && this.splitHoriz) {
			horiz = true;
		}
		this.horizontal = horiz;
		if(this.horizontal) {
			let bott = [this.corners[0],this.corners[1],this.midpoint(1),this.midpoint(3)];
			let top = [this.midpoint(3),this.midpoint(1),this.corners[2],this.corners[3]];
			this.children = [new verb_eval_AdaptiveRefinementNode(this.srf,bott),new verb_eval_AdaptiveRefinementNode(this.srf,top)];
			this.children[0].neighbors = [this.neighbors[0],this.neighbors[1],this.children[1],this.neighbors[3]];
			this.children[1].neighbors = [this.children[0],this.neighbors[1],this.neighbors[2],this.neighbors[3]];
		} else {
			let left = [this.corners[0],this.midpoint(0),this.midpoint(2),this.corners[3]];
			let right = [this.midpoint(0),this.corners[1],this.corners[2],this.midpoint(2)];
			this.children = [new verb_eval_AdaptiveRefinementNode(this.srf,left),new verb_eval_AdaptiveRefinementNode(this.srf,right)];
			this.children[0].neighbors = [this.neighbors[0],this.children[1],this.neighbors[2],this.neighbors[3]];
			this.children[1].neighbors = [this.neighbors[0],this.neighbors[1],this.neighbors[2],this.children[0]];
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			child._divide(options,currentDepth,!horiz);
		}
	}
	triangulate(mesh) {
		if(mesh == null) {
			mesh = verb_core_MeshData.empty();
		}
		if(this.isLeaf()) {
			return this.triangulateLeaf(mesh);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let x = _g1[_g];
			++_g;
			if(x == null) {
				break;
			}
			x.triangulate(mesh);
		}
		return mesh;
	}
	triangulateLeaf(mesh) {
		let baseIndex = mesh.points.length;
		let uvs = [];
		let ids = [];
		let splitid = 0;
		let edgeCorners = this.getAllCorners(0);
		if(edgeCorners.length == 2) {
			splitid = 1;
		}
		let _g = 0;
		let _g1 = edgeCorners.length;
		while(_g < _g1) {
			let j = _g++;
			uvs.push(edgeCorners[j]);
		}
		let edgeCorners1 = this.getAllCorners(1);
		if(edgeCorners1.length == 2) {
			splitid = 2;
		}
		let _g2 = 0;
		let _g3 = edgeCorners1.length;
		while(_g2 < _g3) {
			let j = _g2++;
			uvs.push(edgeCorners1[j]);
		}
		let edgeCorners2 = this.getAllCorners(2);
		if(edgeCorners2.length == 2) {
			splitid = 3;
		}
		let _g4 = 0;
		let _g5 = edgeCorners2.length;
		while(_g4 < _g5) {
			let j = _g4++;
			uvs.push(edgeCorners2[j]);
		}
		let edgeCorners3 = this.getAllCorners(3);
		if(edgeCorners3.length == 2) {
			splitid = 4;
		}
		let _g6 = 0;
		let _g7 = edgeCorners3.length;
		while(_g6 < _g7) {
			let j = _g6++;
			uvs.push(edgeCorners3[j]);
		}
		let _g8 = 0;
		while(_g8 < uvs.length) {
			let corner = uvs[_g8];
			++_g8;
			if(corner.id != -1) {
				ids.push(corner.id);
				continue;
			}
			mesh.uvs.push(corner.uv);
			mesh.points.push(corner.point);
			mesh.normals.push(corner.normal);
			corner.id = baseIndex;
			ids.push(baseIndex);
			++baseIndex;
		}
		if(uvs.length == 4) {
			mesh.faces.push([ids[0],ids[3],ids[1]]);
			mesh.faces.push([ids[3],ids[2],ids[1]]);
			return mesh;
		} else if(uvs.length == 5) {
			let il = ids.length;
			mesh.faces.push([ids[splitid],ids[(splitid + 2) % il],ids[(splitid + 1) % il]]);
			mesh.faces.push([ids[(splitid + 4) % il],ids[(splitid + 3) % il],ids[splitid]]);
			mesh.faces.push([ids[splitid],ids[(splitid + 3) % il],ids[(splitid + 2) % il]]);
			return mesh;
		}
		let center = this.center();
		mesh.uvs.push(center.uv);
		mesh.points.push(center.point);
		mesh.normals.push(center.normal);
		let centerIndex = mesh.points.length - 1;
		let i = 0;
		let j = uvs.length - 1;
		while(i < uvs.length) {
			mesh.faces.push([centerIndex,ids[i],ids[j]]);
			++i;
			j = i - 1;
		}
		return mesh;
	}
}
$hxClasses["verb.eval.AdaptiveRefinementNode"] = $hx_exports["core"]["AdaptiveRefinementNode"] = verb_eval_AdaptiveRefinementNode;
verb_eval_AdaptiveRefinementNode.__name__ = "verb.eval.AdaptiveRefinementNode";
Object.assign(verb_eval_AdaptiveRefinementNode.prototype, {
	__class__: verb_eval_AdaptiveRefinementNode
});
class verb_geom_ICurve {
}
$hxClasses["verb.geom.ICurve"] = verb_geom_ICurve;
verb_geom_ICurve.__name__ = "verb.geom.ICurve";
verb_geom_ICurve.__isInterface__ = true;
verb_geom_ICurve.__interfaces__ = [verb_core_ISerializable];
Object.assign(verb_geom_ICurve.prototype, {
	__class__: verb_geom_ICurve
});
class verb_geom_NurbsCurve extends verb_core_SerializableBase {
	constructor(data) {
		super();
		this._data = verb_eval_Check.isValidNurbsCurveData(data);
	}
	degree() {
		return this._data.degree;
	}
	knots() {
		return this._data.knots.slice(0);
	}
	controlPoints() {
		return verb_eval_Eval.dehomogenize1d(this._data.controlPoints);
	}
	weights() {
		return verb_eval_Eval.weight1d(this._data.controlPoints);
	}
	asNurbs() {
		return new verb_core_NurbsCurveData(this.degree(),this.knots(),verb_eval_Eval.homogenize1d(this.controlPoints(),this.weights()));
	}
	clone() {
		return new verb_geom_NurbsCurve(this._data);
	}
	domain() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knots),verb_core_ArrayExtensions.last(this._data.knots));
	}
	transform(mat) {
		return new verb_geom_NurbsCurve(verb_eval_Modify.rationalCurveTransform(this._data,mat));
	}
	point(u) {
		return verb_eval_Eval.rationalCurvePoint(this._data,u);
	}
	tangent(u) {
		return verb_eval_Eval.rationalCurveTangent(this._data,u);
	}
	derivatives(u,numDerivs) {
		if(numDerivs == null) {
			numDerivs = 1;
		}
		return verb_eval_Eval.rationalCurveDerivatives(this._data,u,numDerivs);
	}
	closestPoint(pt) {
		return verb_eval_Analyze.rationalCurveClosestPoint(this._data,pt);
	}
	closestParam(pt) {
		return verb_eval_Analyze.rationalCurveClosestParam(this._data,pt);
	}
	length() {
		return verb_eval_Analyze.rationalCurveArcLength(this._data);
	}
	lengthAtParam(u) {
		return verb_eval_Analyze.rationalCurveArcLength(this._data,u);
	}
	paramAtLength(len,tolerance) {
		return verb_eval_Analyze.rationalCurveParamAtArcLength(this._data,len,tolerance);
	}
	divideByEqualArcLength(divisions) {
		return verb_eval_Divide.rationalCurveByEqualArcLength(this._data,divisions);
	}
	divideByArcLength(arcLength) {
		return verb_eval_Divide.rationalCurveByArcLength(this._data,arcLength);
	}
	split(u) {
		let _this = verb_eval_Divide.curveSplit(this._data,u);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = new verb_geom_NurbsCurve(_this[i]);
		}
		return result;
	}
	reverse() {
		return new verb_geom_NurbsCurve(verb_eval_Modify.curveReverse(this._data));
	}
	tessellate(tolerance) {
		return verb_eval_Tess.rationalCurveAdaptiveSample(this._data,tolerance,false);
	}
	static byKnotsControlPointsWeights(degree,knots,controlPoints,weights) {
		return new verb_geom_NurbsCurve(new verb_core_NurbsCurveData(degree,knots.slice(),verb_eval_Eval.homogenize1d(controlPoints,weights)));
	}
	static byPoints(points,degree) {
		if(degree == null) {
			degree = 3;
		}
		return new verb_geom_NurbsCurve(verb_eval_Make.rationalInterpCurve(points,degree));
	}
}
$hxClasses["verb.geom.NurbsCurve"] = $hx_exports["geom"]["NurbsCurve"] = verb_geom_NurbsCurve;
verb_geom_NurbsCurve.__name__ = "verb.geom.NurbsCurve";
verb_geom_NurbsCurve.__interfaces__ = [verb_geom_ICurve];
verb_geom_NurbsCurve.__super__ = verb_core_SerializableBase;
Object.assign(verb_geom_NurbsCurve.prototype, {
	__class__: verb_geom_NurbsCurve
});
class verb_geom_Arc extends verb_geom_NurbsCurve {
	constructor(center,xaxis,yaxis,radius,minAngle,maxAngle) {
		super(verb_eval_Make.arc(center,xaxis,yaxis,radius,minAngle,maxAngle));
		this._center = center;
		this._xaxis = xaxis;
		this._yaxis = yaxis;
		this._radius = radius;
		this._minAngle = minAngle;
		this._maxAngle = maxAngle;
	}
	center() {
		return this._center;
	}
	xaxis() {
		return this._xaxis;
	}
	yaxis() {
		return this._yaxis;
	}
	radius() {
		return this._radius;
	}
	minAngle() {
		return this._minAngle;
	}
	maxAngle() {
		return this._maxAngle;
	}
}
$hxClasses["verb.geom.Arc"] = $hx_exports["geom"]["Arc"] = verb_geom_Arc;
verb_geom_Arc.__name__ = "verb.geom.Arc";
verb_geom_Arc.__super__ = verb_geom_NurbsCurve;
Object.assign(verb_geom_Arc.prototype, {
	__class__: verb_geom_Arc
});
class verb_geom_BezierCurve extends verb_geom_NurbsCurve {
	constructor(points,weights) {
		super(verb_eval_Make.rationalBezierCurve(points,weights));
	}
}
$hxClasses["verb.geom.BezierCurve"] = $hx_exports["geom"]["BezierCurve"] = verb_geom_BezierCurve;
verb_geom_BezierCurve.__name__ = "verb.geom.BezierCurve";
verb_geom_BezierCurve.__super__ = verb_geom_NurbsCurve;
Object.assign(verb_geom_BezierCurve.prototype, {
	__class__: verb_geom_BezierCurve
});
class verb_geom_Circle extends verb_geom_Arc {
	constructor(center,xaxis,yaxis,radius) {
		super(center,xaxis,yaxis,radius,0,Math.PI * 2);
	}
}
$hxClasses["verb.geom.Circle"] = $hx_exports["geom"]["Circle"] = verb_geom_Circle;
verb_geom_Circle.__name__ = "verb.geom.Circle";
verb_geom_Circle.__super__ = verb_geom_Arc;
Object.assign(verb_geom_Circle.prototype, {
	__class__: verb_geom_Circle
});
class verb_geom_ISurface {
}
$hxClasses["verb.geom.ISurface"] = verb_geom_ISurface;
verb_geom_ISurface.__name__ = "verb.geom.ISurface";
verb_geom_ISurface.__isInterface__ = true;
verb_geom_ISurface.__interfaces__ = [verb_core_ISerializable];
Object.assign(verb_geom_ISurface.prototype, {
	__class__: verb_geom_ISurface
});
class verb_geom_NurbsSurface extends verb_core_SerializableBase {
	constructor(data) {
		super();
		this._data = verb_eval_Check.isValidNurbsSurfaceData(data);
	}
	degreeU() {
		return this._data.degreeU;
	}
	degreeV() {
		return this._data.degreeV;
	}
	knotsU() {
		return this._data.knotsU.slice(0);
	}
	knotsV() {
		return this._data.knotsV.slice(0);
	}
	controlPoints() {
		return verb_eval_Eval.dehomogenize2d(this._data.controlPoints);
	}
	weights() {
		return verb_eval_Eval.weight2d(this._data.controlPoints);
	}
	asNurbs() {
		return new verb_core_NurbsSurfaceData(this.degreeU(),this.degreeV(),this.knotsU(),this.knotsV(),verb_eval_Eval.homogenize2d(this.controlPoints(),this.weights()));
	}
	clone() {
		return new verb_geom_NurbsSurface(this.asNurbs());
	}
	domainU() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knotsU),verb_core_ArrayExtensions.last(this._data.knotsU));
	}
	domainV() {
		return new verb_core_Interval(verb_core_ArrayExtensions.first(this._data.knotsV),verb_core_ArrayExtensions.last(this._data.knotsV));
	}
	point(u,v) {
		return verb_eval_Eval.rationalSurfacePoint(this._data,u,v);
	}
	normal(u,v) {
		return verb_eval_Eval.rationalSurfaceNormal(this._data,u,v);
	}
	derivatives(u,v,numDerivs) {
		if(numDerivs == null) {
			numDerivs = 1;
		}
		return verb_eval_Eval.rationalSurfaceDerivatives(this._data,u,v,numDerivs);
	}
	closestParam(pt) {
		return verb_eval_Analyze.rationalSurfaceClosestParam(this._data,pt);
	}
	closestPoint(pt) {
		return verb_eval_Analyze.rationalSurfaceClosestPoint(this._data,pt);
	}
	split(u,useV) {
		if(useV == null) {
			useV = false;
		}
		let _this = verb_eval_Divide.surfaceSplit(this._data,u,useV);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = new verb_geom_NurbsSurface(_this[i]);
		}
		return result;
	}
	reverse(useV) {
		if(useV == null) {
			useV = false;
		}
		return new verb_geom_NurbsSurface(verb_eval_Modify.surfaceReverse(this._data,useV));
	}
	isocurve(u,useV) {
		if(useV == null) {
			useV = false;
		}
		return new verb_geom_NurbsCurve(verb_eval_Make.surfaceIsocurve(this._data,u,useV));
	}
	boundaries(options) {
		let _this = verb_eval_Make.surfaceBoundaryCurves(this._data);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = new verb_geom_NurbsCurve(_this[i]);
		}
		return result;
	}
	tessellate(options) {
		return verb_eval_Tess.rationalSurfaceAdaptive(this._data,options);
	}
	transform(mat) {
		return new verb_geom_NurbsSurface(verb_eval_Modify.rationalSurfaceTransform(this._data,mat));
	}
	static byKnotsControlPointsWeights(degreeU,degreeV,knotsU,knotsV,controlPoints,weights) {
		return new verb_geom_NurbsSurface(new verb_core_NurbsSurfaceData(degreeU,degreeV,knotsU,knotsV,verb_eval_Eval.homogenize2d(controlPoints,weights)));
	}
	static byCorners(point0,point1,point2,point3) {
		return new verb_geom_NurbsSurface(verb_eval_Make.fourPointSurface(point0,point1,point2,point3));
	}
	static byLoftingCurves(curves,degreeV) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < curves.length) {
			let c = curves[_g1];
			++_g1;
			_g.push(c.asNurbs());
		}
		return new verb_geom_NurbsSurface(verb_eval_Make.loftedSurface(_g,degreeV));
	}
}
$hxClasses["verb.geom.NurbsSurface"] = $hx_exports["geom"]["NurbsSurface"] = verb_geom_NurbsSurface;
verb_geom_NurbsSurface.__name__ = "verb.geom.NurbsSurface";
verb_geom_NurbsSurface.__interfaces__ = [verb_geom_ISurface];
verb_geom_NurbsSurface.__super__ = verb_core_SerializableBase;
Object.assign(verb_geom_NurbsSurface.prototype, {
	__class__: verb_geom_NurbsSurface
});
class verb_geom_ConicalSurface extends verb_geom_NurbsSurface {
	constructor(axis,xaxis,base,height,radius) {
		super(verb_eval_Make.conicalSurface(axis,xaxis,base,height,radius));
		this._axis = axis;
		this._xaxis = xaxis;
		this._base = base;
		this._height = height;
		this._radius = radius;
	}
	axis() {
		return this._axis;
	}
	xaxis() {
		return this._xaxis;
	}
	base() {
		return this._base;
	}
	height() {
		return this._height;
	}
	radius() {
		return this._radius;
	}
}
$hxClasses["verb.geom.ConicalSurface"] = $hx_exports["geom"]["ConicalSurface"] = verb_geom_ConicalSurface;
verb_geom_ConicalSurface.__name__ = "verb.geom.ConicalSurface";
verb_geom_ConicalSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_ConicalSurface.prototype, {
	__class__: verb_geom_ConicalSurface
});
class verb_geom_CylindricalSurface extends verb_geom_NurbsSurface {
	constructor(axis,xaxis,base,height,radius) {
		super(verb_eval_Make.cylindricalSurface(axis,xaxis,base,height,radius));
		this._axis = axis;
		this._xaxis = xaxis;
		this._base = base;
		this._height = height;
		this._radius = radius;
	}
	axis() {
		return this._axis;
	}
	xaxis() {
		return this._xaxis;
	}
	base() {
		return this._base;
	}
	height() {
		return this._height;
	}
	radius() {
		return this._radius;
	}
}
$hxClasses["verb.geom.CylindricalSurface"] = $hx_exports["geom"]["CylindricalSurface"] = verb_geom_CylindricalSurface;
verb_geom_CylindricalSurface.__name__ = "verb.geom.CylindricalSurface";
verb_geom_CylindricalSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_CylindricalSurface.prototype, {
	__class__: verb_geom_CylindricalSurface
});
class verb_geom_EllipseArc extends verb_geom_NurbsCurve {
	constructor(center,xaxis,yaxis,minAngle,maxAngle) {
		super(verb_eval_Make.ellipseArc(center,xaxis,yaxis,minAngle,maxAngle));
		this._center = center;
		this._xaxis = xaxis;
		this._yaxis = yaxis;
		this._minAngle = minAngle;
		this._maxAngle = maxAngle;
	}
	center() {
		return this._center;
	}
	xaxis() {
		return this._xaxis;
	}
	yaxis() {
		return this._yaxis;
	}
	minAngle() {
		return this._minAngle;
	}
	maxAngle() {
		return this._maxAngle;
	}
}
$hxClasses["verb.geom.EllipseArc"] = $hx_exports["geom"]["EllipseArc"] = verb_geom_EllipseArc;
verb_geom_EllipseArc.__name__ = "verb.geom.EllipseArc";
verb_geom_EllipseArc.__super__ = verb_geom_NurbsCurve;
Object.assign(verb_geom_EllipseArc.prototype, {
	__class__: verb_geom_EllipseArc
});
class verb_geom_Ellipse extends verb_geom_EllipseArc {
	constructor(center,xaxis,yaxis) {
		super(center,xaxis,yaxis,0,Math.PI * 2);
	}
}
$hxClasses["verb.geom.Ellipse"] = $hx_exports["geom"]["Ellipse"] = verb_geom_Ellipse;
verb_geom_Ellipse.__name__ = "verb.geom.Ellipse";
verb_geom_Ellipse.__super__ = verb_geom_EllipseArc;
Object.assign(verb_geom_Ellipse.prototype, {
	__class__: verb_geom_Ellipse
});
class verb_geom_ExtrudedSurface extends verb_geom_NurbsSurface {
	constructor(profile,direction) {
		super(verb_eval_Make.extrudedSurface(verb_core_Vec.normalized(direction),verb_core_Vec.norm(direction),profile.asNurbs()));
		this._profile = profile;
		this._direction = direction;
	}
	profile() {
		return this._profile;
	}
	direction() {
		return this._direction;
	}
}
$hxClasses["verb.geom.ExtrudedSurface"] = $hx_exports["geom"]["ExtrudedSurface"] = verb_geom_ExtrudedSurface;
verb_geom_ExtrudedSurface.__name__ = "verb.geom.ExtrudedSurface";
verb_geom_ExtrudedSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_ExtrudedSurface.prototype, {
	__class__: verb_geom_ExtrudedSurface
});
class verb_geom_Intersect {
	static curves(first,second,tol) {
		if(tol == null) {
			tol = 1e-3;
		}
		return verb_eval_Intersect.curves(first.asNurbs(),second.asNurbs(),tol);
	}
	static curveAndSurface(curve,surface,tol) {
		if(tol == null) {
			tol = 1e-3;
		}
		return verb_eval_Intersect.curveAndSurface(curve.asNurbs(),surface.asNurbs(),tol);
	}
	static surfaces(first,second,tol) {
		if(tol == null) {
			tol = 1e-3;
		}
		let _this = verb_eval_Intersect.surfaces(first.asNurbs(),second.asNurbs(),tol);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = new verb_geom_NurbsCurve(_this[i]);
		}
		return result;
	}
}
$hxClasses["verb.geom.Intersect"] = $hx_exports["geom"]["Intersect"] = verb_geom_Intersect;
verb_geom_Intersect.__name__ = "verb.geom.Intersect";
class verb_geom_Line extends verb_geom_NurbsCurve {
	constructor(start,end) {
		super(verb_eval_Make.polyline([start,end]));
		this._start = start;
		this._end = end;
	}
	start() {
		return this._start;
	}
	end() {
		return this._end;
	}
}
$hxClasses["verb.geom.Line"] = $hx_exports["geom"]["Line"] = verb_geom_Line;
verb_geom_Line.__name__ = "verb.geom.Line";
verb_geom_Line.__super__ = verb_geom_NurbsCurve;
Object.assign(verb_geom_Line.prototype, {
	__class__: verb_geom_Line
});
class verb_geom_RevolvedSurface extends verb_geom_NurbsSurface {
	constructor(profile,center,axis,angle) {
		super(verb_eval_Make.revolvedSurface(profile.asNurbs(),center,axis,angle));
		this._profile = profile;
		this._center = center;
		this._axis = axis;
		this._angle = angle;
	}
	profile() {
		return this._profile;
	}
	center() {
		return this._center;
	}
	axis() {
		return this._center;
	}
	angle() {
		return this._angle;
	}
}
$hxClasses["verb.geom.RevolvedSurface"] = $hx_exports["geom"]["RevolvedSurface"] = verb_geom_RevolvedSurface;
verb_geom_RevolvedSurface.__name__ = "verb.geom.RevolvedSurface";
verb_geom_RevolvedSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_RevolvedSurface.prototype, {
	__class__: verb_geom_RevolvedSurface
});
class verb_geom_SphericalSurface extends verb_geom_NurbsSurface {
	constructor(center,radius) {
		super(verb_eval_Make.sphericalSurface(center,[0,0,1],[1,0,0],radius));
		this._center = center;
		this._radius = radius;
	}
	center() {
		return this._center;
	}
	radius() {
		return this._radius;
	}
}
$hxClasses["verb.geom.SphericalSurface"] = $hx_exports["geom"]["SphericalSurface"] = verb_geom_SphericalSurface;
verb_geom_SphericalSurface.__name__ = "verb.geom.SphericalSurface";
verb_geom_SphericalSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_SphericalSurface.prototype, {
	__class__: verb_geom_SphericalSurface
});
class verb_geom_SweptSurface extends verb_geom_NurbsSurface {
	constructor(profile,rail) {
		super(verb_eval_Make.rationalTranslationalSurface(profile.asNurbs(),rail.asNurbs()));
		this._profile = profile;
		this._rail = rail;
	}
	profile() {
		return this._profile;
	}
	rail() {
		return this._rail;
	}
}
$hxClasses["verb.geom.SweptSurface"] = $hx_exports["geom"]["SweptSurface"] = verb_geom_SweptSurface;
verb_geom_SweptSurface.__name__ = "verb.geom.SweptSurface";
verb_geom_SweptSurface.__super__ = verb_geom_NurbsSurface;
Object.assign(verb_geom_SweptSurface.prototype, {
	__class__: verb_geom_SweptSurface
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
verb_core_Binomial.memo = new haxe_ds_IntMap();
$hx_exports["TOLERANCE"] = verb_core_Constants.TOLERANCE = 1e-6;
$hx_exports["EPSILON"] = verb_core_Constants.EPSILON = 1e-10;
$hx_exports["VERSION"] = verb_core_Constants.VERSION = "2.0.0";
verb_eval_Analyze.Tvalues = [[],[],[-0.5773502691896257645091487805019574556476,0.5773502691896257645091487805019574556476],[0,-0.7745966692414833770358530799564799221665,0.7745966692414833770358530799564799221665],[-0.3399810435848562648026657591032446872005,0.3399810435848562648026657591032446872005,-0.8611363115940525752239464888928095050957,0.8611363115940525752239464888928095050957],[0,-0.5384693101056830910363144207002088049672,0.5384693101056830910363144207002088049672,-0.9061798459386639927976268782993929651256,0.9061798459386639927976268782993929651256],[0.6612093864662645136613995950199053470064,-0.6612093864662645136613995950199053470064,-0.2386191860831969086305017216807119354186,0.2386191860831969086305017216807119354186,-0.9324695142031520278123015544939946091347,0.9324695142031520278123015544939946091347],[0,0.4058451513773971669066064120769614633473,-0.4058451513773971669066064120769614633473,-0.7415311855993944398638647732807884070741,0.7415311855993944398638647732807884070741,-0.9491079123427585245261896840478512624007,0.9491079123427585245261896840478512624007],[-0.1834346424956498049394761423601839806667,0.1834346424956498049394761423601839806667,-0.5255324099163289858177390491892463490419,0.5255324099163289858177390491892463490419,-0.7966664774136267395915539364758304368371,0.7966664774136267395915539364758304368371,-0.9602898564975362316835608685694729904282,0.9602898564975362316835608685694729904282],[0,-0.8360311073266357942994297880697348765441,0.8360311073266357942994297880697348765441,-0.9681602395076260898355762029036728700494,0.9681602395076260898355762029036728700494,-0.3242534234038089290385380146433366085719,0.3242534234038089290385380146433366085719,-0.6133714327005903973087020393414741847857,0.6133714327005903973087020393414741847857],[-0.1488743389816312108848260011297199846175,0.1488743389816312108848260011297199846175,-0.4333953941292471907992659431657841622000,0.4333953941292471907992659431657841622000,-0.6794095682990244062343273651148735757692,0.6794095682990244062343273651148735757692,-0.8650633666889845107320966884234930485275,0.8650633666889845107320966884234930485275,-0.9739065285171717200779640120844520534282,0.9739065285171717200779640120844520534282],[0,-0.2695431559523449723315319854008615246796,0.2695431559523449723315319854008615246796,-0.5190961292068118159257256694586095544802,0.5190961292068118159257256694586095544802,-0.7301520055740493240934162520311534580496,0.7301520055740493240934162520311534580496,-0.8870625997680952990751577693039272666316,0.8870625997680952990751577693039272666316,-0.9782286581460569928039380011228573907714,0.9782286581460569928039380011228573907714],[-0.1252334085114689154724413694638531299833,0.1252334085114689154724413694638531299833,-0.3678314989981801937526915366437175612563,0.3678314989981801937526915366437175612563,-0.5873179542866174472967024189405342803690,0.5873179542866174472967024189405342803690,-0.7699026741943046870368938332128180759849,0.7699026741943046870368938332128180759849,-0.9041172563704748566784658661190961925375,0.9041172563704748566784658661190961925375,-0.9815606342467192506905490901492808229601,0.9815606342467192506905490901492808229601],[0,-0.2304583159551347940655281210979888352115,0.2304583159551347940655281210979888352115,-0.4484927510364468528779128521276398678019,0.4484927510364468528779128521276398678019,-0.6423493394403402206439846069955156500716,0.6423493394403402206439846069955156500716,-0.8015780907333099127942064895828598903056,0.8015780907333099127942064895828598903056,-0.9175983992229779652065478365007195123904,0.9175983992229779652065478365007195123904,-0.9841830547185881494728294488071096110649,0.9841830547185881494728294488071096110649],[-0.1080549487073436620662446502198347476119,0.1080549487073436620662446502198347476119,-0.3191123689278897604356718241684754668342,0.3191123689278897604356718241684754668342,-0.5152486363581540919652907185511886623088,0.5152486363581540919652907185511886623088,-0.6872929048116854701480198030193341375384,0.6872929048116854701480198030193341375384,-0.8272013150697649931897947426503949610397,0.8272013150697649931897947426503949610397,-0.9284348836635735173363911393778742644770,0.9284348836635735173363911393778742644770,-0.9862838086968123388415972667040528016760,0.9862838086968123388415972667040528016760],[0,-0.2011940939974345223006283033945962078128,0.2011940939974345223006283033945962078128,-0.3941513470775633698972073709810454683627,0.3941513470775633698972073709810454683627,-0.5709721726085388475372267372539106412383,0.5709721726085388475372267372539106412383,-0.7244177313601700474161860546139380096308,0.7244177313601700474161860546139380096308,-0.8482065834104272162006483207742168513662,0.8482065834104272162006483207742168513662,-0.9372733924007059043077589477102094712439,0.9372733924007059043077589477102094712439,-0.9879925180204854284895657185866125811469,0.9879925180204854284895657185866125811469],[-0.0950125098376374401853193354249580631303,0.0950125098376374401853193354249580631303,-0.2816035507792589132304605014604961064860,0.2816035507792589132304605014604961064860,-0.4580167776572273863424194429835775735400,0.4580167776572273863424194429835775735400,-0.6178762444026437484466717640487910189918,0.6178762444026437484466717640487910189918,-0.7554044083550030338951011948474422683538,0.7554044083550030338951011948474422683538,-0.8656312023878317438804678977123931323873,0.8656312023878317438804678977123931323873,-0.9445750230732325760779884155346083450911,0.9445750230732325760779884155346083450911,-0.9894009349916499325961541734503326274262,0.9894009349916499325961541734503326274262],[0,-0.1784841814958478558506774936540655574754,0.1784841814958478558506774936540655574754,-0.3512317634538763152971855170953460050405,0.3512317634538763152971855170953460050405,-0.5126905370864769678862465686295518745829,0.5126905370864769678862465686295518745829,-0.6576711592166907658503022166430023351478,0.6576711592166907658503022166430023351478,-0.7815140038968014069252300555204760502239,0.7815140038968014069252300555204760502239,-0.8802391537269859021229556944881556926234,0.8802391537269859021229556944881556926234,-0.9506755217687677612227169578958030214433,0.9506755217687677612227169578958030214433,-0.9905754753144173356754340199406652765077,0.9905754753144173356754340199406652765077],[-0.0847750130417353012422618529357838117333,0.0847750130417353012422618529357838117333,-0.2518862256915055095889728548779112301628,0.2518862256915055095889728548779112301628,-0.4117511614628426460359317938330516370789,0.4117511614628426460359317938330516370789,-0.5597708310739475346078715485253291369276,0.5597708310739475346078715485253291369276,-0.6916870430603532078748910812888483894522,0.6916870430603532078748910812888483894522,-0.8037049589725231156824174550145907971032,0.8037049589725231156824174550145907971032,-0.8926024664975557392060605911271455154078,0.8926024664975557392060605911271455154078,-0.9558239495713977551811958929297763099728,0.9558239495713977551811958929297763099728,-0.9915651684209309467300160047061507702525,0.9915651684209309467300160047061507702525],[0,-0.1603586456402253758680961157407435495048,0.1603586456402253758680961157407435495048,-0.3165640999636298319901173288498449178922,0.3165640999636298319901173288498449178922,-0.4645707413759609457172671481041023679762,0.4645707413759609457172671481041023679762,-0.6005453046616810234696381649462392798683,0.6005453046616810234696381649462392798683,-0.7209661773352293786170958608237816296571,0.7209661773352293786170958608237816296571,-0.8227146565371428249789224867127139017745,0.8227146565371428249789224867127139017745,-0.9031559036148179016426609285323124878093,0.9031559036148179016426609285323124878093,-0.9602081521348300308527788406876515266150,0.9602081521348300308527788406876515266150,-0.9924068438435844031890176702532604935893,0.9924068438435844031890176702532604935893],[-0.0765265211334973337546404093988382110047,0.0765265211334973337546404093988382110047,-0.2277858511416450780804961953685746247430,0.2277858511416450780804961953685746247430,-0.3737060887154195606725481770249272373957,0.3737060887154195606725481770249272373957,-0.5108670019508270980043640509552509984254,0.5108670019508270980043640509552509984254,-0.6360536807265150254528366962262859367433,0.6360536807265150254528366962262859367433,-0.7463319064601507926143050703556415903107,0.7463319064601507926143050703556415903107,-0.8391169718222188233945290617015206853296,0.8391169718222188233945290617015206853296,-0.9122344282513259058677524412032981130491,0.9122344282513259058677524412032981130491,-0.9639719272779137912676661311972772219120,0.9639719272779137912676661311972772219120,-0.9931285991850949247861223884713202782226,0.9931285991850949247861223884713202782226],[0,-0.1455618541608950909370309823386863301163,0.1455618541608950909370309823386863301163,-0.2880213168024010966007925160646003199090,0.2880213168024010966007925160646003199090,-0.4243421202074387835736688885437880520964,0.4243421202074387835736688885437880520964,-0.5516188358872198070590187967243132866220,0.5516188358872198070590187967243132866220,-0.6671388041974123193059666699903391625970,0.6671388041974123193059666699903391625970,-0.7684399634756779086158778513062280348209,0.7684399634756779086158778513062280348209,-0.8533633645833172836472506385875676702761,0.8533633645833172836472506385875676702761,-0.9200993341504008287901871337149688941591,0.9200993341504008287901871337149688941591,-0.9672268385663062943166222149076951614246,0.9672268385663062943166222149076951614246,-0.9937521706203895002602420359379409291933,0.9937521706203895002602420359379409291933],[-0.0697392733197222212138417961186280818222,0.0697392733197222212138417961186280818222,-0.2078604266882212854788465339195457342156,0.2078604266882212854788465339195457342156,-0.3419358208920842251581474204273796195591,0.3419358208920842251581474204273796195591,-0.4693558379867570264063307109664063460953,0.4693558379867570264063307109664063460953,-0.5876404035069115929588769276386473488776,0.5876404035069115929588769276386473488776,-0.6944872631866827800506898357622567712673,0.6944872631866827800506898357622567712673,-0.7878168059792081620042779554083515213881,0.7878168059792081620042779554083515213881,-0.8658125777203001365364256370193787290847,0.8658125777203001365364256370193787290847,-0.9269567721871740005206929392590531966353,0.9269567721871740005206929392590531966353,-0.9700604978354287271239509867652687108059,0.9700604978354287271239509867652687108059,-0.9942945854823992920730314211612989803930,0.9942945854823992920730314211612989803930],[0,-0.1332568242984661109317426822417661370104,0.1332568242984661109317426822417661370104,-0.2641356809703449305338695382833096029790,0.2641356809703449305338695382833096029790,-0.3903010380302908314214888728806054585780,0.3903010380302908314214888728806054585780,-0.5095014778460075496897930478668464305448,0.5095014778460075496897930478668464305448,-0.6196098757636461563850973116495956533871,0.6196098757636461563850973116495956533871,-0.7186613631319501944616244837486188483299,0.7186613631319501944616244837486188483299,-0.8048884016188398921511184069967785579414,0.8048884016188398921511184069967785579414,-0.8767523582704416673781568859341456716389,0.8767523582704416673781568859341456716389,-0.9329710868260161023491969890384229782357,0.9329710868260161023491969890384229782357,-0.9725424712181152319560240768207773751816,0.9725424712181152319560240768207773751816,-0.9947693349975521235239257154455743605736,0.9947693349975521235239257154455743605736],[-0.0640568928626056260850430826247450385909,0.0640568928626056260850430826247450385909,-0.1911188674736163091586398207570696318404,0.1911188674736163091586398207570696318404,-0.3150426796961633743867932913198102407864,0.3150426796961633743867932913198102407864,-0.4337935076260451384870842319133497124524,0.4337935076260451384870842319133497124524,-0.5454214713888395356583756172183723700107,0.5454214713888395356583756172183723700107,-0.6480936519369755692524957869107476266696,0.6480936519369755692524957869107476266696,-0.7401241915785543642438281030999784255232,0.7401241915785543642438281030999784255232,-0.8200019859739029219539498726697452080761,0.8200019859739029219539498726697452080761,-0.8864155270044010342131543419821967550873,0.8864155270044010342131543419821967550873,-0.9382745520027327585236490017087214496548,0.9382745520027327585236490017087214496548,-0.9747285559713094981983919930081690617411,0.9747285559713094981983919930081690617411,-0.9951872199970213601799974097007368118745,0.9951872199970213601799974097007368118745]];
verb_eval_Analyze.Cvalues = [[],[],[1.0,1.0],[0.8888888888888888888888888888888888888888,0.5555555555555555555555555555555555555555,0.5555555555555555555555555555555555555555],[0.6521451548625461426269360507780005927646,0.6521451548625461426269360507780005927646,0.3478548451374538573730639492219994072353,0.3478548451374538573730639492219994072353],[0.5688888888888888888888888888888888888888,0.4786286704993664680412915148356381929122,0.4786286704993664680412915148356381929122,0.2369268850561890875142640407199173626432,0.2369268850561890875142640407199173626432],[0.3607615730481386075698335138377161116615,0.3607615730481386075698335138377161116615,0.4679139345726910473898703439895509948116,0.4679139345726910473898703439895509948116,0.1713244923791703450402961421727328935268,0.1713244923791703450402961421727328935268],[0.4179591836734693877551020408163265306122,0.3818300505051189449503697754889751338783,0.3818300505051189449503697754889751338783,0.2797053914892766679014677714237795824869,0.2797053914892766679014677714237795824869,0.1294849661688696932706114326790820183285,0.1294849661688696932706114326790820183285],[0.3626837833783619829651504492771956121941,0.3626837833783619829651504492771956121941,0.3137066458778872873379622019866013132603,0.3137066458778872873379622019866013132603,0.2223810344533744705443559944262408844301,0.2223810344533744705443559944262408844301,0.1012285362903762591525313543099621901153,0.1012285362903762591525313543099621901153],[0.3302393550012597631645250692869740488788,0.1806481606948574040584720312429128095143,0.1806481606948574040584720312429128095143,0.0812743883615744119718921581105236506756,0.0812743883615744119718921581105236506756,0.3123470770400028400686304065844436655987,0.3123470770400028400686304065844436655987,0.2606106964029354623187428694186328497718,0.2606106964029354623187428694186328497718],[0.2955242247147528701738929946513383294210,0.2955242247147528701738929946513383294210,0.2692667193099963550912269215694693528597,0.2692667193099963550912269215694693528597,0.2190863625159820439955349342281631924587,0.2190863625159820439955349342281631924587,0.1494513491505805931457763396576973324025,0.1494513491505805931457763396576973324025,0.0666713443086881375935688098933317928578,0.0666713443086881375935688098933317928578],[0.2729250867779006307144835283363421891560,0.2628045445102466621806888698905091953727,0.2628045445102466621806888698905091953727,0.2331937645919904799185237048431751394317,0.2331937645919904799185237048431751394317,0.1862902109277342514260976414316558916912,0.1862902109277342514260976414316558916912,0.1255803694649046246346942992239401001976,0.1255803694649046246346942992239401001976,0.0556685671161736664827537204425485787285,0.0556685671161736664827537204425485787285],[0.2491470458134027850005624360429512108304,0.2491470458134027850005624360429512108304,0.2334925365383548087608498989248780562594,0.2334925365383548087608498989248780562594,0.2031674267230659217490644558097983765065,0.2031674267230659217490644558097983765065,0.1600783285433462263346525295433590718720,0.1600783285433462263346525295433590718720,0.1069393259953184309602547181939962242145,0.1069393259953184309602547181939962242145,0.0471753363865118271946159614850170603170,0.0471753363865118271946159614850170603170],[0.2325515532308739101945895152688359481566,0.2262831802628972384120901860397766184347,0.2262831802628972384120901860397766184347,0.2078160475368885023125232193060527633865,0.2078160475368885023125232193060527633865,0.1781459807619457382800466919960979955128,0.1781459807619457382800466919960979955128,0.1388735102197872384636017768688714676218,0.1388735102197872384636017768688714676218,0.0921214998377284479144217759537971209236,0.0921214998377284479144217759537971209236,0.0404840047653158795200215922009860600419,0.0404840047653158795200215922009860600419],[0.2152638534631577901958764433162600352749,0.2152638534631577901958764433162600352749,0.2051984637212956039659240656612180557103,0.2051984637212956039659240656612180557103,0.1855383974779378137417165901251570362489,0.1855383974779378137417165901251570362489,0.1572031671581935345696019386238421566056,0.1572031671581935345696019386238421566056,0.1215185706879031846894148090724766259566,0.1215185706879031846894148090724766259566,0.0801580871597602098056332770628543095836,0.0801580871597602098056332770628543095836,0.0351194603317518630318328761381917806197,0.0351194603317518630318328761381917806197],[0.2025782419255612728806201999675193148386,0.1984314853271115764561183264438393248186,0.1984314853271115764561183264438393248186,0.1861610000155622110268005618664228245062,0.1861610000155622110268005618664228245062,0.1662692058169939335532008604812088111309,0.1662692058169939335532008604812088111309,0.1395706779261543144478047945110283225208,0.1395706779261543144478047945110283225208,0.1071592204671719350118695466858693034155,0.1071592204671719350118695466858693034155,0.0703660474881081247092674164506673384667,0.0703660474881081247092674164506673384667,0.0307532419961172683546283935772044177217,0.0307532419961172683546283935772044177217],[0.1894506104550684962853967232082831051469,0.1894506104550684962853967232082831051469,0.1826034150449235888667636679692199393835,0.1826034150449235888667636679692199393835,0.1691565193950025381893120790303599622116,0.1691565193950025381893120790303599622116,0.1495959888165767320815017305474785489704,0.1495959888165767320815017305474785489704,0.1246289712555338720524762821920164201448,0.1246289712555338720524762821920164201448,0.0951585116824927848099251076022462263552,0.0951585116824927848099251076022462263552,0.0622535239386478928628438369943776942749,0.0622535239386478928628438369943776942749,0.0271524594117540948517805724560181035122,0.0271524594117540948517805724560181035122],[0.1794464703562065254582656442618856214487,0.1765627053669926463252709901131972391509,0.1765627053669926463252709901131972391509,0.1680041021564500445099706637883231550211,0.1680041021564500445099706637883231550211,0.1540457610768102880814315948019586119404,0.1540457610768102880814315948019586119404,0.1351363684685254732863199817023501973721,0.1351363684685254732863199817023501973721,0.1118838471934039710947883856263559267358,0.1118838471934039710947883856263559267358,0.0850361483171791808835353701910620738504,0.0850361483171791808835353701910620738504,0.0554595293739872011294401653582446605128,0.0554595293739872011294401653582446605128,0.0241483028685479319601100262875653246916,0.0241483028685479319601100262875653246916],[0.1691423829631435918406564701349866103341,0.1691423829631435918406564701349866103341,0.1642764837458327229860537764659275904123,0.1642764837458327229860537764659275904123,0.1546846751262652449254180038363747721932,0.1546846751262652449254180038363747721932,0.1406429146706506512047313037519472280955,0.1406429146706506512047313037519472280955,0.1225552067114784601845191268002015552281,0.1225552067114784601845191268002015552281,0.1009420441062871655628139849248346070628,0.1009420441062871655628139849248346070628,0.0764257302548890565291296776166365256053,0.0764257302548890565291296776166365256053,0.0497145488949697964533349462026386416808,0.0497145488949697964533349462026386416808,0.0216160135264833103133427102664524693876,0.0216160135264833103133427102664524693876],[0.1610544498487836959791636253209167350399,0.1589688433939543476499564394650472016787,0.1589688433939543476499564394650472016787,0.1527660420658596667788554008976629984610,0.1527660420658596667788554008976629984610,0.1426067021736066117757461094419029724756,0.1426067021736066117757461094419029724756,0.1287539625393362276755157848568771170558,0.1287539625393362276755157848568771170558,0.1115666455473339947160239016817659974813,0.1115666455473339947160239016817659974813,0.0914900216224499994644620941238396526609,0.0914900216224499994644620941238396526609,0.0690445427376412265807082580060130449618,0.0690445427376412265807082580060130449618,0.0448142267656996003328381574019942119517,0.0448142267656996003328381574019942119517,0.0194617882297264770363120414644384357529,0.0194617882297264770363120414644384357529],[0.1527533871307258506980843319550975934919,0.1527533871307258506980843319550975934919,0.1491729864726037467878287370019694366926,0.1491729864726037467878287370019694366926,0.1420961093183820513292983250671649330345,0.1420961093183820513292983250671649330345,0.1316886384491766268984944997481631349161,0.1316886384491766268984944997481631349161,0.1181945319615184173123773777113822870050,0.1181945319615184173123773777113822870050,0.1019301198172404350367501354803498761666,0.1019301198172404350367501354803498761666,0.0832767415767047487247581432220462061001,0.0832767415767047487247581432220462061001,0.0626720483341090635695065351870416063516,0.0626720483341090635695065351870416063516,0.0406014298003869413310399522749321098790,0.0406014298003869413310399522749321098790,0.0176140071391521183118619623518528163621,0.0176140071391521183118619623518528163621],[0.1460811336496904271919851476833711882448,0.1445244039899700590638271665537525436099,0.1445244039899700590638271665537525436099,0.1398873947910731547221334238675831108927,0.1398873947910731547221334238675831108927,0.1322689386333374617810525744967756043290,0.1322689386333374617810525744967756043290,0.1218314160537285341953671771257335983563,0.1218314160537285341953671771257335983563,0.1087972991671483776634745780701056420336,0.1087972991671483776634745780701056420336,0.0934444234560338615532897411139320884835,0.0934444234560338615532897411139320884835,0.0761001136283793020170516533001831792261,0.0761001136283793020170516533001831792261,0.0571344254268572082836358264724479574912,0.0571344254268572082836358264724479574912,0.0369537897708524937999506682993296661889,0.0369537897708524937999506682993296661889,0.0160172282577743333242246168584710152658,0.0160172282577743333242246168584710152658],[0.1392518728556319933754102483418099578739,0.1392518728556319933754102483418099578739,0.1365414983460151713525738312315173965863,0.1365414983460151713525738312315173965863,0.1311735047870623707329649925303074458757,0.1311735047870623707329649925303074458757,0.1232523768105124242855609861548144719594,0.1232523768105124242855609861548144719594,0.1129322960805392183934006074217843191142,0.1129322960805392183934006074217843191142,0.1004141444428809649320788378305362823508,0.1004141444428809649320788378305362823508,0.0859416062170677274144436813727028661891,0.0859416062170677274144436813727028661891,0.0697964684245204880949614189302176573987,0.0697964684245204880949614189302176573987,0.0522933351526832859403120512732112561121,0.0522933351526832859403120512732112561121,0.0337749015848141547933022468659129013491,0.0337749015848141547933022468659129013491,0.0146279952982722006849910980471854451902,0.0146279952982722006849910980471854451902],[0.1336545721861061753514571105458443385831,0.1324620394046966173716424647033169258050,0.1324620394046966173716424647033169258050,0.1289057221880821499785953393997936532597,0.1289057221880821499785953393997936532597,0.1230490843067295304675784006720096548158,0.1230490843067295304675784006720096548158,0.1149966402224113649416435129339613014914,0.1149966402224113649416435129339613014914,0.1048920914645414100740861850147438548584,0.1048920914645414100740861850147438548584,0.0929157660600351474770186173697646486034,0.0929157660600351474770186173697646486034,0.0792814117767189549228925247420432269137,0.0792814117767189549228925247420432269137,0.0642324214085258521271696151589109980391,0.0642324214085258521271696151589109980391,0.0480376717310846685716410716320339965612,0.0480376717310846685716410716320339965612,0.0309880058569794443106942196418845053837,0.0309880058569794443106942196418845053837,0.0134118594871417720813094934586150649766,0.0134118594871417720813094934586150649766],[0.1279381953467521569740561652246953718517,0.1279381953467521569740561652246953718517,0.1258374563468282961213753825111836887264,0.1258374563468282961213753825111836887264,0.1216704729278033912044631534762624256070,0.1216704729278033912044631534762624256070,0.1155056680537256013533444839067835598622,0.1155056680537256013533444839067835598622,0.1074442701159656347825773424466062227946,0.1074442701159656347825773424466062227946,0.0976186521041138882698806644642471544279,0.0976186521041138882698806644642471544279,0.0861901615319532759171852029837426671850,0.0861901615319532759171852029837426671850,0.0733464814110803057340336152531165181193,0.0733464814110803057340336152531165181193,0.0592985849154367807463677585001085845412,0.0592985849154367807463677585001085845412,0.0442774388174198061686027482113382288593,0.0442774388174198061686027482113382288593,0.0285313886289336631813078159518782864491,0.0285313886289336631813078159518782864491,0.0123412297999871995468056670700372915759,0.0123412297999871995468056670700372915759]];
verb_Verb.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
