<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\core;

use \php\_Boot\HxAnon;
use \php\Boot;

class Trig {
	/**
	 * @param \Array_hx $pt
	 * @param \Array_hx $o
	 * @param \Array_hx $r
	 * 
	 * @return float
	 */
	public static function distToRay ($pt, $o, $r) {
		#src/verb/core/Trig.hx:55: characters 9-45
		$d = Trig::rayClosestPoint($pt, $o, $r);
		#src/verb/core/Trig.hx:56: characters 9-36
		$dif = Vec::sub($d, $pt);
		#src/verb/core/Trig.hx:58: characters 9-31
		return Vec::norm($dif);
	}

	/**
	 * @param \Array_hx $a
	 * @param \Array_hx $b
	 * @param \Array_hx $c
	 * 
	 * @return float
	 */
	public static function distToSegment ($a, $b, $c) {
		#src/verb/core/Trig.hx:18: characters 9-60
		$res = Trig::segmentClosestPoint($b, $a, $c, 0.0, 1.0);
		#src/verb/core/Trig.hx:19: characters 9-37
		return Vec::dist($b, $res->pt);
	}

	/**
	 * @param \Array_hx $pt
	 * @param Plane $p
	 * @param float $tol
	 * 
	 * @return bool
	 */
	public static function isPointInPlane ($pt, $p, $tol) {
		#src/verb/core/Trig.hx:14: characters 9-68
		return \abs(Vec::dot(Vec::sub($pt, $p->origin), $p->normal)) < $tol;
	}

	/**
	 * @param \Array_hx $pt
	 * @param \Array_hx $o
	 * @param \Array_hx $r
	 * 
	 * @return \Array_hx
	 */
	public static function rayClosestPoint ($pt, $o, $r) {
		#src/verb/core/Trig.hx:35: lines 35-37
		$o2pt = Vec::sub($pt, $o);
		$do2ptr = Vec::dot($o2pt, $r);
		$proj = Vec::add($o, Vec::mul($do2ptr, $r));
		#src/verb/core/Trig.hx:39: characters 9-20
		return $proj;
	}

	/**
	 * @param \Array_hx $pt
	 * @param \Array_hx $segpt0
	 * @param \Array_hx $segpt1
	 * @param float $u0
	 * @param float $u1
	 * 
	 * @return object
	 */
	public static function segmentClosestPoint ($pt, $segpt0, $segpt1, $u0, $u1) {
		#src/verb/core/Trig.hx:112: lines 112-113
		$dif = Vec::sub($segpt1, $segpt0);
		$l = Vec::norm($dif);
		#src/verb/core/Trig.hx:115: lines 115-117
		if ($l < Constants::$EPSILON) {
			#src/verb/core/Trig.hx:116: characters 13-42
			return new HxAnon([
				"u" => $u0,
				"pt" => $segpt0,
			]);
		}
		#src/verb/core/Trig.hx:119: lines 119-122
		$o = $segpt0;
		$r = Vec::mul(1 / $l, $dif);
		$o2pt = Vec::sub($pt, $o);
		$do2ptr = Vec::dot($o2pt, $r);
		#src/verb/core/Trig.hx:124: lines 124-128
		if ($do2ptr < 0) {
			#src/verb/core/Trig.hx:125: characters 13-43
			return new HxAnon([
				"u" => $u0,
				"pt" => $segpt0,
			]);
		} else if ($do2ptr > $l) {
			#src/verb/core/Trig.hx:127: characters 13-43
			return new HxAnon([
				"u" => $u1,
				"pt" => $segpt1,
			]);
		}
		#src/verb/core/Trig.hx:130: characters 9-91
		return new HxAnon([
			"u" => $u0 + ($u1 - $u0) * $do2ptr / $l,
			"pt" => Vec::add($o, Vec::mul($do2ptr, $r)),
		]);
	}

	/**
	 * @param \Array_hx $p1
	 * @param \Array_hx $p2
	 * @param \Array_hx $p3
	 * @param float $tol
	 * 
	 * @return bool
	 */
	public static function threePointsAreFlat ($p1, $p2, $p3, $tol) {
		#src/verb/core/Trig.hx:87: lines 87-90
		$p2mp1 = Vec::sub($p2, $p1);
		$p3mp1 = Vec::sub($p3, $p1);
		$norm = Vec::cross($p2mp1, $p3mp1);
		$area = Vec::dot($norm, $norm);
		#src/verb/core/Trig.hx:92: characters 9-26
		return $area < $tol;
	}
}

Boot::registerClass(Trig::class, 'verb.core.Trig');
