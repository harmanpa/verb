<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\geom;

use \php\Boot;
use \verb\eval_hx\Intersect as EvalIntersect;

class Intersect {
	/**
	 * @param ICurve $curve
	 * @param ISurface $surface
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function curveAndSurface ($curve, $surface, $tol = 1e-3) {
		#src/verb/geom/Intersect.hx:46: characters 9-93
		if ($tol === null) {
			$tol = 1e-3;
		}
		return EvalIntersect::curveAndSurface($curve->asNurbs(), $surface->asNurbs(), $tol);
	}

	/**
	 * @param ICurve $first
	 * @param ICurve $second
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function curves ($first, $second, $tol = 1e-3) {
		#src/verb/geom/Intersect.hx:29: characters 9-84
		if ($tol === null) {
			$tol = 1e-3;
		}
		return EvalIntersect::curves($first->asNurbs(), $second->asNurbs(), $tol);
	}

	/**
	 * @param ISurface $first
	 * @param ISurface $second
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function surfaces ($first, $second, $tol = 1e-3) {
		#src/verb/geom/Intersect.hx:61: lines 61-62
		if ($tol === null) {
			$tol = 1e-3;
		}
		$_this = EvalIntersect::surfaces($first->asNurbs(), $second->asNurbs(), $tol);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = new NurbsCurve($item);
		}
		return \Array_hx::wrap($result);
	}
}

Boot::registerClass(Intersect::class, 'verb.geom.Intersect');
