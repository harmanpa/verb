<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\geom;

use \verb\core\NurbsSurfaceData;
use \php\Boot;
use \verb\eval_hx\Tess;
use \verb\eval_hx\Divide;
use \verb\eval_hx\Analyze;
use \verb\eval_hx\Check;
use \verb\eval_hx\Eval_hx;
use \verb\eval_hx\Modify;
use \verb\eval_hx\AdaptiveRefinementOptions;
use \verb\core\SerializableBase;
use \verb\core\Interval;
use \verb\core\MeshData;
use \verb\eval_hx\Make;
use \verb\core\ArrayExtensions;

class NurbsSurface extends SerializableBase implements ISurface {
	/**
	 * @var NurbsSurfaceData
	 */
	public $_data;

	/**
	 * @param \Array_hx $point0
	 * @param \Array_hx $point1
	 * @param \Array_hx $point2
	 * @param \Array_hx $point3
	 * 
	 * @return NurbsSurface
	 */
	public static function byCorners ($point0, $point1, $point2, $point3) {
		#src/verb/geom/NurbsSurface.hx:80: characters 9-91
		return new NurbsSurface(Make::fourPointSurface($point0, $point1, $point2, $point3));
	}

	/**
	 * @param int $degreeU
	 * @param int $degreeV
	 * @param \Array_hx $knotsU
	 * @param \Array_hx $knotsV
	 * @param \Array_hx $controlPoints
	 * @param \Array_hx $weights
	 * 
	 * @return NurbsSurface
	 */
	public static function byKnotsControlPointsWeights ($degreeU, $degreeV, $knotsU, $knotsV, $controlPoints, $weights = null) {
		#src/verb/geom/NurbsSurface.hx:63: characters 9-135
		return new NurbsSurface(new NurbsSurfaceData($degreeU, $degreeV, $knotsU, $knotsV, Eval_hx::homogenize2d($controlPoints, $weights)));
	}

	/**
	 * @param \Array_hx $curves
	 * @param int $degreeV
	 * 
	 * @return NurbsSurface
	 */
	public static function byLoftingCurves ($curves, $degreeV = null) {
		#src/verb/geom/NurbsSurface.hx:94: characters 53-85
		$_g = new \Array_hx();
		#src/verb/geom/NurbsSurface.hx:94: characters 54-83
		$_g1 = 0;
		while ($_g1 < $curves->length) {
			#src/verb/geom/NurbsSurface.hx:94: characters 59-60
			$c = ($curves->arr[$_g1] ?? null);
			#src/verb/geom/NurbsSurface.hx:94: characters 54-83
			++$_g1;
			#src/verb/geom/NurbsSurface.hx:94: characters 72-83
			$x = $c->asNurbs();
			$_g->arr[$_g->length++] = $x;
		}
		#src/verb/geom/NurbsSurface.hx:94: characters 9-97
		return new NurbsSurface(Make::loftedSurface($_g, $degreeV));
	}

	/**
	 * @param NurbsSurfaceData $data
	 * 
	 * @return void
	 */
	public function __construct ($data) {
		#src/verb/geom/NurbsSurface.hx:38: characters 9-52
		$this->_data = Check::isValidNurbsSurfaceData($data);
	}

	/**
	 * @return NurbsSurfaceData
	 */
	public function asNurbs () {
		#src/verb/geom/NurbsSurface.hx:133: characters 38-47
		$tmp = $this->degreeU();
		#src/verb/geom/NurbsSurface.hx:133: characters 49-58
		$tmp1 = $this->degreeV();
		#src/verb/geom/NurbsSurface.hx:133: characters 60-68
		$tmp2 = $this->knotsU();
		#src/verb/geom/NurbsSurface.hx:133: characters 70-78
		$tmp3 = $this->knotsV();
		#src/verb/geom/NurbsSurface.hx:133: characters 9-128
		return new NurbsSurfaceData($tmp, $tmp1, $tmp2, $tmp3, Eval_hx::homogenize2d($this->controlPoints(), $this->weights()));
	}

	/**
	 * @param AdaptiveRefinementOptions $options
	 * 
	 * @return \Array_hx
	 */
	public function boundaries ($options = null) {
		#src/verb/geom/NurbsSurface.hx:296: characters 16-97
		$_this = Make::surfaceBoundaryCurves($this->_data);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = new NurbsCurve($item);
		}
		return \Array_hx::wrap($result);
	}

	/**
	 * @return NurbsSurface
	 */
	public function clone () {
		#src/verb/geom/NurbsSurface.hx:143: characters 9-45
		return new NurbsSurface($this->asNurbs());
	}

	/**
	 * @param \Array_hx $pt
	 * 
	 * @return \Array_hx
	 */
	public function closestParam ($pt) {
		#src/verb/geom/NurbsSurface.hx:227: characters 9-64
		return Analyze::rationalSurfaceClosestParam($this->_data, $pt);
	}

	/**
	 * @param \Array_hx $pt
	 * 
	 * @return \Array_hx
	 */
	public function closestPoint ($pt) {
		#src/verb/geom/NurbsSurface.hx:241: characters 9-64
		return Analyze::rationalSurfaceClosestPoint($this->_data, $pt);
	}

	/**
	 * @return \Array_hx
	 */
	public function controlPoints () {
		#src/verb/geom/NurbsSurface.hx:120: characters 61-108
		return Eval_hx::dehomogenize2d($this->_data->controlPoints);
	}

	/**
	 * @return int
	 */
	public function degreeU () {
		#src/verb/geom/NurbsSurface.hx:104: characters 39-59
		return $this->_data->degreeU;
	}

	/**
	 * @return int
	 */
	public function degreeV () {
		#src/verb/geom/NurbsSurface.hx:108: characters 39-59
		return $this->_data->degreeV;
	}

	/**
	 * @param float $u
	 * @param float $v
	 * @param int $numDerivs
	 * 
	 * @return \Array_hx
	 */
	public function derivatives ($u, $v, $numDerivs = 1) {
		#src/verb/geom/NurbsSurface.hx:213: characters 9-73
		if ($numDerivs === null) {
			$numDerivs = 1;
		}
		return Eval_hx::rationalSurfaceDerivatives($this->_data, $u, $v, $numDerivs);
	}

	/**
	 * @return Interval
	 */
	public function domainU () {
		#src/verb/geom/NurbsSurface.hx:153: characters 30-50
		$tmp = ArrayExtensions::first($this->_data->knotsU);
		#src/verb/geom/NurbsSurface.hx:153: characters 9-72
		return new Interval($tmp, ArrayExtensions::last($this->_data->knotsU));
	}

	/**
	 * @return Interval
	 */
	public function domainV () {
		#src/verb/geom/NurbsSurface.hx:163: characters 30-50
		$tmp = ArrayExtensions::first($this->_data->knotsV);
		#src/verb/geom/NurbsSurface.hx:163: characters 9-72
		return new Interval($tmp, ArrayExtensions::last($this->_data->knotsV));
	}

	/**
	 * @param float $u
	 * @param bool $useV
	 * 
	 * @return NurbsCurve
	 */
	public function isocurve ($u, $useV = false) {
		#src/verb/geom/NurbsSurface.hx:286: characters 9-72
		if ($useV === null) {
			$useV = false;
		}
		return new NurbsCurve(Make::surfaceIsocurve($this->_data, $u, $useV));
	}

	/**
	 * @return \Array_hx
	 */
	public function knotsU () {
		#src/verb/geom/NurbsSurface.hx:112: characters 41-69
		return $this->_data->knotsU->slice(0);
	}

	/**
	 * @return \Array_hx
	 */
	public function knotsV () {
		#src/verb/geom/NurbsSurface.hx:116: characters 41-69
		return $this->_data->knotsV->slice(0);
	}

	/**
	 * @param float $u
	 * @param float $v
	 * 
	 * @return \Array_hx
	 */
	public function normal ($u, $v) {
		#src/verb/geom/NurbsSurface.hx:193: characters 9-57
		return Eval_hx::rationalSurfaceNormal($this->_data, $u, $v);
	}

	/**
	 * @param float $u
	 * @param float $v
	 * 
	 * @return \Array_hx
	 */
	public function point ($u, $v) {
		#src/verb/geom/NurbsSurface.hx:178: characters 9-56
		return Eval_hx::rationalSurfacePoint($this->_data, $u, $v);
	}

	/**
	 * @param bool $useV
	 * 
	 * @return NurbsSurface
	 */
	public function reverse ($useV = false) {
		#src/verb/geom/NurbsSurface.hx:271: characters 9-72
		if ($useV === null) {
			$useV = false;
		}
		return new NurbsSurface(Modify::surfaceReverse($this->_data, $useV));
	}

	/**
	 * @param float $u
	 * @param bool $useV
	 * 
	 * @return \Array_hx
	 */
	public function split ($u, $useV = false) {
		#src/verb/geom/NurbsSurface.hx:256: lines 256-257
		if ($useV === null) {
			$useV = false;
		}
		$_this = Divide::surfaceSplit($this->_data, $u, $useV);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = new NurbsSurface($item);
		}
		return \Array_hx::wrap($result);
	}

	/**
	 * @param AdaptiveRefinementOptions $options
	 * 
	 * @return MeshData
	 */
	public function tessellate ($options = null) {
		#src/verb/geom/NurbsSurface.hx:311: characters 9-62
		return Tess::rationalSurfaceAdaptive($this->_data, $options);
	}

	/**
	 * @param \Array_hx $mat
	 * 
	 * @return NurbsSurface
	 */
	public function transform ($mat) {
		#src/verb/geom/NurbsSurface.hx:325: characters 9-81
		return new NurbsSurface(Modify::rationalSurfaceTransform($this->_data, $mat));
	}

	/**
	 * @return \Array_hx
	 */
	public function weights () {
		#src/verb/geom/NurbsSurface.hx:124: characters 48-89
		return Eval_hx::weight2d($this->_data->controlPoints);
	}
}

Boot::registerClass(NurbsSurface::class, 'verb.geom.NurbsSurface');
