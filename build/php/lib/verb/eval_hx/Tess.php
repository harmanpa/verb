<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\eval_hx;

use \verb\core\NurbsSurfaceData;
use \php\Boot;
use \verb\core\Trig;
use \verb\core\Vec;
use \verb\core\MeshData;
use \verb\core\SurfacePoint;
use \verb\core\NurbsCurveData;
use \verb\core\ArrayExtensions;

class Tess {
	/**
	 * @param NurbsSurfaceData $surface
	 * @param AdaptiveRefinementOptions $options
	 * 
	 * @return \Array_hx
	 */
	public static function divideRationalSurfaceAdaptive ($surface, $options = null) {
		#src/verb/eval/Tess.hx:241: characters 3-65
		if ($options === null) {
			#src/verb/eval/Tess.hx:241: characters 24-65
			$options = new AdaptiveRefinementOptions();
		}
		#src/verb/eval/Tess.hx:244: characters 13-79
		$options->minDivsU = ($options->minDivsU !== null ? $options->minDivsU : 1);
		#src/verb/eval/Tess.hx:245: characters 13-79
		$options->minDivsU = ($options->minDivsV !== null ? $options->minDivsV : 1);
		#src/verb/eval/Tess.hx:246: characters 13-76
		$options->refine = ($options->refine !== null ? $options->refine : true);
		#src/verb/eval/Tess.hx:249: characters 3-53
		$minU = ($surface->controlPoints->length - 1) * 2;
		#src/verb/eval/Tess.hx:250: characters 3-56
		$minV = (($surface->controlPoints->arr[0] ?? null)->length - 1) * 2;
		#src/verb/eval/Tess.hx:252: characters 3-84
		$divsU = $options->minDivsU = ($options->minDivsU > $minU ? $options->minDivsU : $minU);
		#src/verb/eval/Tess.hx:253: characters 3-84
		$divsV = $options->minDivsV = ($options->minDivsV > $minV ? $options->minDivsV : $minV);
		#src/verb/eval/Tess.hx:256: characters 3-36
		$umax = ArrayExtensions::last($surface->knotsU);
		#src/verb/eval/Tess.hx:257: characters 3-32
		$umin = ($surface->knotsU->arr[0] ?? null);
		#src/verb/eval/Tess.hx:258: characters 3-36
		$vmax = ArrayExtensions::last($surface->knotsV);
		#src/verb/eval/Tess.hx:259: characters 3-32
		$vmin = ($surface->knotsV->arr[0] ?? null);
		#src/verb/eval/Tess.hx:261: lines 261-262
		$du = ($umax - $umin) / $divsU;
		$dv = ($vmax - $vmin) / $divsV;
		#src/verb/eval/Tess.hx:264: characters 3-17
		$divs = new \Array_hx();
		#src/verb/eval/Tess.hx:265: characters 3-16
		$pts = new \Array_hx();
		#src/verb/eval/Tess.hx:268: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:268: characters 17-26
		$_g1 = $divsV + 1;
		#src/verb/eval/Tess.hx:268: lines 268-282
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:268: characters 13-26
			$i = $_g++;
			#src/verb/eval/Tess.hx:269: characters 4-19
			$ptrow = new \Array_hx();
			#src/verb/eval/Tess.hx:270: characters 14-18
			$_g2 = 0;
			#src/verb/eval/Tess.hx:270: characters 18-27
			$_g3 = $divsU + 1;
			#src/verb/eval/Tess.hx:270: lines 270-280
			while ($_g2 < $_g3) {
				#src/verb/eval/Tess.hx:270: characters 14-27
				$j = $_g2++;
				#src/verb/eval/Tess.hx:272: lines 272-273
				$u = $umin + $du * $j;
				$v = $vmin + $dv * $i;
				#src/verb/eval/Tess.hx:276: characters 5-66
				$ds = Eval_hx::rationalSurfaceDerivatives($surface, $u, $v, 1);
				#src/verb/eval/Tess.hx:278: characters 5-67
				$norm = Vec::normalized(Vec::cross((($ds->arr[0] ?? null)->arr[1] ?? null), (($ds->arr[1] ?? null)->arr[0] ?? null)));
				#src/verb/eval/Tess.hx:279: characters 35-43
				$ds1 = (($ds->arr[0] ?? null)->arr[0] ?? null);
				#src/verb/eval/Tess.hx:279: characters 5-84
				$x = new SurfacePoint($ds1, $norm, \Array_hx::wrap([
					$u,
					$v,
				]), -1, Vec::isZero($norm));
				$ptrow->arr[$ptrow->length++] = $x;
			}
			#src/verb/eval/Tess.hx:281: characters 4-21
			$pts->arr[$pts->length++] = $ptrow;
		}
		#src/verb/eval/Tess.hx:285: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:285: characters 17-22
		$_g1 = $divsV;
		#src/verb/eval/Tess.hx:285: lines 285-294
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:285: characters 13-22
			$i = $_g++;
			#src/verb/eval/Tess.hx:286: characters 14-18
			$_g2 = 0;
			#src/verb/eval/Tess.hx:286: characters 18-23
			$_g3 = $divsU;
			#src/verb/eval/Tess.hx:286: lines 286-293
			while ($_g2 < $_g3) {
				#src/verb/eval/Tess.hx:286: characters 14-23
				$j = $_g2++;
				#src/verb/eval/Tess.hx:287: lines 287-290
				$corners = \Array_hx::wrap([
					(($pts->arr[$divsV - $i - 1] ?? null)->arr[$j] ?? null),
					(($pts->arr[$divsV - $i - 1] ?? null)->arr[$j + 1] ?? null),
					(($pts->arr[$divsV - $i] ?? null)->arr[$j + 1] ?? null),
					(($pts->arr[$divsV - $i] ?? null)->arr[$j] ?? null),
				]);
				#src/verb/eval/Tess.hx:292: characters 5-64
				$x = new AdaptiveRefinementNode($surface, $corners);
				$divs->arr[$divs->length++] = $x;
			}
		}
		#src/verb/eval/Tess.hx:296: characters 3-35
		if (!$options->refine) {
			#src/verb/eval/Tess.hx:296: characters 24-35
			return $divs;
		}
		#src/verb/eval/Tess.hx:299: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:299: characters 17-22
		$_g1 = $divsV;
		#src/verb/eval/Tess.hx:299: lines 299-311
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:299: characters 13-22
			$i = $_g++;
			#src/verb/eval/Tess.hx:300: characters 14-18
			$_g2 = 0;
			#src/verb/eval/Tess.hx:300: characters 18-23
			$_g3 = $divsU;
			#src/verb/eval/Tess.hx:300: lines 300-310
			while ($_g2 < $_g3) {
				#src/verb/eval/Tess.hx:300: characters 14-23
				$j = $_g2++;
				#src/verb/eval/Tess.hx:302: lines 302-306
				$ci = $i * $divsU + $j;
				$n = Tess::north($ci, $i, $j, $divsU, $divsV, $divs);
				$e = Tess::east($ci, $i, $j, $divsU, $divsV, $divs);
				$s = Tess::south($ci, $i, $j, $divsU, $divsV, $divs);
				$w = Tess::west($ci, $i, $j, $divsU, $divsV, $divs);
				#src/verb/eval/Tess.hx:308: characters 5-40
				$divs[$ci]->neighbors = \Array_hx::wrap([
					$s,
					$e,
					$n,
					$w,
				]);
				#src/verb/eval/Tess.hx:309: characters 5-31
				($divs->arr[$ci] ?? null)->divide($options);
			}
		}
		#src/verb/eval/Tess.hx:313: characters 3-14
		return $divs;
	}

	/**
	 * @param int $index
	 * @param int $i
	 * @param int $j
	 * @param int $divsU
	 * @param int $divsV
	 * @param \Array_hx $divs
	 * 
	 * @return AdaptiveRefinementNode
	 */
	public static function east ($index, $i, $j, $divsU, $divsV, $divs) {
		#src/verb/eval/Tess.hx:327: characters 3-34
		if ($j === ($divsU - 1)) {
			#src/verb/eval/Tess.hx:327: characters 23-34
			return null;
		}
		#src/verb/eval/Tess.hx:328: characters 3-27
		return ($divs->arr[$index + 1] ?? null);
	}

	/**
	 * @param int $index
	 * @param int $i
	 * @param int $j
	 * @param int $divsU
	 * @param int $divsV
	 * @param \Array_hx $divs
	 * 
	 * @return AdaptiveRefinementNode
	 */
	public static function north ($index, $i, $j, $divsU, $divsV, $divs) {
		#src/verb/eval/Tess.hx:317: characters 3-26
		if ($i === 0) {
			#src/verb/eval/Tess.hx:317: characters 15-26
			return null;
		}
		#src/verb/eval/Tess.hx:318: characters 3-31
		return ($divs->arr[$index - $divsU] ?? null);
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param float $tol
	 * @param bool $includeU
	 * 
	 * @return \Array_hx
	 */
	public static function rationalCurveAdaptiveSample ($curve, $tol = 1e-6, $includeU = false) {
		#src/verb/eval/Tess.hx:93: lines 93-107
		if ($tol === null) {
			$tol = 1e-6;
		}
		if ($includeU === null) {
			$includeU = false;
		}
		#src/verb/eval/Tess.hx:96: lines 96-104
		if ($curve->degree === 1) {
			#src/verb/eval/Tess.hx:97: lines 97-103
			if (!$includeU) {
				#src/verb/eval/Tess.hx:98: characters 12-56
				$_this = $curve->controlPoints;
				$f = Boot::getStaticClosure(Eval_hx::class, 'dehomogenize');
				$result = [];
				$data = $_this->arr;
				$_g_current = 0;
				$_g_length = \count($data);
				$_g_data = $data;
				while ($_g_current < $_g_length) {
					$item = $_g_data[$_g_current++];
					$result[] = $f($item);
				}
				return \Array_hx::wrap($result);
			} else {
				#src/verb/eval/Tess.hx:101: lines 101-102
				$_g = new \Array_hx();
				#src/verb/eval/Tess.hx:101: characters 24-28
				$_g1 = 0;
				#src/verb/eval/Tess.hx:101: characters 28-54
				$_g2 = $curve->controlPoints->length;
				#src/verb/eval/Tess.hx:101: lines 101-102
				while ($_g1 < $_g2) {
					#src/verb/eval/Tess.hx:101: characters 24-54
					$i = $_g1++;
					#src/verb/eval/Tess.hx:102: characters 6-80
					$x = (\Array_hx::wrap([($curve->knots->arr[$i + 1] ?? null)]))->concat(Eval_hx::dehomogenize(($curve->controlPoints->arr[$i] ?? null)));
					$_g->arr[$_g->length++] = $x;
				}
				#src/verb/eval/Tess.hx:101: lines 101-102
				return $_g;
			}
		}
		#src/verb/eval/Tess.hx:106: characters 3-102
		return Tess::rationalCurveAdaptiveSampleRange($curve, ($curve->knots->arr[0] ?? null), ArrayExtensions::last($curve->knots), $tol, $includeU);
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param float $start
	 * @param float $end
	 * @param float $tol
	 * @param bool $includeU
	 * 
	 * @return \Array_hx
	 */
	public static function rationalCurveAdaptiveSampleRange ($curve, $start, $end, $tol, $includeU) {
		#src/verb/eval/Tess.hx:125: lines 125-129
		$p1 = Eval_hx::rationalCurvePoint($curve, $start);
		$p3 = Eval_hx::rationalCurvePoint($curve, $end);
		$t = 0.5 + 0.2 * (\mt_rand() / \mt_getrandmax());
		$mid = $start + ($end - $start) * $t;
		$p2 = Eval_hx::rationalCurvePoint($curve, $mid);
		#src/verb/eval/Tess.hx:132: characters 3-31
		$diff = Vec::sub($p1, $p3);
		#src/verb/eval/Tess.hx:133: characters 3-32
		$diff2 = Vec::sub($p1, $p2);
		#src/verb/eval/Tess.hx:136: lines 136-154
		if (((Vec::dot($diff, $diff) < $tol) && (Vec::dot($diff2, $diff2) > $tol)) || !Trig::threePointsAreFlat($p1, $p2, $p3, $tol)) {
			#src/verb/eval/Tess.hx:139: characters 4-48
			$exact_mid = $start + ($end - $start) * 0.5;
			#src/verb/eval/Tess.hx:142: lines 142-143
			$left_pts = Tess::rationalCurveAdaptiveSampleRange($curve, $start, $exact_mid, $tol, $includeU);
			$right_pts = Tess::rationalCurveAdaptiveSampleRange($curve, $exact_mid, $end, $tol, $includeU);
			#src/verb/eval/Tess.hx:146: characters 4-50
			return $left_pts->slice(0, -1)->concat($right_pts);
		} else if ($includeU) {
			#src/verb/eval/Tess.hx:150: characters 15-35
			$tmp = (\Array_hx::wrap([$start]))->concat($p1);
			#src/verb/eval/Tess.hx:150: characters 5-56
			return \Array_hx::wrap([
				$tmp,
				(\Array_hx::wrap([$end]))->concat($p3),
			]);
		} else {
			#src/verb/eval/Tess.hx:152: characters 5-23
			return \Array_hx::wrap([
				$p1,
				$p3,
			]);
		}
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param int $numSamples
	 * @param bool $includeU
	 * 
	 * @return \Array_hx
	 */
	public static function rationalCurveRegularSample ($curve, $numSamples, $includeU) {
		#src/verb/eval/Tess.hx:36: characters 3-107
		return Tess::rationalCurveRegularSampleRange($curve, ($curve->knots->arr[0] ?? null), ArrayExtensions::last($curve->knots), $numSamples, $includeU);
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param float $start
	 * @param float $end
	 * @param int $numSamples
	 * @param bool $includeU
	 * 
	 * @return \Array_hx
	 */
	public static function rationalCurveRegularSampleRange ($curve, $start, $end, $numSamples, $includeU) {
		#src/verb/eval/Tess.hx:56: lines 56-58
		if ($numSamples < 1) {
			#src/verb/eval/Tess.hx:57: characters 4-18
			$numSamples = 2;
		}
		#src/verb/eval/Tess.hx:60: characters 3-14
		$p = new \Array_hx();
		#src/verb/eval/Tess.hx:61: characters 3-55
		$span = ($end - $start) / ($numSamples - 1);
		#src/verb/eval/Tess.hx:62: characters 3-21
		$u = 0;
		#src/verb/eval/Tess.hx:64: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:64: characters 17-27
		$_g1 = $numSamples;
		#src/verb/eval/Tess.hx:64: lines 64-75
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:64: characters 13-27
			$i = $_g++;
			#src/verb/eval/Tess.hx:66: characters 4-24
			$u = $start + $span * $i;
			#src/verb/eval/Tess.hx:68: lines 68-73
			if ($includeU) {
				#src/verb/eval/Tess.hx:69: characters 8-31
				$uVec = \Array_hx::wrap([$u]);
				#src/verb/eval/Tess.hx:70: characters 5-63
				$x = $uVec->concat(Eval_hx::rationalCurvePoint($curve, $u));
				$p->arr[$p->length++] = $x;
			} else {
				#src/verb/eval/Tess.hx:72: characters 5-48
				$x1 = Eval_hx::rationalCurvePoint($curve, $u);
				$p->arr[$p->length++] = $x1;
			}
		}
		#src/verb/eval/Tess.hx:77: characters 3-11
		return $p;
	}

	/**
	 * @param NurbsSurfaceData $surface
	 * @param AdaptiveRefinementOptions $options
	 * 
	 * @return MeshData
	 */
	public static function rationalSurfaceAdaptive ($surface, $options = null) {
		#src/verb/eval/Tess.hx:347: characters 13-72
		if ($options === null) {
			#src/verb/eval/Tess.hx:347: characters 41-72
			$options = new AdaptiveRefinementOptions();
		}
		#src/verb/eval/Tess.hx:350: characters 3-68
		$arrTrees = Tess::divideRationalSurfaceAdaptive($surface, $options);
		#src/verb/eval/Tess.hx:353: characters 3-59
		return Tess::triangulateAdaptiveRefinementNodeTree($arrTrees);
	}

	/**
	 * @param NurbsSurfaceData $surface
	 * @param int $divs_u
	 * @param int $divs_v
	 * 
	 * @return MeshData
	 */
	public static function rationalSurfaceNaive ($surface, $divs_u, $divs_v) {
		#src/verb/eval/Tess.hx:171: characters 3-36
		if ($divs_u < 1) {
			#src/verb/eval/Tess.hx:171: characters 23-33
			$divs_u = 1;
		}
		#src/verb/eval/Tess.hx:172: characters 3-36
		if ($divs_v < 1) {
			#src/verb/eval/Tess.hx:172: characters 23-33
			$divs_v = 1;
		}
		#src/verb/eval/Tess.hx:174: lines 174-178
		$degreeU = $surface->degreeU;
		$degreeV = $surface->degreeV;
		$controlPoints = $surface->controlPoints;
		$knotsU = $surface->knotsU;
		$knotsV = $surface->knotsV;
		#src/verb/eval/Tess.hx:180: characters 3-42
		$u_span = ArrayExtensions::last($knotsU) - ($knotsU->arr[0] ?? null);
		#src/verb/eval/Tess.hx:181: characters 3-42
		$v_span = ArrayExtensions::last($knotsV) - ($knotsV->arr[0] ?? null);
		#src/verb/eval/Tess.hx:183: lines 183-184
		$span_u = $u_span / $divs_u;
		$span_v = $v_span / $divs_v;
		#src/verb/eval/Tess.hx:186: characters 3-33
		$points = new \Array_hx();
		#src/verb/eval/Tess.hx:187: characters 3-27
		$uvs = new \Array_hx();
		#src/verb/eval/Tess.hx:188: characters 3-35
		$normals = new \Array_hx();
		#src/verb/eval/Tess.hx:190: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:190: characters 17-25
		$_g1 = $divs_u + 1;
		#src/verb/eval/Tess.hx:190: lines 190-206
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:190: characters 13-25
			$i = $_g++;
			#src/verb/eval/Tess.hx:191: characters 14-18
			$_g2 = 0;
			#src/verb/eval/Tess.hx:191: characters 18-26
			$_g3 = $divs_v + 1;
			#src/verb/eval/Tess.hx:191: lines 191-205
			while ($_g2 < $_g3) {
				#src/verb/eval/Tess.hx:191: characters 14-26
				$j = $_g2++;
				#src/verb/eval/Tess.hx:193: lines 193-194
				$pt_u = $i * $span_u;
				$pt_v = $j * $span_v;
				#src/verb/eval/Tess.hx:196: characters 5-29
				$uvs->arr[$uvs->length++] = \Array_hx::wrap([
					$pt_u,
					$pt_v,
				]);
				#src/verb/eval/Tess.hx:198: characters 5-76
				$derivs = Eval_hx::rationalSurfaceDerivatives($surface, $pt_u, $pt_v, 1);
				#src/verb/eval/Tess.hx:199: characters 5-27
				$pt = (($derivs->arr[0] ?? null)->arr[0] ?? null);
				#src/verb/eval/Tess.hx:201: characters 5-22
				$points->arr[$points->length++] = $pt;
				#src/verb/eval/Tess.hx:203: characters 5-77
				$normal = Vec::normalized(Vec::cross((($derivs->arr[1] ?? null)->arr[0] ?? null), (($derivs->arr[0] ?? null)->arr[1] ?? null)));
				#src/verb/eval/Tess.hx:204: characters 5-27
				$normals->arr[$normals->length++] = $normal;
			}
		}
		#src/verb/eval/Tess.hx:208: characters 3-18
		$faces = new \Array_hx();
		#src/verb/eval/Tess.hx:210: characters 13-17
		$_g = 0;
		#src/verb/eval/Tess.hx:210: characters 17-23
		$_g1 = $divs_u;
		#src/verb/eval/Tess.hx:210: lines 210-222
		while ($_g < $_g1) {
			#src/verb/eval/Tess.hx:210: characters 13-23
			$i = $_g++;
			#src/verb/eval/Tess.hx:211: characters 14-18
			$_g2 = 0;
			#src/verb/eval/Tess.hx:211: characters 18-24
			$_g3 = $divs_v;
			#src/verb/eval/Tess.hx:211: lines 211-221
			while ($_g2 < $_g3) {
				#src/verb/eval/Tess.hx:211: characters 14-24
				$j = $_g2++;
				#src/verb/eval/Tess.hx:212: lines 212-217
				$a_i = $i * ($divs_v + 1) + $j;
				$b_i = ($i + 1) * ($divs_v + 1) + $j;
				$c_i = $b_i + 1;
				$d_i = $a_i + 1;
				$abc = \Array_hx::wrap([
					$a_i,
					$b_i,
					$c_i,
				]);
				$acd = \Array_hx::wrap([
					$a_i,
					$c_i,
					$d_i,
				]);
				#src/verb/eval/Tess.hx:219: characters 5-20
				$faces->arr[$faces->length++] = $abc;
				#src/verb/eval/Tess.hx:220: characters 5-20
				$faces->arr[$faces->length++] = $acd;
			}
		}
		#src/verb/eval/Tess.hx:224: characters 3-53
		return new MeshData($faces, $points, $normals, $uvs);
	}

	/**
	 * @param int $index
	 * @param int $i
	 * @param int $j
	 * @param int $divsU
	 * @param int $divsV
	 * @param \Array_hx $divs
	 * 
	 * @return AdaptiveRefinementNode
	 */
	public static function south ($index, $i, $j, $divsU, $divsV, $divs) {
		#src/verb/eval/Tess.hx:322: characters 3-34
		if ($i === ($divsV - 1)) {
			#src/verb/eval/Tess.hx:322: characters 23-34
			return null;
		}
		#src/verb/eval/Tess.hx:323: characters 3-31
		return ($divs->arr[$index + $divsU] ?? null);
	}

	/**
	 * @param \Array_hx $arrTree
	 * 
	 * @return MeshData
	 */
	public static function triangulateAdaptiveRefinementNodeTree ($arrTree) {
		#src/verb/eval/Tess.hx:339: characters 3-31
		$mesh = MeshData::empty();
		#src/verb/eval/Tess.hx:340: characters 3-44
		$_g = 0;
		while ($_g < $arrTree->length) {
			#src/verb/eval/Tess.hx:340: characters 8-9
			$x = ($arrTree->arr[$_g] ?? null);
			#src/verb/eval/Tess.hx:340: characters 3-44
			++$_g;
			#src/verb/eval/Tess.hx:340: characters 23-44
			$x->triangulate($mesh);
		}
		#src/verb/eval/Tess.hx:341: characters 3-14
		return $mesh;
	}

	/**
	 * @param int $index
	 * @param int $i
	 * @param int $j
	 * @param int $divsU
	 * @param int $divsV
	 * @param \Array_hx $divs
	 * 
	 * @return AdaptiveRefinementNode
	 */
	public static function west ($index, $i, $j, $divsU, $divsV, $divs) {
		#src/verb/eval/Tess.hx:332: characters 3-26
		if ($j === 0) {
			#src/verb/eval/Tess.hx:332: characters 15-26
			return null;
		}
		#src/verb/eval/Tess.hx:333: characters 3-27
		return ($divs->arr[$index - 1] ?? null);
	}
}

Boot::registerClass(Tess::class, 'verb.eval.Tess');
