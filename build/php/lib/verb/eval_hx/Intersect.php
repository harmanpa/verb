<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\eval_hx;

use \verb\core\PolylineMeshIntersection;
use \verb\core\KdPoint_verb_core_MeshIntersectionPoint;
use \php\_Boot\HxAnon;
use \verb\core\NurbsSurfaceData;
use \verb\core\Pair;
use \verb\core\KdTree_verb_core_MeshIntersectionPoint;
use \php\Boot;
use \verb\core\LazyCurveBoundingBoxTree;
use \haxe\Exception;
use \verb\core\LazyMeshBoundingBoxTree;
use \verb\core\Mesh;
use \verb\core\TriSegmentIntersection;
use \verb\core\SurfaceSurfaceIntersectionPoint;
use \verb\core\LazyPolylineBoundingBoxTree;
use \verb\core\MeshIntersectionPoint;
use \verb\core\Constants;
use \verb\core\CurveCurveIntersection;
use \verb\core\Minimizer;
use \verb\core\LazySurfaceBoundingBoxTree;
use \verb\core\MeshBoundingBoxTree;
use \verb\core\PolylineData;
use \verb\core\Interval;
use \verb\core\CurveSurfaceIntersection;
use \verb\core\Vec;
use \verb\core\Ray;
use \verb\core\MeshData;
use \verb\core\NurbsCurveData;
use \verb\core\ArrayExtensions;
use \verb\core\CurveTriPoint;

class Intersect {
	/**
	 * @param IBoundingBoxTree $ai
	 * @param IBoundingBoxTree $bi
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function boundingBoxTrees ($ai, $bi, $tol = 1e-9) {
		#src/verb/eval/Intersect.hx:578: lines 578-641
		if ($tol === null) {
			$tol = 1e-9;
		}
		#src/verb/eval/Intersect.hx:580: characters 9-25
		$atrees = new \Array_hx();
		#src/verb/eval/Intersect.hx:581: characters 9-25
		$btrees = new \Array_hx();
		#src/verb/eval/Intersect.hx:583: characters 9-24
		$atrees->arr[$atrees->length++] = $ai;
		#src/verb/eval/Intersect.hx:584: characters 9-24
		$btrees->arr[$btrees->length++] = $bi;
		#src/verb/eval/Intersect.hx:586: characters 9-26
		$results = new \Array_hx();
		#src/verb/eval/Intersect.hx:588: lines 588-638
		while ($atrees->length > 0) {
			#src/verb/eval/Intersect.hx:590: characters 21-33
			if ($atrees->length > 0) {
				$atrees->length--;
			}
			#src/verb/eval/Intersect.hx:590: characters 13-34
			$a = \array_pop($atrees->arr);
			#src/verb/eval/Intersect.hx:591: characters 21-33
			if ($btrees->length > 0) {
				$btrees->length--;
			}
			#src/verb/eval/Intersect.hx:591: characters 13-34
			$b = \array_pop($btrees->arr);
			#src/verb/eval/Intersect.hx:593: characters 13-49
			if ($a->empty() || $b->empty()) {
				#src/verb/eval/Intersect.hx:593: characters 41-49
				continue;
			}
			#src/verb/eval/Intersect.hx:594: characters 13-80
			if (!$a->boundingBox()->intersects($b->boundingBox(), $tol)) {
				#src/verb/eval/Intersect.hx:594: characters 72-80
				continue;
			}
			#src/verb/eval/Intersect.hx:596: characters 13-41
			$ai = $a->indivisible($tol);
			#src/verb/eval/Intersect.hx:597: characters 13-41
			$bi = $b->indivisible($tol);
			#src/verb/eval/Intersect.hx:599: lines 599-622
			if ($ai && $bi) {
				#src/verb/eval/Intersect.hx:600: characters 40-49
				$x = $a->yield();
				#src/verb/eval/Intersect.hx:600: characters 17-63
				$x1 = new Pair($x, $b->yield());
				$results->arr[$results->length++] = $x1;
				#src/verb/eval/Intersect.hx:601: characters 17-25
				continue;
			} else if ($ai && !$bi) {
				#src/verb/eval/Intersect.hx:603: characters 17-36
				$bs = $b->split();
				#src/verb/eval/Intersect.hx:605: characters 17-33
				$atrees->arr[$atrees->length++] = $a;
				#src/verb/eval/Intersect.hx:606: characters 17-40
				$btrees->arr[$btrees->length++] = $bs->item1;
				#src/verb/eval/Intersect.hx:608: characters 17-33
				$atrees->arr[$atrees->length++] = $a;
				#src/verb/eval/Intersect.hx:609: characters 17-40
				$btrees->arr[$btrees->length++] = $bs->item0;
				#src/verb/eval/Intersect.hx:611: characters 17-25
				continue;
			} else if (!$ai && $bi) {
				#src/verb/eval/Intersect.hx:613: characters 17-36
				$as = $a->split();
				#src/verb/eval/Intersect.hx:615: characters 17-40
				$atrees->arr[$atrees->length++] = $as->item1;
				#src/verb/eval/Intersect.hx:616: characters 17-33
				$btrees->arr[$btrees->length++] = $b;
				#src/verb/eval/Intersect.hx:618: characters 17-40
				$atrees->arr[$atrees->length++] = $as->item0;
				#src/verb/eval/Intersect.hx:619: characters 17-33
				$btrees->arr[$btrees->length++] = $b;
				#src/verb/eval/Intersect.hx:621: characters 17-25
				continue;
			}
			#src/verb/eval/Intersect.hx:624: characters 13-48
			$as1 = $a->split();
			$bs1 = $b->split();
			#src/verb/eval/Intersect.hx:626: characters 13-36
			$atrees->arr[$atrees->length++] = $as1->item1;
			#src/verb/eval/Intersect.hx:627: characters 13-36
			$btrees->arr[$btrees->length++] = $bs1->item1;
			#src/verb/eval/Intersect.hx:629: characters 13-36
			$atrees->arr[$atrees->length++] = $as1->item1;
			#src/verb/eval/Intersect.hx:630: characters 13-36
			$btrees->arr[$btrees->length++] = $bs1->item0;
			#src/verb/eval/Intersect.hx:632: characters 13-36
			$atrees->arr[$atrees->length++] = $as1->item0;
			#src/verb/eval/Intersect.hx:633: characters 13-36
			$btrees->arr[$btrees->length++] = $bs1->item1;
			#src/verb/eval/Intersect.hx:635: characters 13-36
			$atrees->arr[$atrees->length++] = $as1->item0;
			#src/verb/eval/Intersect.hx:636: characters 13-36
			$btrees->arr[$btrees->length++] = $bs1->item0;
		}
		#src/verb/eval/Intersect.hx:640: characters 9-23
		return $results;
	}

	/**
	 * @param Ray $ray
	 * @param MeshData $mesh
	 * @param int $faceIndex
	 * 
	 * @return Interval
	 */
	public static function clipRayInCoplanarTriangle ($ray, $mesh, $faceIndex) {
		#src/verb/eval/Intersect.hx:785: lines 785-791
		$tri = ($mesh->faces->arr[$faceIndex] ?? null);
		$o = \Array_hx::wrap([
			($mesh->points->arr[($tri->arr[0] ?? null)] ?? null),
			($mesh->points->arr[($tri->arr[1] ?? null)] ?? null),
			($mesh->points->arr[($tri->arr[2] ?? null)] ?? null),
		]);
		$uvs = \Array_hx::wrap([
			($mesh->uvs->arr[($tri->arr[0] ?? null)] ?? null),
			($mesh->uvs->arr[($tri->arr[1] ?? null)] ?? null),
			($mesh->uvs->arr[($tri->arr[2] ?? null)] ?? null),
		]);
		#src/verb/eval/Intersect.hx:788: characters 19-42
		$uvd = Vec::sub(($uvs->arr[1] ?? null), ($uvs->arr[0] ?? null));
		#src/verb/eval/Intersect.hx:788: characters 44-67
		$uvd1 = Vec::sub(($uvs->arr[2] ?? null), ($uvs->arr[1] ?? null));
		#src/verb/eval/Intersect.hx:785: lines 785-791
		$uvd2 = \Array_hx::wrap([
			$uvd,
			$uvd1,
			Vec::sub(($uvs->arr[0] ?? null), ($uvs->arr[2] ?? null)),
		]);
		#src/verb/eval/Intersect.hx:789: characters 17-38
		$s = Vec::sub(($o->arr[1] ?? null), ($o->arr[0] ?? null));
		#src/verb/eval/Intersect.hx:789: characters 40-61
		$s1 = Vec::sub(($o->arr[2] ?? null), ($o->arr[1] ?? null));
		#src/verb/eval/Intersect.hx:785: lines 785-791
		$s2 = \Array_hx::wrap([
			$s,
			$s1,
			Vec::sub(($o->arr[0] ?? null), ($o->arr[2] ?? null)),
		]);
		#src/verb/eval/Intersect.hx:790: characters 15-38
		$f = Boot::getStaticClosure(Vec::class, 'normalized');
		$result = [];
		$data = $s2->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = $f($item);
		}
		#src/verb/eval/Intersect.hx:785: lines 785-791
		$d = \Array_hx::wrap($result);
		#src/verb/eval/Intersect.hx:791: characters 15-32
		$f = Boot::getStaticClosure(Vec::class, 'norm');
		$result = [];
		$data = $s2->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = $f($item);
		}
		#src/verb/eval/Intersect.hx:785: lines 785-791
		$l = \Array_hx::wrap($result);
		#src/verb/eval/Intersect.hx:794: characters 9-41
		$minU = null;
		#src/verb/eval/Intersect.hx:795: characters 9-41
		$maxU = null;
		#src/verb/eval/Intersect.hx:798: characters 19-23
		$_g = 0;
		#src/verb/eval/Intersect.hx:798: lines 798-822
		while ($_g < 3) {
			#src/verb/eval/Intersect.hx:798: characters 19-24
			$i = $_g++;
			#src/verb/eval/Intersect.hx:799: characters 13-27
			$o0 = ($o->arr[$i] ?? null);
			#src/verb/eval/Intersect.hx:800: characters 13-27
			$d0 = ($d->arr[$i] ?? null);
			#src/verb/eval/Intersect.hx:802: characters 13-69
			$res = Intersect::rays($o0, $d0, $ray->origin, $ray->dir);
			#src/verb/eval/Intersect.hx:804: lines 804-806
			if ($res === null) {
				#src/verb/eval/Intersect.hx:805: characters 17-25
				continue;
			}
			#src/verb/eval/Intersect.hx:808: characters 13-31
			$useg = $res->u0;
			#src/verb/eval/Intersect.hx:809: characters 13-31
			$uray = $res->u1;
			#src/verb/eval/Intersect.hx:812: characters 13-87
			if (($useg < -Constants::$EPSILON) || ($useg > (($l->arr[$i] ?? null) + Constants::$EPSILON))) {
				#src/verb/eval/Intersect.hx:812: characters 79-87
				continue;
			}
			#src/verb/eval/Intersect.hx:815: lines 815-817
			if (($minU === null) || ($uray < $minU->u)) {
				#src/verb/eval/Intersect.hx:816: characters 49-87
				$minU1 = Vec::onRay($ray->origin, $ray->dir, $uray);
				#src/verb/eval/Intersect.hx:816: characters 17-21
				$minU = new CurveTriPoint($uray, $minU1, Vec::onRay(($uvs->arr[$i] ?? null), ($uvd2->arr[$i] ?? null), $useg / ($l->arr[$i] ?? null)));
			}
			#src/verb/eval/Intersect.hx:819: lines 819-821
			if (($maxU === null) || ($uray > $maxU->u)) {
				#src/verb/eval/Intersect.hx:820: characters 49-87
				$maxU1 = Vec::onRay($ray->origin, $ray->dir, $uray);
				#src/verb/eval/Intersect.hx:820: characters 17-21
				$maxU = new CurveTriPoint($uray, $maxU1, Vec::onRay(($uvs->arr[$i] ?? null), ($uvd2->arr[$i] ?? null), $useg / ($l->arr[$i] ?? null)));
			}
		}
		#src/verb/eval/Intersect.hx:824: lines 824-826
		if (($maxU === null) || ($minU === null)) {
			#src/verb/eval/Intersect.hx:825: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:829: characters 9-55
		return new Interval($minU, $maxU);
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param NurbsSurfaceData $surface
	 * @param float $tol
	 * @param IBoundingBoxTree $crvBbTree
	 * @param IBoundingBoxTree $srfBbTree
	 * 
	 * @return \Array_hx
	 */
	public static function curveAndSurface ($curve, $surface, $tol = 1e-3, $crvBbTree = null, $srfBbTree = null) {
		#src/verb/eval/Intersect.hx:421: lines 421-454
		if ($tol === null) {
			$tol = 1e-3;
		}
		#src/verb/eval/Intersect.hx:423: characters 21-90
		if ($crvBbTree === null) {
			#src/verb/eval/Intersect.hx:423: characters 53-90
			$crvBbTree = new LazyCurveBoundingBoxTree($curve);
		}
		#src/verb/eval/Intersect.hx:424: characters 21-94
		if ($srfBbTree === null) {
			#src/verb/eval/Intersect.hx:424: characters 53-94
			$srfBbTree = new LazySurfaceBoundingBoxTree($surface);
		}
		#src/verb/eval/Intersect.hx:426: characters 9-76
		$ints = Intersect::boundingBoxTrees($crvBbTree, $srfBbTree, $tol);
		#src/verb/eval/Intersect.hx:428: lines 428-449
		$result = [];
		$data = $ints->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			#src/verb/eval/Intersect.hx:430: characters 13-38
			$crvSeg = $item->item0;
			#src/verb/eval/Intersect.hx:431: characters 13-39
			$srfPart = $item->item1;
			#src/verb/eval/Intersect.hx:434: characters 13-44
			$min = ArrayExtensions::first($crvSeg->knots);
			#src/verb/eval/Intersect.hx:435: characters 13-43
			$max = ArrayExtensions::last($crvSeg->knots);
			#src/verb/eval/Intersect.hx:437: characters 13-39
			$u = ($min + $max) / 2.0;
			#src/verb/eval/Intersect.hx:440: characters 13-47
			$minu = ArrayExtensions::first($srfPart->knotsU);
			#src/verb/eval/Intersect.hx:441: characters 13-46
			$maxu = ArrayExtensions::last($srfPart->knotsU);
			#src/verb/eval/Intersect.hx:443: characters 13-47
			$minv = ArrayExtensions::first($srfPart->knotsV);
			#src/verb/eval/Intersect.hx:444: characters 13-46
			$maxv = ArrayExtensions::last($srfPart->knotsV);
			#src/verb/eval/Intersect.hx:446: characters 13-67
			$uv = \Array_hx::wrap([
				($minu + $maxu) / 2.0,
				($minv + $maxv) / 2.0,
			]);
			#src/verb/eval/Intersect.hx:428: lines 428-449
			$result[] = Intersect::curveAndSurfaceWithEstimate($crvSeg, $srfPart, (\Array_hx::wrap([$u]))->concat($uv), $tol);
		}
		#src/verb/eval/Intersect.hx:428: lines 428-451
		$_this = \Array_hx::wrap($result);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if (Vec::distSquared($item->curvePoint, $item->surfacePoint) < ($tol * $tol)) {
				$result[] = $item;
			}
		}
		#src/verb/eval/Intersect.hx:428: lines 428-453
		return ArrayExtensions::unique(\Array_hx::wrap($result), function ($a, $b) use (&$tol) {
			#src/verb/eval/Intersect.hx:452: characters 13-51
			return \abs($a->u - $b->u) < (0.5 * $tol);
		});
	}

	/**
	 * @param NurbsCurveData $curve
	 * @param NurbsSurfaceData $surface
	 * @param \Array_hx $start_params
	 * @param float $tol
	 * 
	 * @return CurveSurfaceIntersection
	 */
	public static function curveAndSurfaceWithEstimate ($curve, $surface, $start_params, $tol = 1e-3) {
		#src/verb/eval/Intersect.hx:472: lines 472-522
		if ($tol === null) {
			$tol = 1e-3;
		}
		#src/verb/eval/Intersect.hx:474: lines 474-480
		$objective = function ($x) use (&$surface, &$curve) {
			#src/verb/eval/Intersect.hx:475: lines 475-477
			$p1 = Eval_hx::rationalCurvePoint($curve, ($x->arr[0] ?? null));
			$p2 = Eval_hx::rationalSurfacePoint($surface, ($x->arr[1] ?? null), ($x->arr[2] ?? null));
			$p1_p2 = Vec::sub($p1, $p2);
			#src/verb/eval/Intersect.hx:479: characters 13-41
			return Vec::dot($p1_p2, $p1_p2);
		};
		#src/verb/eval/Intersect.hx:501: lines 501-515
		$grad = function ($x) use (&$surface, &$curve) {
			#src/verb/eval/Intersect.hx:503: lines 503-504
			$dc = Eval_hx::rationalCurveDerivatives($curve, ($x->arr[0] ?? null), 1);
			$ds = Eval_hx::rationalSurfaceDerivatives($surface, ($x->arr[1] ?? null), ($x->arr[2] ?? null), 1);
			#src/verb/eval/Intersect.hx:506: characters 13-46
			$r = Vec::sub((($ds->arr[0] ?? null)->arr[0] ?? null), ($dc->arr[0] ?? null));
			#src/verb/eval/Intersect.hx:508: characters 13-45
			$drdt = Vec::mul(-1.0, ($dc->arr[1] ?? null));
			#src/verb/eval/Intersect.hx:509: characters 13-33
			$drdu = (($ds->arr[1] ?? null)->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:510: characters 13-33
			$drdv = (($ds->arr[0] ?? null)->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:512: characters 25-49
			$grad = 2.0 * Vec::dot($drdt, $r);
			#src/verb/eval/Intersect.hx:513: characters 25-49
			$grad1 = 2.0 * Vec::dot($drdu, $r);
			#src/verb/eval/Intersect.hx:512: lines 512-514
			return \Array_hx::wrap([
				$grad,
				$grad1,
				2.0 * Vec::dot($drdv, $r),
			]);
		};
		#src/verb/eval/Intersect.hx:517: characters 9-82
		$sol_obj = Minimizer::uncmin($objective, $start_params, $tol * $tol, $grad);
		#src/verb/eval/Intersect.hx:518: characters 9-46
		$finalSolution = $sol_obj->solution;
		#src/verb/eval/Intersect.hx:520: characters 46-62
		$finalSolution1 = ($finalSolution->arr[0] ?? null);
		#src/verb/eval/Intersect.hx:520: characters 66-82
		$finalSolution2 = ($finalSolution->arr[1] ?? null);
		#src/verb/eval/Intersect.hx:520: characters 84-100
		$finalSolution3 = ($finalSolution->arr[2] ?? null);
		#src/verb/eval/Intersect.hx:521: characters 13-63
		$tmp = Eval_hx::rationalCurvePoint($curve, ($finalSolution->arr[0] ?? null));
		#src/verb/eval/Intersect.hx:520: lines 520-521
		return new CurveSurfaceIntersection($finalSolution1, \Array_hx::wrap([
			$finalSolution2,
			$finalSolution3,
		]), $tmp, Eval_hx::rationalSurfacePoint($surface, ($finalSolution->arr[1] ?? null), ($finalSolution->arr[2] ?? null)));
	}

	/**
	 * @param NurbsCurveData $curve1
	 * @param NurbsCurveData $curve2
	 * @param float $tolerance
	 * 
	 * @return \Array_hx
	 */
	public static function curves ($curve1, $curve2, $tolerance) {
		#src/verb/eval/Intersect.hx:657: lines 657-659
		$ints = Intersect::boundingBoxTrees(new LazyCurveBoundingBoxTree($curve1), new LazyCurveBoundingBoxTree($curve2), 0);
		#src/verb/eval/Intersect.hx:661: lines 661-663
		$result = [];
		$data = $ints->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = Intersect::curvesWithEstimate($curve1, $curve2, ArrayExtensions::first($item->item0->knots), ArrayExtensions::first($item->item1->knots), $tolerance);
		}
		#src/verb/eval/Intersect.hx:661: lines 661-665
		$_this = \Array_hx::wrap($result);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if (Vec::distSquared($item->point0, $item->point1) < $tolerance) {
				$result[] = $item;
			}
		}
		#src/verb/eval/Intersect.hx:661: lines 661-667
		return ArrayExtensions::unique(\Array_hx::wrap($result), function ($a, $b) use (&$tolerance) {
			#src/verb/eval/Intersect.hx:666: characters 13-55
			return \abs($a->u0 - $b->u0) < ($tolerance * 5);
		});
	}

	/**
	 * @param NurbsCurveData $curve0
	 * @param NurbsCurveData $curve1
	 * @param float $u0
	 * @param float $u1
	 * @param float $tolerance
	 * 
	 * @return CurveCurveIntersection
	 */
	public static function curvesWithEstimate ($curve0, $curve1, $u0, $u1, $tolerance) {
		#src/verb/eval/Intersect.hx:691: lines 691-697
		$objective = function ($x) use (&$curve1, &$curve0) {
			#src/verb/eval/Intersect.hx:692: lines 692-694
			$p1 = Eval_hx::rationalCurvePoint($curve0, ($x->arr[0] ?? null));
			$p2 = Eval_hx::rationalCurvePoint($curve1, ($x->arr[1] ?? null));
			$p1_p2 = Vec::sub($p1, $p2);
			#src/verb/eval/Intersect.hx:696: characters 13-41
			return Vec::dot($p1_p2, $p1_p2);
		};
		#src/verb/eval/Intersect.hx:712: lines 712-723
		$grad = function ($x) use (&$curve1, &$curve0) {
			#src/verb/eval/Intersect.hx:713: lines 713-714
			$dc0 = Eval_hx::rationalCurveDerivatives($curve0, ($x->arr[0] ?? null), 1);
			$dc1 = Eval_hx::rationalCurveDerivatives($curve1, ($x->arr[1] ?? null), 1);
			#src/verb/eval/Intersect.hx:716: characters 13-47
			$r = Vec::sub(($dc0->arr[0] ?? null), ($dc1->arr[0] ?? null));
			#src/verb/eval/Intersect.hx:718: characters 13-31
			$drdu = ($dc0->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:719: characters 13-46
			$drdt = Vec::mul(-1.0, ($dc1->arr[1] ?? null));
			#src/verb/eval/Intersect.hx:721: characters 25-49
			$grad = 2.0 * Vec::dot($drdu, $r);
			#src/verb/eval/Intersect.hx:721: lines 721-722
			return \Array_hx::wrap([
				$grad,
				2.0 * Vec::dot($drdt, $r),
			]);
		};
		#src/verb/eval/Intersect.hx:725: characters 9-92
		$sol_obj = Minimizer::uncmin($objective, \Array_hx::wrap([
			$u0,
			$u1,
		]), $tolerance * $tolerance, $grad);
		#src/verb/eval/Intersect.hx:727: lines 727-728
		$u1 = ($sol_obj->solution->arr[0] ?? null);
		$u2 = ($sol_obj->solution->arr[1] ?? null);
		#src/verb/eval/Intersect.hx:730: lines 730-731
		$p1 = Eval_hx::rationalCurvePoint($curve0, $u1);
		$p2 = Eval_hx::rationalCurvePoint($curve1, $u2);
		#src/verb/eval/Intersect.hx:733: characters 9-58
		return new CurveCurveIntersection($p1, $p2, $u1, $u2);
	}

	/**
	 * @param \Array_hx $segments
	 * 
	 * @return KdTree_verb_core_MeshIntersectionPoint
	 */
	public static function kdTreeFromSegments ($segments) {
		#src/verb/eval/Intersect.hx:369: characters 9-29
		$treePoints = new \Array_hx();
		#src/verb/eval/Intersect.hx:372: lines 372-375
		$_g = 0;
		while ($_g < $segments->length) {
			#src/verb/eval/Intersect.hx:372: characters 14-17
			$seg = ($segments->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:372: lines 372-375
			++$_g;
			#src/verb/eval/Intersect.hx:373: characters 13-66
			$x = new KdPoint_verb_core_MeshIntersectionPoint($seg->min->point, $seg->min);
			$treePoints->arr[$treePoints->length++] = $x;
			#src/verb/eval/Intersect.hx:374: characters 13-66
			$x1 = new KdPoint_verb_core_MeshIntersectionPoint($seg->max->point, $seg->max);
			$treePoints->arr[$treePoints->length++] = $x1;
		}
		#src/verb/eval/Intersect.hx:378: characters 9-78
		return new KdTree_verb_core_MeshIntersectionPoint($treePoints, Boot::getStaticClosure(Vec::class, 'distSquared'));
	}

	/**
	 * @param MeshIntersectionPoint $segEnd
	 * @param KdTree_verb_core_MeshIntersectionPoint $tree
	 * @param int $numResults
	 * 
	 * @return MeshIntersectionPoint
	 */
	public static function lookupAdjacentSegment ($segEnd, $tree, $numResults) {
		#src/verb/eval/Intersect.hx:395: lines 395-398
		$_this = $tree->nearest($segEnd->point, $numResults, Constants::$EPSILON);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if ($segEnd !== $item->obj->obj) {
				$result[] = $item;
			}
		}
		#src/verb/eval/Intersect.hx:395: lines 395-399
		$_this = \Array_hx::wrap($result);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = $item->obj->obj;
		}
		$adj = \Array_hx::wrap($result);
		#src/verb/eval/Intersect.hx:402: characters 16-49
		if ($adj->length === 1) {
			#src/verb/eval/Intersect.hx:402: characters 36-42
			return ($adj->arr[0] ?? null);
		} else {
			#src/verb/eval/Intersect.hx:402: characters 45-49
			return null;
		}
	}

	/**
	 * @param \Array_hx $segments
	 * 
	 * @return \Array_hx
	 */
	public static function makeMeshIntersectionPolylines ($segments) {
		#src/verb/eval/Intersect.hx:264: characters 9-44
		if ($segments->length === 0) {
			#src/verb/eval/Intersect.hx:264: characters 35-44
			return new \Array_hx();
		}
		#src/verb/eval/Intersect.hx:267: lines 267-270
		$_g = 0;
		while ($_g < $segments->length) {
			#src/verb/eval/Intersect.hx:267: characters 14-15
			$s = ($segments->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:267: lines 267-270
			++$_g;
			#src/verb/eval/Intersect.hx:268: characters 13-22
			$s->max->opp = $s->min;
			#src/verb/eval/Intersect.hx:269: characters 13-22
			$s->min->opp = $s->max;
		}
		#src/verb/eval/Intersect.hx:273: characters 9-51
		$tree = Intersect::kdTreeFromSegments($segments);
		#src/verb/eval/Intersect.hx:276: characters 9-54
		$ends = new \Array_hx();
		#src/verb/eval/Intersect.hx:278: lines 278-281
		$_g = 0;
		while ($_g < $segments->length) {
			#src/verb/eval/Intersect.hx:278: characters 14-17
			$seg = ($segments->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:278: lines 278-281
			++$_g;
			#src/verb/eval/Intersect.hx:279: characters 13-31
			$ends->arr[$ends->length++] = $seg->min;
			#src/verb/eval/Intersect.hx:280: characters 13-31
			$ends->arr[$ends->length++] = $seg->max;
		}
		#src/verb/eval/Intersect.hx:284: lines 284-293
		$_g = 0;
		while ($_g < $ends->length) {
			#src/verb/eval/Intersect.hx:284: characters 14-20
			$segEnd = ($ends->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:284: lines 284-293
			++$_g;
			#src/verb/eval/Intersect.hx:285: characters 13-45
			if ($segEnd->adj !== null) {
				#src/verb/eval/Intersect.hx:285: characters 37-45
				continue;
			}
			#src/verb/eval/Intersect.hx:287: characters 13-81
			$adjEnd = Intersect::lookupAdjacentSegment($segEnd, $tree, $segments->length);
			#src/verb/eval/Intersect.hx:289: lines 289-292
			if (($adjEnd !== null) && ($adjEnd->adj === null)) {
				#src/verb/eval/Intersect.hx:290: characters 17-27
				$segEnd->adj = $adjEnd;
				#src/verb/eval/Intersect.hx:291: characters 17-27
				$adjEnd->adj = $segEnd;
			}
		}
		#src/verb/eval/Intersect.hx:296: lines 296-298
		$result = [];
		$data = $ends->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if ($item->adj === null) {
				$result[] = $item;
			}
		}
		$freeEnds = \Array_hx::wrap($result);
		#src/verb/eval/Intersect.hx:301: lines 301-303
		if ($freeEnds->length === 0) {
			#src/verb/eval/Intersect.hx:302: characters 13-21
			$freeEnds = $ends;
		}
		#src/verb/eval/Intersect.hx:305: characters 9-22
		$pls = new \Array_hx();
		#src/verb/eval/Intersect.hx:306: characters 9-32
		$numVisitedEnds = 0;
		#src/verb/eval/Intersect.hx:307: characters 9-34
		$loopDetected = false;
		#src/verb/eval/Intersect.hx:309: lines 309-352
		while ($freeEnds->length !== 0) {
			#src/verb/eval/Intersect.hx:311: characters 23-37
			if ($freeEnds->length > 0) {
				$freeEnds->length--;
			}
			#src/verb/eval/Intersect.hx:311: characters 13-38
			$end = \array_pop($freeEnds->arr);
			#src/verb/eval/Intersect.hx:313: lines 313-345
			if (!$end->visited) {
				#src/verb/eval/Intersect.hx:316: characters 17-29
				$pl = new \Array_hx();
				#src/verb/eval/Intersect.hx:317: characters 17-34
				$curEnd = $end;
				#src/verb/eval/Intersect.hx:319: lines 319-339
				while ($curEnd !== null) {
					#src/verb/eval/Intersect.hx:322: lines 322-324
					if ($curEnd->visited) {
						#src/verb/eval/Intersect.hx:323: characters 25-30
						break;
					}
					#src/verb/eval/Intersect.hx:327: characters 21-35
					$curEnd->visited = true;
					#src/verb/eval/Intersect.hx:328: characters 21-39
					$curEnd->opp->visited = true;
					#src/verb/eval/Intersect.hx:330: characters 21-36
					$pl->arr[$pl->length++] = $curEnd;
					#src/verb/eval/Intersect.hx:331: characters 21-40
					$numVisitedEnds += 2;
					#src/verb/eval/Intersect.hx:333: characters 21-27
					$curEnd = $curEnd->opp->adj;
					#src/verb/eval/Intersect.hx:336: lines 336-338
					if ($curEnd === $end) {
						#src/verb/eval/Intersect.hx:337: characters 25-30
						break;
					}
				}
				#src/verb/eval/Intersect.hx:341: lines 341-344
				if ($pl->length > 0) {
					#src/verb/eval/Intersect.hx:342: characters 21-51
					$x = ($pl->arr[$pl->length - 1] ?? null)->opp;
					$pl->arr[$pl->length++] = $x;
					#src/verb/eval/Intersect.hx:343: characters 21-35
					$pls->arr[$pls->length++] = $pl;
				}
			}
			#src/verb/eval/Intersect.hx:347: lines 347-351
			if (($freeEnds->length === 0) && ($ends->length > 0) && ($loopDetected || ($numVisitedEnds < $ends->length))) {
				#src/verb/eval/Intersect.hx:348: characters 17-29
				$loopDetected = true;
				#src/verb/eval/Intersect.hx:349: characters 25-35
				if ($ends->length > 0) {
					$ends->length--;
				}
				#src/verb/eval/Intersect.hx:349: characters 17-36
				$e = \array_pop($ends->arr);
				#src/verb/eval/Intersect.hx:350: characters 17-35
				$freeEnds->arr[$freeEnds->length++] = $e;
			}
		}
		#src/verb/eval/Intersect.hx:354: characters 9-19
		return $pls;
	}

	/**
	 * @param Interval $clip1
	 * @param Interval $clip2
	 * @param MeshData $mesh1
	 * @param int $faceIndex1
	 * @param MeshData $mesh2
	 * @param int $faceIndex2
	 * 
	 * @return Interval
	 */
	public static function mergeTriangleClipIntervals ($clip1, $clip2, $mesh1, $faceIndex1, $mesh2, $faceIndex2) {
		#src/verb/eval/Intersect.hx:837: lines 837-840
		if (($clip2->min->u > ($clip1->max->u + Constants::$EPSILON)) || ($clip1->min->u > ($clip2->max->u + Constants::$EPSILON))) {
			#src/verb/eval/Intersect.hx:839: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:843: characters 9-137
		$min = ($clip1->min->u > $clip2->min->u ? new Pair($clip1->min, 0) : new Pair($clip2->min, 1));
		#src/verb/eval/Intersect.hx:844: characters 9-137
		$max = ($clip1->max->u < $clip2->max->u ? new Pair($clip1->max, 0) : new Pair($clip2->max, 1));
		#src/verb/eval/Intersect.hx:847: characters 13-91
		$res = new MeshIntersectionPoint(null, null, $min->item0->point, $faceIndex1, $faceIndex2);
		#src/verb/eval/Intersect.hx:846: lines 846-848
		$res1 = new Interval($res, new MeshIntersectionPoint(null, null, $max->item0->point, $faceIndex1, $faceIndex2));
		#src/verb/eval/Intersect.hx:850: lines 850-856
		if ($min->item1 === 0) {
			#src/verb/eval/Intersect.hx:851: characters 13-39
			$res1->min->uv0 = $min->item0->uv;
			#src/verb/eval/Intersect.hx:852: characters 13-89
			$res1->min->uv1 = Mesh::triangleUVFromPoint($mesh2, $faceIndex2, $min->item0->point);
		} else {
			#src/verb/eval/Intersect.hx:854: characters 13-89
			$res1->min->uv0 = Mesh::triangleUVFromPoint($mesh1, $faceIndex1, $min->item0->point);
			#src/verb/eval/Intersect.hx:855: characters 13-39
			$res1->min->uv1 = $min->item0->uv;
		}
		#src/verb/eval/Intersect.hx:858: lines 858-864
		if ($max->item1 === 0) {
			#src/verb/eval/Intersect.hx:859: characters 13-39
			$res1->max->uv0 = $max->item0->uv;
			#src/verb/eval/Intersect.hx:860: characters 13-89
			$res1->max->uv1 = Mesh::triangleUVFromPoint($mesh2, $faceIndex2, $max->item0->point);
		} else {
			#src/verb/eval/Intersect.hx:862: characters 13-89
			$res1->max->uv0 = Mesh::triangleUVFromPoint($mesh1, $faceIndex1, $max->item0->point);
			#src/verb/eval/Intersect.hx:863: characters 13-39
			$res1->max->uv1 = $max->item0->uv;
		}
		#src/verb/eval/Intersect.hx:866: characters 9-19
		return $res1;
	}

	/**
	 * @param MeshData $mesh
	 * @param float $min
	 * @param float $max
	 * @param float $step
	 * 
	 * @return \Array_hx
	 */
	public static function meshSlices ($mesh, $min, $max, $step) {
		#src/verb/eval/Intersect.hx:228: characters 9-54
		$bbtree = new MeshBoundingBoxTree($mesh);
		#src/verb/eval/Intersect.hx:229: characters 9-39
		$bb = $bbtree->boundingBox();
		#src/verb/eval/Intersect.hx:231: characters 9-28
		$x0 = ($bb->min->arr[0] ?? null);
		#src/verb/eval/Intersect.hx:232: characters 9-28
		$y0 = ($bb->min->arr[1] ?? null);
		#src/verb/eval/Intersect.hx:234: characters 9-28
		$x1 = ($bb->max->arr[0] ?? null);
		#src/verb/eval/Intersect.hx:235: characters 9-28
		$y1 = ($bb->max->arr[1] ?? null);
		#src/verb/eval/Intersect.hx:237: characters 9-47
		$span = Vec::span($min, $max, $step);
		#src/verb/eval/Intersect.hx:238: characters 9-69
		$slices = new \Array_hx();
		#src/verb/eval/Intersect.hx:240: lines 240-247
		$_g = 0;
		while ($_g < $span->length) {
			#src/verb/eval/Intersect.hx:240: characters 15-16
			$z = ($span->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:240: lines 240-247
			++$_g;
			#src/verb/eval/Intersect.hx:241: characters 13-84
			$pts = \Array_hx::wrap([
				\Array_hx::wrap([
					$x0,
					$y0,
					$z,
				]),
				\Array_hx::wrap([
					$x1,
					$y0,
					$z,
				]),
				\Array_hx::wrap([
					$x1,
					$y1,
					$z,
				]),
				\Array_hx::wrap([
					$x0,
					$y1,
					$z,
				]),
			]);
			#src/verb/eval/Intersect.hx:242: characters 13-81
			$uvs = \Array_hx::wrap([
				\Array_hx::wrap([
					0.0,
					0.0,
				]),
				\Array_hx::wrap([
					1.0,
					0.0,
				]),
				\Array_hx::wrap([
					1.0,
					1.0,
				]),
				\Array_hx::wrap([
					0.0,
					1.0,
				]),
			]);
			#src/verb/eval/Intersect.hx:243: characters 13-59
			$faces = \Array_hx::wrap([
				\Array_hx::wrap([
					0,
					1,
					2,
				]),
				\Array_hx::wrap([
					0,
					2,
					3,
				]),
			]);
			#src/verb/eval/Intersect.hx:244: characters 13-63
			$plane = new MeshData($faces, $pts, null, $uvs);
			#src/verb/eval/Intersect.hx:246: characters 13-67
			$x = Intersect::meshes($mesh, $plane, $bbtree);
			$slices->arr[$slices->length++] = $x;
		}
		#src/verb/eval/Intersect.hx:249: characters 9-22
		return $slices;
	}

	/**
	 * @param MeshData $mesh0
	 * @param MeshData $mesh1
	 * @param IBoundingBoxTree $bbtree0
	 * @param IBoundingBoxTree $bbtree1
	 * 
	 * @return \Array_hx
	 */
	public static function meshes ($mesh0, $mesh1, $bbtree0 = null, $bbtree1 = null) {
		#src/verb/eval/Intersect.hx:174: characters 9-76
		if ($bbtree0 === null) {
			#src/verb/eval/Intersect.hx:174: characters 30-37
			$bbtree0 = new LazyMeshBoundingBoxTree($mesh0);
		}
		#src/verb/eval/Intersect.hx:175: characters 9-76
		if ($bbtree1 === null) {
			#src/verb/eval/Intersect.hx:175: characters 30-37
			$bbtree1 = new LazyMeshBoundingBoxTree($mesh1);
		}
		#src/verb/eval/Intersect.hx:178: characters 9-72
		$bbints = Intersect::boundingBoxTrees($bbtree0, $bbtree1, 0);
		#src/verb/eval/Intersect.hx:181: lines 181-183
		$result = [];
		$data = $bbints->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = Intersect::triangles($mesh0, $item->item0, $mesh1, $item->item1);
		}
		#src/verb/eval/Intersect.hx:181: lines 181-185
		$_this = \Array_hx::wrap($result);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if ($item !== null) {
				$result[] = $item;
			}
		}
		#src/verb/eval/Intersect.hx:181: lines 181-187
		$_this = \Array_hx::wrap($result);
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			if (Vec::distSquared($item->min->point, $item->max->point) > Constants::$EPSILON) {
				$result[] = $item;
			}
		}
		#src/verb/eval/Intersect.hx:181: lines 181-207
		$segments = ArrayExtensions::unique(\Array_hx::wrap($result), function ($a, $b) {
			#src/verb/eval/Intersect.hx:193: characters 13-54
			$s1 = Vec::sub($a->min->uv0, $b->min->uv0);
			#src/verb/eval/Intersect.hx:194: characters 13-40
			$d1 = Vec::dot($s1, $s1);
			#src/verb/eval/Intersect.hx:196: characters 13-54
			$s2 = Vec::sub($a->max->uv0, $b->max->uv0);
			#src/verb/eval/Intersect.hx:197: characters 13-40
			$d2 = Vec::dot($s2, $s2);
			#src/verb/eval/Intersect.hx:199: characters 13-54
			$s3 = Vec::sub($a->min->uv0, $b->max->uv0);
			#src/verb/eval/Intersect.hx:200: characters 13-40
			$d3 = Vec::dot($s3, $s3);
			#src/verb/eval/Intersect.hx:202: characters 13-54
			$s4 = Vec::sub($a->max->uv0, $b->min->uv0);
			#src/verb/eval/Intersect.hx:203: characters 13-40
			$d4 = Vec::dot($s4, $s4);
			#src/verb/eval/Intersect.hx:205: lines 205-206
			if (!(($d1 < Constants::$EPSILON) && ($d2 < Constants::$EPSILON))) {
				#src/verb/eval/Intersect.hx:206: characters 17-69
				if ($d3 < Constants::$EPSILON) {
					#src/verb/eval/Intersect.hx:206: characters 45-67
					return $d4 < Constants::$EPSILON;
				} else {
					#src/verb/eval/Intersect.hx:206: characters 17-69
					return false;
				}
			} else {
				#src/verb/eval/Intersect.hx:205: lines 205-206
				return true;
			}
		});
		#src/verb/eval/Intersect.hx:209: characters 9-57
		return Intersect::makeMeshIntersectionPolylines($segments);
	}

	/**
	 * @param \Array_hx $origin0
	 * @param \Array_hx $normal0
	 * @param \Array_hx $origin1
	 * @param \Array_hx $normal1
	 * 
	 * @return Ray
	 */
	public static function planes ($origin0, $normal0, $origin1, $normal1) {
		#src/verb/eval/Intersect.hx:884: characters 9-45
		$d = Vec::cross($normal0, $normal1);
		#src/verb/eval/Intersect.hx:886: characters 9-59
		if (Vec::dot($d, $d) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:886: characters 48-59
			return null;
		}
		#src/verb/eval/Intersect.hx:889: characters 9-20
		$li = 0;
		#src/verb/eval/Intersect.hx:890: characters 9-35
		$mi = \abs(($d->arr[0] ?? null));
		#src/verb/eval/Intersect.hx:891: characters 9-35
		$m1 = \abs(($d->arr[1] ?? null));
		#src/verb/eval/Intersect.hx:892: characters 9-35
		$m2 = \abs(($d->arr[2] ?? null));
		#src/verb/eval/Intersect.hx:894: lines 894-897
		if ($m1 > $mi) {
			#src/verb/eval/Intersect.hx:895: characters 13-19
			$li = 1;
			#src/verb/eval/Intersect.hx:896: characters 13-20
			$mi = $m1;
		}
		#src/verb/eval/Intersect.hx:899: lines 899-902
		if ($m2 > $mi) {
			#src/verb/eval/Intersect.hx:900: characters 13-19
			$li = 2;
			#src/verb/eval/Intersect.hx:901: characters 13-20
			$mi = $m2;
		}
		#src/verb/eval/Intersect.hx:904: characters 9-28
		$a1 = null;
		$b1 = null;
		$a2 = null;
		$b2 = null;
		#src/verb/eval/Intersect.hx:906: lines 906-921
		if ($li === 0) {
			#src/verb/eval/Intersect.hx:907: characters 13-28
			$a1 = ($normal0->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:908: characters 13-28
			$b1 = ($normal0->arr[2] ?? null);
			#src/verb/eval/Intersect.hx:909: characters 13-28
			$a2 = ($normal1->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:910: characters 13-28
			$b2 = ($normal1->arr[2] ?? null);
		} else if ($li === 1) {
			#src/verb/eval/Intersect.hx:912: characters 13-28
			$a1 = ($normal0->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:913: characters 13-28
			$b1 = ($normal0->arr[2] ?? null);
			#src/verb/eval/Intersect.hx:914: characters 13-28
			$a2 = ($normal1->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:915: characters 13-28
			$b2 = ($normal1->arr[2] ?? null);
		} else {
			#src/verb/eval/Intersect.hx:917: characters 13-28
			$a1 = ($normal0->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:918: characters 13-28
			$b1 = ($normal0->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:919: characters 13-28
			$a2 = ($normal1->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:920: characters 13-28
			$b2 = ($normal1->arr[1] ?? null);
		}
		#src/verb/eval/Intersect.hx:924: characters 9-47
		$d1 = -Vec::dot($origin0, $normal0);
		#src/verb/eval/Intersect.hx:925: characters 9-47
		$d2 = -Vec::dot($origin1, $normal1);
		#src/verb/eval/Intersect.hx:927: characters 9-37
		$den = $a1 * $b2 - $b1 * $a2;
		#src/verb/eval/Intersect.hx:929: characters 9-43
		$x = ($b1 * $d2 - $d1 * $b2) / $den;
		#src/verb/eval/Intersect.hx:930: characters 9-43
		$y = ($d1 * $a2 - $a1 * $d2) / $den;
		#src/verb/eval/Intersect.hx:931: characters 9-15
		$p = null;
		#src/verb/eval/Intersect.hx:933: lines 933-939
		if ($li === 0) {
			#src/verb/eval/Intersect.hx:934: characters 13-24
			$p = \Array_hx::wrap([
				0,
				$x,
				$y,
			]);
		} else if ($li === 1) {
			#src/verb/eval/Intersect.hx:936: characters 13-24
			$p = \Array_hx::wrap([
				$x,
				0,
				$y,
			]);
		} else {
			#src/verb/eval/Intersect.hx:938: characters 13-24
			$p = \Array_hx::wrap([
				$x,
				$y,
				0,
			]);
		}
		#src/verb/eval/Intersect.hx:941: characters 9-49
		return new Ray($p, Vec::normalized($d));
	}

	/**
	 * @param PolylineData $polyline
	 * @param MeshData $mesh
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function polylineAndMesh ($polyline, $mesh, $tol) {
		#src/verb/eval/Intersect.hx:539: lines 539-541
		$res = Intersect::boundingBoxTrees(new LazyPolylineBoundingBoxTree($polyline), new LazyMeshBoundingBoxTree($mesh), $tol);
		#src/verb/eval/Intersect.hx:543: characters 9-31
		$finalResults = new \Array_hx();
		#src/verb/eval/Intersect.hx:545: lines 545-559
		$_g = 0;
		while ($_g < $res->length) {
			#src/verb/eval/Intersect.hx:545: characters 14-19
			$event = ($res->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:545: lines 545-559
			++$_g;
			#src/verb/eval/Intersect.hx:547: characters 13-37
			$polid = $event->item0;
			#src/verb/eval/Intersect.hx:548: characters 13-38
			$faceid = $event->item1;
			#src/verb/eval/Intersect.hx:550: characters 13-144
			$inter = Intersect::segmentWithTriangle(($polyline->points->arr[$polid] ?? null), ($polyline->points->arr[$polid + 1] ?? null), $mesh->points, ($mesh->faces->arr[$faceid] ?? null));
			#src/verb/eval/Intersect.hx:551: characters 13-42
			if ($inter === null) {
				#src/verb/eval/Intersect.hx:551: characters 34-42
				continue;
			}
			#src/verb/eval/Intersect.hx:553: characters 13-34
			$pt = $inter->point;
			#src/verb/eval/Intersect.hx:554: characters 13-101
			$u = (Vec::lerp($inter->p, \Array_hx::wrap([($polyline->params->arr[$polid] ?? null)]), \Array_hx::wrap([($polyline->params->arr[$polid + 1] ?? null)]))->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:555: characters 13-68
			$uv = Mesh::triangleUVFromPoint($mesh, $faceid, $pt);
			#src/verb/eval/Intersect.hx:557: characters 13-88
			$x = new PolylineMeshIntersection($pt, $u, $uv, $polid, $faceid);
			$finalResults->arr[$finalResults->length++] = $x;
		}
		#src/verb/eval/Intersect.hx:561: characters 9-28
		return $finalResults;
	}

	/**
	 * @param PolylineData $polyline0
	 * @param PolylineData $polyline1
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function polylines ($polyline0, $polyline1, $tol) {
		#src/verb/eval/Intersect.hx:989: lines 989-991
		$res = Intersect::boundingBoxTrees(new LazyPolylineBoundingBoxTree($polyline0), new LazyPolylineBoundingBoxTree($polyline1), $tol);
		#src/verb/eval/Intersect.hx:993: characters 9-31
		$finalResults = new \Array_hx();
		#src/verb/eval/Intersect.hx:995: lines 995-1009
		$_g = 0;
		while ($_g < $res->length) {
			#src/verb/eval/Intersect.hx:995: characters 14-19
			$event = ($res->arr[$_g] ?? null);
			#src/verb/eval/Intersect.hx:995: lines 995-1009
			++$_g;
			#src/verb/eval/Intersect.hx:996: characters 13-38
			$polid0 = $event->item0;
			#src/verb/eval/Intersect.hx:997: characters 13-38
			$polid1 = $event->item1;
			#src/verb/eval/Intersect.hx:999: lines 999-1000
			$inter = Intersect::segments(($polyline0->points->arr[$polid0] ?? null), ($polyline0->points->arr[$polid0 + 1] ?? null), ($polyline1->points->arr[$polid1] ?? null), ($polyline1->points->arr[$polid1 + 1] ?? null), $tol);
			#src/verb/eval/Intersect.hx:1002: characters 13-42
			if ($inter === null) {
				#src/verb/eval/Intersect.hx:1002: characters 34-42
				continue;
			}
			#src/verb/eval/Intersect.hx:1005: characters 13-108
			$inter->u0 = (Vec::lerp($inter->u0, \Array_hx::wrap([($polyline0->params->arr[$polid0] ?? null)]), \Array_hx::wrap([($polyline0->params->arr[$polid0 + 1] ?? null)]))->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:1006: characters 13-108
			$inter->u1 = (Vec::lerp($inter->u1, \Array_hx::wrap([($polyline1->params->arr[$polid1] ?? null)]), \Array_hx::wrap([($polyline1->params->arr[$polid1 + 1] ?? null)]))->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:1008: characters 13-37
			$finalResults->arr[$finalResults->length++] = $inter;
		}
		#src/verb/eval/Intersect.hx:1011: characters 9-28
		return $finalResults;
	}

	/**
	 * @param \Array_hx $a0
	 * @param \Array_hx $a
	 * @param \Array_hx $b0
	 * @param \Array_hx $b
	 * 
	 * @return CurveCurveIntersection
	 */
	public static function rays ($a0, $a, $b0, $b) {
		#src/verb/eval/Intersect.hx:1069: lines 1069-1076
		$dab = Vec::dot($a, $b);
		$dab0 = Vec::dot($a, $b0);
		$daa0 = Vec::dot($a, $a0);
		$dbb0 = Vec::dot($b, $b0);
		$dba0 = Vec::dot($b, $a0);
		$daa = Vec::dot($a, $a);
		$dbb = Vec::dot($b, $b);
		$div = $daa * $dbb - $dab * $dab;
		#src/verb/eval/Intersect.hx:1079: lines 1079-1081
		if (\abs($div) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:1080: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1083: lines 1083-1085
		$num = $dab * ($dab0 - $daa0) - $daa * ($dbb0 - $dba0);
		$w = $num / $div;
		$t = ($dab0 - $daa0 + $w * $dab) / $daa;
		#src/verb/eval/Intersect.hx:1087: characters 9-40
		$p0 = Vec::onRay($a0, $a, $t);
		#src/verb/eval/Intersect.hx:1088: characters 9-40
		$p1 = Vec::onRay($b0, $b, $w);
		#src/verb/eval/Intersect.hx:1090: characters 9-58
		return new CurveCurveIntersection($p0, $p1, $t, $w);
	}

	/**
	 * @param \Array_hx $p0
	 * @param \Array_hx $p1
	 * @param \Array_hx $v0
	 * @param \Array_hx $n
	 * 
	 * @return object
	 */
	public static function segmentAndPlane ($p0, $p1, $v0, $n) {
		#src/verb/eval/Intersect.hx:1177: characters 9-50
		$denom = Vec::dot($n, Vec::sub($p1, $p0));
		#src/verb/eval/Intersect.hx:1180: lines 1180-1182
		if (\abs($denom) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:1181: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1184: characters 9-51
		$numer = Vec::dot($n, Vec::sub($v0, $p0));
		#src/verb/eval/Intersect.hx:1186: characters 9-31
		$p = $numer / $denom;
		#src/verb/eval/Intersect.hx:1188: characters 9-80
		if (($p > (1.0 + Constants::$EPSILON)) || ($p < -Constants::$EPSILON)) {
			#src/verb/eval/Intersect.hx:1188: characters 69-80
			return null;
		}
		#src/verb/eval/Intersect.hx:1190: characters 9-24
		return new HxAnon(["p" => $p]);
	}

	/**
	 * @param \Array_hx $p0
	 * @param \Array_hx $p1
	 * @param \Array_hx $points
	 * @param \Array_hx $tri
	 * 
	 * @return TriSegmentIntersection
	 */
	public static function segmentWithTriangle ($p0, $p1, $points, $tri) {
		#src/verb/eval/Intersect.hx:1108: lines 1108-1113
		$v0 = ($points->arr[($tri->arr[0] ?? null)] ?? null);
		$v1 = ($points->arr[($tri->arr[1] ?? null)] ?? null);
		$v2 = ($points->arr[($tri->arr[2] ?? null)] ?? null);
		$u = Vec::sub($v1, $v0);
		$v = Vec::sub($v2, $v0);
		$n = Vec::cross($u, $v);
		#src/verb/eval/Intersect.hx:1115: lines 1115-1118
		$dir = Vec::sub($p1, $p0);
		$w0 = Vec::sub($p0, $v0);
		$a = -Vec::dot($n, $w0);
		$b = Vec::dot($n, $dir);
		#src/verb/eval/Intersect.hx:1121: lines 1121-1123
		if (\abs($b) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:1122: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1125: characters 9-23
		$r = $a / $b;
		#src/verb/eval/Intersect.hx:1128: lines 1128-1130
		if (($r < 0) || ($r > 1)) {
			#src/verb/eval/Intersect.hx:1129: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1133: characters 9-51
		$pt = Vec::add($p0, Vec::mul($r, $dir));
		#src/verb/eval/Intersect.hx:1136: lines 1136-1142
		$uv = Vec::dot($u, $v);
		$uu = Vec::dot($u, $u);
		$vv = Vec::dot($v, $v);
		$w = Vec::sub($pt, $v0);
		$wu = Vec::dot($w, $u);
		$wv = Vec::dot($w, $v);
		$denom = $uv * $uv - $uu * $vv;
		#src/verb/eval/Intersect.hx:1144: lines 1144-1146
		if (\abs($denom) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:1145: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1148: lines 1148-1149
		$s = ($uv * $wv - $vv * $wu) / $denom;
		$t = ($uv * $wu - $uu * $wv) / $denom;
		#src/verb/eval/Intersect.hx:1151: lines 1151-1153
		if (($s > (1.0 + Constants::$EPSILON)) || ($t > (1.0 + Constants::$EPSILON)) || ($t < -Constants::$EPSILON) || ($s < -Constants::$EPSILON) || (($s + $t) > (1.0 + Constants::$EPSILON))) {
			#src/verb/eval/Intersect.hx:1152: characters 13-24
			return null;
		}
		#src/verb/eval/Intersect.hx:1155: characters 9-56
		return new TriSegmentIntersection($pt, $s, $t, $r);
	}

	/**
	 * @param \Array_hx $a0
	 * @param \Array_hx $a1
	 * @param \Array_hx $b0
	 * @param \Array_hx $b1
	 * @param float $tol
	 * 
	 * @return CurveCurveIntersection
	 */
	public static function segments ($a0, $a1, $b0, $b1, $tol) {
		#src/verb/eval/Intersect.hx:1030: lines 1030-1036
		$a1ma0 = Vec::sub($a1, $a0);
		$aN = \sqrt(Vec::dot($a1ma0, $a1ma0));
		$a = Vec::mul(1 / $aN, $a1ma0);
		$b1mb0 = Vec::sub($b1, $b0);
		$bN = \sqrt(Vec::dot($b1mb0, $b1mb0));
		$b = Vec::mul(1 / $bN, $b1mb0);
		$int_params = Intersect::rays($a0, $a, $b0, $b);
		#src/verb/eval/Intersect.hx:1038: lines 1038-1049
		if ($int_params !== null) {
			#src/verb/eval/Intersect.hx:1040: characters 32-65
			$b = $int_params->u0 / $aN;
			#src/verb/eval/Intersect.hx:1040: characters 22-71
			$a = (\is_nan(0) || \is_nan($b) ? \Math::$NaN : \max(0, $b));
			#src/verb/eval/Intersect.hx:1040: lines 1040-1044
			$u0 = (\is_nan($a) || \is_nan(1.0) ? \Math::$NaN : \min($a, 1.0));
			#src/verb/eval/Intersect.hx:1041: characters 32-65
			$b = $int_params->u1 / $bN;
			#src/verb/eval/Intersect.hx:1041: characters 22-71
			$a = (\is_nan(0) || \is_nan($b) ? \Math::$NaN : \max(0, $b));
			#src/verb/eval/Intersect.hx:1040: lines 1040-1044
			$u1 = (\is_nan($a) || \is_nan(1.0) ? \Math::$NaN : \min($a, 1.0));
			$point0 = Vec::onRay($a0, $a1ma0, $u0);
			$point1 = Vec::onRay($b0, $b1mb0, $u1);
			$dist = Vec::distSquared($point0, $point1);
			#src/verb/eval/Intersect.hx:1046: lines 1046-1048
			if ($dist < ($tol * $tol)) {
				#src/verb/eval/Intersect.hx:1047: characters 17-76
				return new CurveCurveIntersection($point0, $point1, $u0, $u1);
			}
		}
		#src/verb/eval/Intersect.hx:1051: characters 9-20
		return null;
	}

	/**
	 * @param NurbsSurfaceData $surface0
	 * @param NurbsSurfaceData $surface1
	 * @param float $tol
	 * 
	 * @return \Array_hx
	 */
	public static function surfaces ($surface0, $surface1, $tol) {
		#src/verb/eval/Intersect.hx:52: characters 9-62
		$tess1 = Tess::rationalSurfaceAdaptive($surface0);
		#src/verb/eval/Intersect.hx:53: characters 9-62
		$tess2 = Tess::rationalSurfaceAdaptive($surface1);
		#src/verb/eval/Intersect.hx:56: characters 9-58
		$resApprox = Intersect::meshes($tess1, $tess2);
		#src/verb/eval/Intersect.hx:59: lines 59-63
		$result = [];
		$data = $resApprox->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			#src/verb/eval/Intersect.hx:60: lines 60-62
			$result1 = [];
			$data = $item->arr;
			$_g_current1 = 0;
			$_g_length1 = \count($data);
			$_g_data1 = $data;
			while ($_g_current1 < $_g_length1) {
				$item1 = $_g_data1[$_g_current1++];
				$result1[] = Intersect::surfacesAtPointWithEstimate($surface0, $surface1, $item1->uv0, $item1->uv1, $tol);
			}
			#src/verb/eval/Intersect.hx:59: lines 59-63
			$result[] = \Array_hx::wrap($result1);
		}
		$exactPls = \Array_hx::wrap($result);
		#src/verb/eval/Intersect.hx:66: lines 66-68
		$result = [];
		$data = $exactPls->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			#src/verb/eval/Intersect.hx:67: characters 46-83
			$result1 = [];
			$data = $item->arr;
			$_g_current1 = 0;
			$_g_length1 = \count($data);
			$_g_data1 = $data;
			while ($_g_current1 < $_g_length1) {
				$item1 = $_g_data1[$_g_current1++];
				$result1[] = $item1->point;
			}
			#src/verb/eval/Intersect.hx:66: lines 66-68
			$result[] = Make::rationalInterpCurve(\Array_hx::wrap($result1), 3);
		}
		return \Array_hx::wrap($result);
	}

	/**
	 * @param NurbsSurfaceData $surface0
	 * @param NurbsSurfaceData $surface1
	 * @param \Array_hx $uv1
	 * @param \Array_hx $uv2
	 * @param float $tol
	 * 
	 * @return SurfaceSurfaceIntersectionPoint
	 */
	public static function surfacesAtPointWithEstimate ($surface0, $surface1, $uv1, $uv2, $tol) {
		#src/verb/eval/Intersect.hx:91: characters 9-66
		$pds = null;
		$p = null;
		$pn = null;
		$pu = null;
		$pv = null;
		$pd = null;
		$qds = null;
		$q = null;
		$qn = null;
		$qu = null;
		$qv = null;
		$qd = null;
		$dist = null;
		#src/verb/eval/Intersect.hx:92: characters 9-24
		$maxits = 5;
		#src/verb/eval/Intersect.hx:93: characters 9-21
		$its = 0;
		#src/verb/eval/Intersect.hx:95: lines 95-151
		while (true) {
			#src/verb/eval/Intersect.hx:97: characters 13-81
			$pds = Eval_hx::rationalSurfaceDerivatives($surface0, ($uv1->arr[0] ?? null), ($uv1->arr[1] ?? null), 1);
			#src/verb/eval/Intersect.hx:98: characters 13-26
			$p = (($pds->arr[0] ?? null)->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:99: characters 13-27
			$pu = (($pds->arr[1] ?? null)->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:100: characters 13-27
			$pv = (($pds->arr[0] ?? null)->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:101: characters 13-55
			$pn = Vec::normalized(Vec::cross($pu, $pv));
			#src/verb/eval/Intersect.hx:102: characters 13-34
			$pd = Vec::dot($pn, $p);
			#src/verb/eval/Intersect.hx:104: characters 13-81
			$qds = Eval_hx::rationalSurfaceDerivatives($surface1, ($uv2->arr[0] ?? null), ($uv2->arr[1] ?? null), 1);
			#src/verb/eval/Intersect.hx:105: characters 13-26
			$q = (($qds->arr[0] ?? null)->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:106: characters 13-27
			$qu = (($qds->arr[1] ?? null)->arr[0] ?? null);
			#src/verb/eval/Intersect.hx:107: characters 13-27
			$qv = (($qds->arr[0] ?? null)->arr[1] ?? null);
			#src/verb/eval/Intersect.hx:108: characters 13-55
			$qn = Vec::normalized(Vec::cross($qu, $qv));
			#src/verb/eval/Intersect.hx:109: characters 13-34
			$qd = Vec::dot($qn, $q);
			#src/verb/eval/Intersect.hx:112: characters 13-41
			$dist = Vec::distSquared($p, $q);
			#src/verb/eval/Intersect.hx:114: lines 114-116
			if ($dist < ($tol * $tol)) {
				#src/verb/eval/Intersect.hx:115: characters 17-22
				break;
			}
			#src/verb/eval/Intersect.hx:119: characters 13-60
			$fn = Vec::normalized(Vec::cross($pn, $qn));
			#src/verb/eval/Intersect.hx:120: characters 13-39
			$fd = Vec::dot($fn, $p);
			#src/verb/eval/Intersect.hx:123: characters 13-69
			$x = Intersect::threePlanes($pn, $pd, $qn, $qd, $fn, $fd);
			#src/verb/eval/Intersect.hx:125: characters 13-33
			if ($x === null) {
				#src/verb/eval/Intersect.hx:125: characters 28-33
				throw Exception::thrown("panic!");
			}
			#src/verb/eval/Intersect.hx:130: characters 13-40
			$pdif = Vec::sub($x, $p);
			#src/verb/eval/Intersect.hx:131: characters 13-40
			$qdif = Vec::sub($x, $q);
			#src/verb/eval/Intersect.hx:133: characters 13-42
			$rw = Vec::cross($pu, $pn);
			#src/verb/eval/Intersect.hx:134: characters 13-42
			$rt = Vec::cross($pv, $pn);
			#src/verb/eval/Intersect.hx:136: characters 13-42
			$su = Vec::cross($qu, $qn);
			#src/verb/eval/Intersect.hx:137: characters 13-42
			$sv = Vec::cross($qv, $qn);
			#src/verb/eval/Intersect.hx:139: characters 13-62
			$dw = Vec::dot($rt, $pdif) / Vec::dot($rt, $pu);
			#src/verb/eval/Intersect.hx:140: characters 13-62
			$dt = Vec::dot($rw, $pdif) / Vec::dot($rw, $pv);
			#src/verb/eval/Intersect.hx:142: characters 13-62
			$du = Vec::dot($sv, $qdif) / Vec::dot($sv, $qu);
			#src/verb/eval/Intersect.hx:143: characters 13-62
			$dv = Vec::dot($su, $qdif) / Vec::dot($su, $qv);
			#src/verb/eval/Intersect.hx:145: characters 13-43
			$uv1 = Vec::add(\Array_hx::wrap([
				$dw,
				$dt,
			]), $uv1);
			#src/verb/eval/Intersect.hx:146: characters 13-43
			$uv2 = Vec::add(\Array_hx::wrap([
				$du,
				$dv,
			]), $uv2);
			#src/verb/eval/Intersect.hx:149: characters 13-18
			++$its;
			#src/verb/eval/Intersect.hx:95: lines 95-151
			if (!($its < $maxits)) {
				break;
			}
		}
		#src/verb/eval/Intersect.hx:153: characters 9-70
		return new SurfaceSurfaceIntersectionPoint($uv1, $uv2, $p, $dist);
	}

	/**
	 * @param \Array_hx $n0
	 * @param float $d0
	 * @param \Array_hx $n1
	 * @param float $d1
	 * @param \Array_hx $n2
	 * @param float $d2
	 * 
	 * @return \Array_hx
	 */
	public static function threePlanes ($n0, $d0, $n1, $d1, $n2, $d2) {
		#src/verb/eval/Intersect.hx:962: characters 9-37
		$u = Vec::cross($n1, $n2);
		#src/verb/eval/Intersect.hx:963: characters 9-36
		$den = Vec::dot($n0, $u);
		#src/verb/eval/Intersect.hx:965: characters 9-59
		if (\abs($den) < Constants::$EPSILON) {
			#src/verb/eval/Intersect.hx:965: characters 48-59
			return null;
		}
		#src/verb/eval/Intersect.hx:967: characters 9-68
		$diff = Vec::sub(Vec::mul($d2, $n1), Vec::mul($d1, $n2));
		#src/verb/eval/Intersect.hx:968: characters 9-68
		$num = Vec::add(Vec::mul($d0, $u), Vec::cross($n0, $diff));
		#src/verb/eval/Intersect.hx:970: characters 9-39
		return Vec::mul(1 / $den, $num);
	}

	/**
	 * @param MeshData $mesh0
	 * @param int $faceIndex0
	 * @param MeshData $mesh1
	 * @param int $faceIndex1
	 * 
	 * @return Interval
	 */
	public static function triangles ($mesh0, $faceIndex0, $mesh1, $faceIndex1) {
		#src/verb/eval/Intersect.hx:751: characters 9-44
		$tri0 = ($mesh0->faces->arr[$faceIndex0] ?? null);
		#src/verb/eval/Intersect.hx:752: characters 9-44
		$tri1 = ($mesh1->faces->arr[$faceIndex1] ?? null);
		#src/verb/eval/Intersect.hx:755: characters 9-61
		$n0 = Mesh::getTriangleNorm($mesh0->points, $tri0);
		#src/verb/eval/Intersect.hx:756: characters 9-61
		$n1 = Mesh::getTriangleNorm($mesh1->points, $tri1);
		#src/verb/eval/Intersect.hx:757: characters 9-42
		$o0 = ($mesh0->points->arr[($tri0->arr[0] ?? null)] ?? null);
		#src/verb/eval/Intersect.hx:758: characters 9-42
		$o1 = ($mesh1->points->arr[($tri1->arr[0] ?? null)] ?? null);
		#src/verb/eval/Intersect.hx:761: characters 9-52
		$ray = Intersect::planes($o0, $n0, $o1, $n1);
		#src/verb/eval/Intersect.hx:762: characters 9-37
		if ($ray === null) {
			#src/verb/eval/Intersect.hx:762: characters 26-37
			return null;
		}
		#src/verb/eval/Intersect.hx:765: characters 9-73
		$clip1 = Intersect::clipRayInCoplanarTriangle($ray, $mesh0, $faceIndex0);
		#src/verb/eval/Intersect.hx:766: characters 9-39
		if ($clip1 === null) {
			#src/verb/eval/Intersect.hx:766: characters 28-39
			return null;
		}
		#src/verb/eval/Intersect.hx:769: characters 9-73
		$clip2 = Intersect::clipRayInCoplanarTriangle($ray, $mesh1, $faceIndex1);
		#src/verb/eval/Intersect.hx:770: characters 9-39
		if ($clip2 === null) {
			#src/verb/eval/Intersect.hx:770: characters 28-39
			return null;
		}
		#src/verb/eval/Intersect.hx:773: characters 9-102
		$merged = Intersect::mergeTriangleClipIntervals($clip1, $clip2, $mesh0, $faceIndex0, $mesh1, $faceIndex1);
		#src/verb/eval/Intersect.hx:774: characters 9-40
		if ($merged === null) {
			#src/verb/eval/Intersect.hx:774: characters 29-40
			return null;
		}
		#src/verb/eval/Intersect.hx:777: characters 13-113
		$tmp = new MeshIntersectionPoint($merged->min->uv0, $merged->min->uv1, $merged->min->point, $faceIndex0, $faceIndex1);
		#src/verb/eval/Intersect.hx:776: lines 776-778
		return new Interval($tmp, new MeshIntersectionPoint($merged->max->uv0, $merged->max->uv1, $merged->max->point, $faceIndex0, $faceIndex1));
	}
}

Boot::registerClass(Intersect::class, 'verb.eval.Intersect');
