<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace verb\eval_hx;

use \verb\core\NurbsSurfaceData;
use \php\Boot;
use \haxe\Exception;
use \verb\core\Constants;
use \verb\core\Mat;
use \verb\core\Trig;
use \verb\core\Vec;
use \verb\core\NurbsCurveData;
use \verb\core\ArrayExtensions;

class Make {
	/**
	 * @param \Array_hx $center
	 * @param \Array_hx $xaxis
	 * @param \Array_hx $yaxis
	 * @param float $radius
	 * @param float $startAngle
	 * @param float $endAngle
	 * 
	 * @return NurbsCurveData
	 */
	public static function arc ($center, $xaxis, $yaxis, $radius, $startAngle, $endAngle) {
		#src/verb/eval/Make.hx:350: characters 9-147
		return Make::ellipseArc($center, Vec::mul($radius, Vec::normalized($xaxis)), Vec::mul($radius, Vec::normalized($yaxis)), $startAngle, $endAngle);
	}

	/**
	 * @param NurbsCurveData $curve
	 * 
	 * @return NurbsCurveData
	 */
	public static function clonedCurve ($curve) {
		#src/verb/eval/Make.hx:156: characters 36-48
		$curve1 = $curve->degree;
		#src/verb/eval/Make.hx:156: characters 50-68
		$tmp = (clone $curve->knots);
		#src/verb/eval/Make.hx:156: characters 70-126
		$_this = $curve->controlPoints;
		$result = [];
		$data = $_this->arr;
		$_g_current = 0;
		$_g_length = \count($data);
		$_g_data = $data;
		while ($_g_current < $_g_length) {
			$item = $_g_data[$_g_current++];
			$result[] = (clone $item);
		}
		#src/verb/eval/Make.hx:156: characters 9-128
		return new NurbsCurveData($curve1, $tmp, \Array_hx::wrap($result));
	}

	/**
	 * @param \Array_hx $axis
	 * @param \Array_hx $xaxis
	 * @param \Array_hx $base
	 * @param float $height
	 * @param float $radius
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function conicalSurface ($axis, $xaxis, $base, $height, $radius) {
		#src/verb/eval/Make.hx:620: lines 620-625
		$angle = 2 * \Math::$PI;
		$prof_degree = 1;
		#src/verb/eval/Make.hx:622: characters 29-69
		$prof_ctrl_pts = Vec::add($base, Vec::mul($height, $axis));
		#src/verb/eval/Make.hx:620: lines 620-625
		$prof_ctrl_pts1 = \Array_hx::wrap([
			$prof_ctrl_pts,
			Vec::add($base, Vec::mul($radius, $xaxis)),
		]);
		$prof_knots = \Array_hx::wrap([
			0.0,
			0.0,
			1.0,
			1.0,
		]);
		$prof_weights = \Array_hx::wrap([
			1.0,
			1.0,
		]);
		$prof = new NurbsCurveData($prof_degree, $prof_knots, Eval_hx::homogenize1d($prof_ctrl_pts1, $prof_weights));
		#src/verb/eval/Make.hx:627: characters 9-57
		return Make::revolvedSurface($prof, $base, $axis, $angle);
	}

	/**
	 * @param \Array_hx $axis
	 * @param \Array_hx $xaxis
	 * @param \Array_hx $base
	 * @param float $height
	 * @param float $radius
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function cylindricalSurface ($axis, $xaxis, $base, $height, $radius) {
		#src/verb/eval/Make.hx:437: lines 437-439
		$yaxis = Vec::cross($axis, $xaxis);
		$angle = 2.0 * \Math::$PI;
		$circ = Make::arc($base, $xaxis, $yaxis, $radius, 0.0, 2 * \Math::$PI);
		#src/verb/eval/Make.hx:441: characters 9-58
		return Make::extrudedSurface($axis, $height, $circ);
	}

	/**
	 * @param \Array_hx $center
	 * @param \Array_hx $xaxis
	 * @param \Array_hx $yaxis
	 * @param float $startAngle
	 * @param float $endAngle
	 * 
	 * @return NurbsCurveData
	 */
	public static function ellipseArc ($center, $xaxis, $yaxis, $startAngle, $endAngle) {
		#src/verb/eval/Make.hx:245: characters 9-41
		$xradius = Vec::norm($xaxis);
		#src/verb/eval/Make.hx:246: characters 9-41
		$yradius = Vec::norm($yaxis);
		#src/verb/eval/Make.hx:248: characters 9-40
		$xaxis = Vec::normalized($xaxis);
		#src/verb/eval/Make.hx:249: characters 9-40
		$yaxis = Vec::normalized($yaxis);
		#src/verb/eval/Make.hx:252: characters 9-73
		if ($endAngle < $startAngle) {
			#src/verb/eval/Make.hx:252: characters 36-73
			$endAngle = 2.0 * \Math::$PI + $startAngle;
		}
		#src/verb/eval/Make.hx:254: lines 254-255
		$theta = $endAngle - $startAngle;
		$numArcs = 0;
		#src/verb/eval/Make.hx:258: lines 258-268
		if ($theta <= (\Math::$PI / 2)) {
			#src/verb/eval/Make.hx:259: characters 13-24
			$numArcs = 1;
		} else if ($theta <= \Math::$PI) {
			#src/verb/eval/Make.hx:262: characters 17-28
			$numArcs = 2;
		} else if ($theta <= (3 * \Math::$PI / 2)) {
			#src/verb/eval/Make.hx:264: characters 17-28
			$numArcs = 3;
		} else {
			#src/verb/eval/Make.hx:266: characters 17-28
			$numArcs = 4;
		}
		#src/verb/eval/Make.hx:270: lines 270-279
		$dtheta = $theta / $numArcs;
		$n = 2 * $numArcs;
		$w1 = \cos($dtheta / 2);
		$P0 = Vec::add($center, Vec::add(Vec::mul($xradius * \cos($startAngle), $xaxis), Vec::mul($yradius * \sin($startAngle), $yaxis)));
		$T0 = Vec::sub(Vec::mul(\cos($startAngle), $yaxis), Vec::mul(\sin($startAngle), $xaxis));
		$controlPoints = new \Array_hx();
		$knots = Vec::zeros1d(2 * $numArcs + 3);
		$index = 0;
		$angle = $startAngle;
		$weights = Vec::zeros1d($numArcs * 2);
		#src/verb/eval/Make.hx:281: characters 9-30
		$controlPoints->offsetSet(0, $P0);
		#src/verb/eval/Make.hx:282: characters 9-25
		$weights->offsetSet(0, 1.0);
		#src/verb/eval/Make.hx:284: characters 19-23
		$_g = 1;
		#src/verb/eval/Make.hx:284: characters 23-32
		$_g1 = $numArcs + 1;
		#src/verb/eval/Make.hx:284: lines 284-307
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:284: characters 19-32
			$i = $_g++;
			#src/verb/eval/Make.hx:286: characters 13-28
			$angle += $dtheta;
			#src/verb/eval/Make.hx:287: lines 287-288
			$P2 = Vec::add($center, Vec::add(Vec::mul($xradius * \cos($angle), $xaxis), Vec::mul($yradius * \sin($angle), $yaxis)));
			#src/verb/eval/Make.hx:290: characters 13-33
			$weights->offsetSet($index + 2, 1);
			#src/verb/eval/Make.hx:291: characters 13-40
			$controlPoints->offsetSet($index + 2, $P2);
			#src/verb/eval/Make.hx:293: characters 13-101
			$T2 = Vec::sub(Vec::mul(\cos($angle), $yaxis), Vec::mul(\sin($angle), $xaxis));
			#src/verb/eval/Make.hx:295: characters 13-113
			$inters = Intersect::rays($P0, Vec::mul(1 / Vec::norm($T0), $T0), $P2, Vec::mul(1 / Vec::norm($T2), $T2));
			#src/verb/eval/Make.hx:296: characters 13-59
			$P1 = Vec::add($P0, Vec::mul($inters->u0, $T0));
			#src/verb/eval/Make.hx:298: characters 13-34
			$weights->offsetSet($index + 1, $w1);
			#src/verb/eval/Make.hx:299: characters 13-40
			$controlPoints->offsetSet($index + 1, $P1);
			#src/verb/eval/Make.hx:301: characters 13-23
			$index += 2;
			#src/verb/eval/Make.hx:303: lines 303-306
			if ($i < $numArcs) {
				#src/verb/eval/Make.hx:304: characters 17-24
				$P0 = $P2;
				#src/verb/eval/Make.hx:305: characters 17-24
				$T0 = $T2;
			}
		}
		#src/verb/eval/Make.hx:309: characters 9-33
		$j = 2 * $numArcs + 1;
		#src/verb/eval/Make.hx:312: characters 13-27
		$knots->offsetSet(0, 0.0);
		#src/verb/eval/Make.hx:313: characters 13-29
		$knots->offsetSet($j, 1.0);
		#src/verb/eval/Make.hx:312: characters 13-27
		$knots->offsetSet(1, 0.0);
		#src/verb/eval/Make.hx:313: characters 13-29
		$knots->offsetSet(1 + $j, 1.0);
		#src/verb/eval/Make.hx:312: characters 13-27
		$knots->offsetSet(2, 0.0);
		#src/verb/eval/Make.hx:313: characters 13-29
		$knots->offsetSet(2 + $j, 1.0);
		#src/verb/eval/Make.hx:316: lines 316-326
		if ($numArcs === 2) {
			#src/verb/eval/Make.hx:318: characters 17-42
			$knots->offsetSet(3, $knots->offsetSet(4, 0.5));
		} else if ($numArcs === 3) {
			#src/verb/eval/Make.hx:320: characters 17-42
			$knots->offsetSet(3, $knots->offsetSet(4, 0.33333333333333331));
			#src/verb/eval/Make.hx:321: characters 17-42
			$knots->offsetSet(5, $knots->offsetSet(6, 0.66666666666666663));
		} else if ($numArcs === 4) {
			#src/verb/eval/Make.hx:323: characters 17-43
			$knots->offsetSet(3, $knots->offsetSet(4, 0.25));
			#src/verb/eval/Make.hx:324: characters 17-42
			$knots->offsetSet(5, $knots->offsetSet(6, 0.5));
			#src/verb/eval/Make.hx:325: characters 17-43
			$knots->offsetSet(7, $knots->offsetSet(8, 0.75));
		}
		#src/verb/eval/Make.hx:328: characters 9-90
		return new NurbsCurveData(2, $knots, Eval_hx::homogenize1d($controlPoints, $weights));
	}

	/**
	 * @param \Array_hx $axis
	 * @param float $length
	 * @param NurbsCurveData $profile
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function extrudedSurface ($axis, $length, $profile) {
		#src/verb/eval/Make.hx:397: characters 9-61
		$controlPoints = \Array_hx::wrap([
			new \Array_hx(),
			new \Array_hx(),
			new \Array_hx(),
		]);
		#src/verb/eval/Make.hx:398: characters 9-49
		$weights = \Array_hx::wrap([
			new \Array_hx(),
			new \Array_hx(),
			new \Array_hx(),
		]);
		#src/verb/eval/Make.hx:400: characters 9-79
		$prof_controlPoints = Eval_hx::dehomogenize1d($profile->controlPoints);
		#src/verb/eval/Make.hx:401: characters 9-67
		$prof_weights = Eval_hx::weight1d($profile->controlPoints);
		#src/verb/eval/Make.hx:403: characters 9-51
		$translation = Vec::mul($length, $axis);
		#src/verb/eval/Make.hx:404: characters 9-61
		$halfTranslation = Vec::mul(0.5 * $length, $axis);
		#src/verb/eval/Make.hx:407: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:407: characters 23-48
		$_g1 = $prof_controlPoints->length;
		#src/verb/eval/Make.hx:407: lines 407-416
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:407: characters 19-48
			$j = $_g++;
			#src/verb/eval/Make.hx:409: characters 13-56
			($controlPoints->arr[2] ?? null)->offsetSet($j, ($prof_controlPoints->arr[$j] ?? null));
			#src/verb/eval/Make.hx:410: characters 13-84
			($controlPoints->arr[1] ?? null)->offsetSet($j, Vec::add($halfTranslation, ($prof_controlPoints->arr[$j] ?? null)));
			#src/verb/eval/Make.hx:411: characters 13-80
			($controlPoints->arr[0] ?? null)->offsetSet($j, Vec::add($translation, ($prof_controlPoints->arr[$j] ?? null)));
			#src/verb/eval/Make.hx:413: characters 13-44
			($weights->arr[0] ?? null)->offsetSet($j, ($prof_weights->arr[$j] ?? null));
			#src/verb/eval/Make.hx:414: characters 13-44
			($weights->arr[1] ?? null)->offsetSet($j, ($prof_weights->arr[$j] ?? null));
			#src/verb/eval/Make.hx:415: characters 13-44
			($weights->arr[2] ?? null)->offsetSet($j, ($prof_weights->arr[$j] ?? null));
		}
		#src/verb/eval/Make.hx:418: characters 41-55
		$profile1 = $profile->degree;
		#src/verb/eval/Make.hx:418: characters 72-85
		$profile2 = $profile->knots;
		#src/verb/eval/Make.hx:418: characters 9-131
		return new NurbsSurfaceData(2, $profile1, \Array_hx::wrap([
			0,
			0,
			0,
			1,
			1,
			1,
		]), $profile2, Eval_hx::homogenize2d($controlPoints, $weights));
	}

	/**
	 * @param \Array_hx $p1
	 * @param \Array_hx $p2
	 * @param \Array_hx $p3
	 * @param \Array_hx $p4
	 * @param int $degree
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function fourPointSurface ($p1, $p2, $p3, $p4, $degree = 3) {
		#src/verb/eval/Make.hx:199: lines 199-227
		if ($degree === null) {
			$degree = 3;
		}
		#src/verb/eval/Make.hx:201: characters 9-42
		$degreeFloat = $degree;
		#src/verb/eval/Make.hx:203: characters 9-22
		$pts = new \Array_hx();
		#src/verb/eval/Make.hx:204: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:204: characters 23-31
		$_g1 = $degree + 1;
		#src/verb/eval/Make.hx:204: lines 204-220
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:204: characters 19-31
			$i = $_g++;
			#src/verb/eval/Make.hx:206: characters 13-26
			$row = new \Array_hx();
			#src/verb/eval/Make.hx:207: characters 23-27
			$_g2 = 0;
			#src/verb/eval/Make.hx:207: characters 27-35
			$_g3 = $degree + 1;
			#src/verb/eval/Make.hx:207: lines 207-217
			while ($_g2 < $_g3) {
				#src/verb/eval/Make.hx:207: characters 23-35
				$j = $_g2++;
				#src/verb/eval/Make.hx:209: characters 17-47
				$l = 1.0 - $i / $degreeFloat;
				#src/verb/eval/Make.hx:210: characters 17-50
				$p1p2 = Vec::lerp($l, $p1, $p2);
				#src/verb/eval/Make.hx:211: characters 17-50
				$p4p3 = Vec::lerp($l, $p4, $p3);
				#src/verb/eval/Make.hx:213: characters 17-73
				$res = Vec::lerp(1.0 - $j / $degreeFloat, $p1p2, $p4p3);
				#src/verb/eval/Make.hx:214: characters 17-30
				$res->arr[$res->length++] = 1.0;
				#src/verb/eval/Make.hx:216: characters 17-30
				$row->arr[$row->length++] = $res;
			}
			#src/verb/eval/Make.hx:219: characters 13-28
			$pts->arr[$pts->length++] = $row;
		}
		#src/verb/eval/Make.hx:222: characters 8-43
		$zeros = Vec::rep($degree + 1, 0.0);
		#src/verb/eval/Make.hx:223: characters 8-42
		$ones = Vec::rep($degree + 1, 1.0);
		#src/verb/eval/Make.hx:225: characters 53-71
		$tmp = $zeros->concat($ones);
		#src/verb/eval/Make.hx:225: characters 8-98
		return new NurbsSurfaceData($degree, $degree, $tmp, $zeros->concat($ones), $pts);
	}

	/**
	 * @param \Array_hx $curves
	 * @param int $degreeV
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function loftedSurface ($curves, $degreeV = null) {
		#src/verb/eval/Make.hx:125: characters 9-15
		$curves = Modify::unifyCurveKnotVectors($curves);
		#src/verb/eval/Make.hx:128: characters 9-40
		$degreeU = ($curves->arr[0] ?? null)->degree;
		#src/verb/eval/Make.hx:129: characters 9-41
		if ($degreeV === null) {
			#src/verb/eval/Make.hx:129: characters 30-37
			$degreeV = 3;
		}
		#src/verb/eval/Make.hx:130: lines 130-132
		if ($degreeV > ($curves->length - 1)) {
			#src/verb/eval/Make.hx:131: characters 13-20
			$degreeV = $curves->length - 1;
		}
		#src/verb/eval/Make.hx:135: characters 9-49
		$knotsU = ($curves->arr[0] ?? null)->knots;
		#src/verb/eval/Make.hx:137: characters 9-36
		$knotsV = new \Array_hx();
		#src/verb/eval/Make.hx:138: characters 9-53
		$controlPoints = new \Array_hx();
		#src/verb/eval/Make.hx:139: characters 20-24
		$_g = 0;
		#src/verb/eval/Make.hx:139: characters 24-54
		$_g1 = ($curves->arr[0] ?? null)->controlPoints->length;
		#src/verb/eval/Make.hx:139: lines 139-150
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:139: characters 20-54
			$i = $_g++;
			#src/verb/eval/Make.hx:142: lines 142-144
			$result = [];
			$data = $curves->arr;
			$_g_current = 0;
			$_g_length = \count($data);
			$_g_data = $data;
			while ($_g_current < $_g_length) {
				$item = $_g_data[$_g_current++];
				$result[] = ($item->controlPoints->arr[$i] ?? null);
			}
			$points = \Array_hx::wrap($result);
			#src/verb/eval/Make.hx:147: characters 13-71
			$c = Make::rationalInterpCurve($points, $degreeV, true);
			#src/verb/eval/Make.hx:148: characters 13-50
			$controlPoints->arr[$controlPoints->length++] = $c->controlPoints;
			#src/verb/eval/Make.hx:149: characters 13-19
			$knotsV = $c->knots;
		}
		#src/verb/eval/Make.hx:152: characters 9-87
		return new NurbsSurfaceData($degreeU, $degreeV, $knotsU, $knotsV, $controlPoints);
	}

	/**
	 * @param \Array_hx $pts
	 * 
	 * @return NurbsCurveData
	 */
	public static function polyline ($pts) {
		#src/verb/eval/Make.hx:365: characters 9-39
		$knots = \Array_hx::wrap([
			0.0,
			0.0,
		]);
		#src/verb/eval/Make.hx:366: characters 9-24
		$lsum = 0.0;
		#src/verb/eval/Make.hx:368: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:368: characters 23-35
		$_g1 = $pts->length - 1;
		#src/verb/eval/Make.hx:368: lines 368-371
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:368: characters 19-35
			$i = $_g++;
			#src/verb/eval/Make.hx:369: characters 13-49
			$lsum += Vec::dist(($pts->arr[$i] ?? null), ($pts->arr[$i + 1] ?? null));
			#src/verb/eval/Make.hx:370: characters 13-31
			$knots->arr[$knots->length++] = $lsum;
		}
		#src/verb/eval/Make.hx:372: characters 9-27
		$knots->arr[$knots->length++] = $lsum;
		#src/verb/eval/Make.hx:375: characters 9-43
		$knots = Vec::mul(1 / $lsum, $knots);
		#src/verb/eval/Make.hx:377: characters 23-56
		$_g = new \Array_hx();
		#src/verb/eval/Make.hx:377: characters 35-39
		$_g1 = 0;
		#src/verb/eval/Make.hx:377: characters 39-49
		$_g2 = $pts->length;
		#src/verb/eval/Make.hx:377: characters 25-54
		while ($_g1 < $_g2) {
			#src/verb/eval/Make.hx:377: characters 35-49
			$i = $_g1++;
			#src/verb/eval/Make.hx:377: characters 51-54
			$_g->arr[$_g->length++] = 1.0;
		}
		#src/verb/eval/Make.hx:377: characters 9-57
		$weights = $_g;
		#src/verb/eval/Make.hx:379: characters 9-88
		return new NurbsCurveData(1, $knots, Eval_hx::homogenize1d($pts->slice(0), $weights));
	}

	/**
	 * @param \Array_hx $controlPoints
	 * @param \Array_hx $weights
	 * 
	 * @return NurbsCurveData
	 */
	public static function rationalBezierCurve ($controlPoints, $weights = null) {
		#src/verb/eval/Make.hx:174: characters 9-47
		$degree = $controlPoints->length - 1;
		#src/verb/eval/Make.hx:176: characters 9-24
		$knots = new \Array_hx();
		#src/verb/eval/Make.hx:177: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:177: characters 23-31
		$_g1 = $degree + 1;
		#src/verb/eval/Make.hx:177: characters 9-53
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:177: characters 19-31
			$i = $_g++;
			#src/verb/eval/Make.hx:177: characters 35-50
			$knots->arr[$knots->length++] = 0.0;
		}
		#src/verb/eval/Make.hx:178: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:178: characters 23-31
		$_g1 = $degree + 1;
		#src/verb/eval/Make.hx:178: characters 9-53
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:178: characters 19-31
			$i = $_g++;
			#src/verb/eval/Make.hx:178: characters 35-50
			$knots->arr[$knots->length++] = 1.0;
		}
		#src/verb/eval/Make.hx:181: characters 9-76
		if ($weights === null) {
			#src/verb/eval/Make.hx:181: characters 30-76
			$weights = Vec::rep($controlPoints->length, 1.0);
		}
		#src/verb/eval/Make.hx:183: characters 9-95
		return new NurbsCurveData($degree, $knots, Eval_hx::homogenize1d($controlPoints, $weights));
	}

	/**
	 * @param \Array_hx $points
	 * @param int $degree
	 * @param bool $homogeneousPoints
	 * @param \Array_hx $start_tangent
	 * @param \Array_hx $end_tangent
	 * 
	 * @return NurbsCurveData
	 */
	public static function rationalInterpCurve ($points, $degree = 3, $homogeneousPoints = false, $start_tangent = null, $end_tangent = null) {
		#src/verb/eval/Make.hx:635: lines 635-747
		if ($degree === null) {
			$degree = 3;
		}
		if ($homogeneousPoints === null) {
			$homogeneousPoints = false;
		}
		#src/verb/eval/Make.hx:646: lines 646-648
		if ($points->length < ($degree + 1)) {
			#src/verb/eval/Make.hx:647: characters 13-18
			throw Exception::thrown("You need to supply at least degree + 1 points! You only supplied " . ($points->length??'null') . " points.");
		}
		#src/verb/eval/Make.hx:650: characters 9-26
		$us = \Array_hx::wrap([0.0]);
		#src/verb/eval/Make.hx:651: characters 19-23
		$_g = 1;
		#src/verb/eval/Make.hx:651: characters 23-36
		$_g1 = $points->length;
		#src/verb/eval/Make.hx:651: lines 651-655
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:651: characters 19-36
			$i = $_g++;
			#src/verb/eval/Make.hx:652: characters 13-71
			$chord = Vec::norm(Vec::sub(($points->arr[$i] ?? null), ($points->arr[$i - 1] ?? null)));
			#src/verb/eval/Make.hx:653: characters 13-42
			$last = ($us->arr[$us->length - 1] ?? null);
			#src/verb/eval/Make.hx:654: characters 13-36
			$us->arr[$us->length++] = $last + $chord;
		}
		#src/verb/eval/Make.hx:658: characters 9-35
		$max = ($us->arr[$us->length - 1] ?? null);
		#src/verb/eval/Make.hx:659: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:659: characters 23-32
		$_g1 = $us->length;
		#src/verb/eval/Make.hx:659: lines 659-661
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:659: characters 19-32
			$i = $_g++;
			#src/verb/eval/Make.hx:660: characters 13-18
			$us[$i] /= $max;
		}
		#src/verb/eval/Make.hx:663: characters 9-53
		$knotsStart = Vec::rep($degree + 1, 0.0);
		#src/verb/eval/Make.hx:667: characters 9-72
		$hasTangents = ($start_tangent !== null) && ($end_tangent !== null);
		#src/verb/eval/Make.hx:668: characters 9-41
		$start = ($hasTangents ? 0 : 1);
		#src/verb/eval/Make.hx:669: characters 9-77
		$end = ($hasTangents ? $us->length - $degree + 1 : $us->length - $degree);
		#src/verb/eval/Make.hx:671: characters 19-24
		$_g = $start;
		#src/verb/eval/Make.hx:671: characters 27-30
		$_g1 = $end;
		#src/verb/eval/Make.hx:671: lines 671-678
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:671: characters 19-30
			$i = $_g++;
			#src/verb/eval/Make.hx:672: characters 13-34
			$weightSums = 0.0;
			#src/verb/eval/Make.hx:673: characters 23-27
			$_g2 = 0;
			#src/verb/eval/Make.hx:673: characters 27-33
			$_g3 = $degree;
			#src/verb/eval/Make.hx:673: lines 673-675
			while ($_g2 < $_g3) {
				#src/verb/eval/Make.hx:673: characters 23-33
				$j = $_g2++;
				#src/verb/eval/Make.hx:674: characters 17-40
				$weightSums += ($us->arr[$i + $j] ?? null);
			}
			#src/verb/eval/Make.hx:677: characters 13-57
			$knotsStart->arr[$knotsStart->length++] = 1 / $degree * $weightSums;
		}
		#src/verb/eval/Make.hx:680: characters 9-69
		$knots = $knotsStart->concat(Vec::rep($degree + 1, 1.0));
		#src/verb/eval/Make.hx:683: characters 9-20
		$A = new \Array_hx();
		#src/verb/eval/Make.hx:684: characters 9-69
		$n = ($hasTangents ? $points->length + 1 : $points->length - 1);
		#src/verb/eval/Make.hx:686: characters 9-39
		$lst = ($hasTangents ? 1 : 0);
		#src/verb/eval/Make.hx:687: characters 9-92
		$ld = ($hasTangents ? $points->length - ($degree - 1) : $points->length - ($degree + 1));
		#src/verb/eval/Make.hx:689: lines 689-699
		$_g = 0;
		while ($_g < $us->length) {
			#src/verb/eval/Make.hx:689: characters 14-15
			$u = ($us->arr[$_g] ?? null);
			#src/verb/eval/Make.hx:689: lines 689-699
			++$_g;
			#src/verb/eval/Make.hx:690: characters 13-67
			$span = Eval_hx::knotSpanGivenN($n, $degree, $u, $knots);
			#src/verb/eval/Make.hx:691: characters 13-94
			$basisFuncs = Eval_hx::basisFunctionsGivenKnotSpanIndex($span, $u, $degree, $knots);
			#src/verb/eval/Make.hx:693: characters 13-36
			$ls = $span - $degree;
			#src/verb/eval/Make.hx:695: characters 13-46
			$rowstart = Vec::zeros1d($ls);
			#src/verb/eval/Make.hx:696: characters 13-49
			$rowend = Vec::zeros1d($ld - $ls);
			#src/verb/eval/Make.hx:698: characters 13-65
			$x = $rowstart->concat($basisFuncs)->concat($rowend);
			$A->arr[$A->length++] = $x;
		}
		#src/verb/eval/Make.hx:701: lines 701-709
		if ($hasTangents) {
			#src/verb/eval/Make.hx:702: characters 13-38
			$ln = ($A->arr[0] ?? null)->length - 2;
			#src/verb/eval/Make.hx:704: characters 13-74
			$tanRow0 = (\Array_hx::wrap([
				-1.0,
				1.0,
			]))->concat(Vec::zeros1d($ln));
			#src/verb/eval/Make.hx:705: characters 13-74
			$tanRow1 = Vec::zeros1d($ln)->concat(\Array_hx::wrap([
				-1.0,
				1.0,
			]));
			#src/verb/eval/Make.hx:707: characters 13-47
			ArrayExtensions::spliceAndInsert($A, 1, 0, $tanRow0);
			#src/verb/eval/Make.hx:708: characters 13-56
			ArrayExtensions::spliceAndInsert($A, $A->length - 1, 0, $tanRow1);
		}
		#src/verb/eval/Make.hx:712: characters 9-36
		$dim = ($points->arr[0] ?? null)->length;
		#src/verb/eval/Make.hx:713: characters 9-21
		$xs = new \Array_hx();
		#src/verb/eval/Make.hx:715: characters 9-70
		$mult1 = (1 - ($knots->arr[$knots->length - $degree - 2] ?? null)) / $degree;
		#src/verb/eval/Make.hx:716: characters 9-48
		$mult0 = ($knots->arr[$degree + 1] ?? null) / $degree;
		#src/verb/eval/Make.hx:718: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:718: characters 23-26
		$_g1 = $dim;
		#src/verb/eval/Make.hx:718: lines 718-736
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:718: characters 19-26
			$i = $_g++;
			#src/verb/eval/Make.hx:719: characters 13-34
			$b = null;
			#src/verb/eval/Make.hx:721: lines 721-732
			if (!$hasTangents) {
				#src/verb/eval/Make.hx:722: characters 21-60
				$result = [];
				$data = $points->arr;
				$_g_current = 0;
				$_g_length = \count($data);
				$_g_data = $data;
				while ($_g_current < $_g_length) {
					$item = $_g_data[$_g_current++];
					$result[] = ($item->arr[$i] ?? null);
				}
				$b = \Array_hx::wrap($result);
			} else {
				#src/verb/eval/Make.hx:727: characters 17-18
				$b = \Array_hx::wrap([(($points->arr[0] ?? null)->arr[$i] ?? null)]);
				#src/verb/eval/Make.hx:728: characters 25-49
				$tmp = $mult0 * ($start_tangent->arr[$i] ?? null);
				#src/verb/eval/Make.hx:728: characters 17-50
				$b->arr[$b->length++] = $tmp;
				#src/verb/eval/Make.hx:729: characters 27-31
				$_g2 = 1;
				#src/verb/eval/Make.hx:729: characters 31-46
				$_g3 = $points->length - 1;
				#src/verb/eval/Make.hx:729: characters 17-70
				while ($_g2 < $_g3) {
					#src/verb/eval/Make.hx:729: characters 27-46
					$j = $_g2++;
					#src/verb/eval/Make.hx:729: characters 56-68
					$points1 = (($points->arr[$j] ?? null)->arr[$i] ?? null);
					#src/verb/eval/Make.hx:729: characters 48-70
					$b->arr[$b->length++] = $points1;
				}
				#src/verb/eval/Make.hx:730: characters 25-47
				$tmp1 = $mult1 * ($end_tangent->arr[$i] ?? null);
				#src/verb/eval/Make.hx:730: characters 17-49
				$b->arr[$b->length++] = $tmp1;
				#src/verb/eval/Make.hx:731: characters 17-43
				$x = (ArrayExtensions::last($points)->arr[$i] ?? null);
				$b->arr[$b->length++] = $x;
			}
			#src/verb/eval/Make.hx:734: characters 13-39
			$x1 = Mat::solve($A, $b);
			#src/verb/eval/Make.hx:735: characters 13-23
			$xs->arr[$xs->length++] = $x1;
		}
		#src/verb/eval/Make.hx:738: characters 9-58
		$controlPts = Mat::transpose($xs);
		#src/verb/eval/Make.hx:740: lines 740-743
		if (!$homogeneousPoints) {
			#src/verb/eval/Make.hx:741: characters 13-59
			$weights = Vec::rep($controlPts->length, 1.0);
			#src/verb/eval/Make.hx:742: characters 13-23
			$controlPts = Eval_hx::homogenize1d($controlPts, $weights);
		}
		#src/verb/eval/Make.hx:745: characters 9-63
		return new NurbsCurveData($degree, $knots, $controlPts);
	}

	/**
	 * @param NurbsCurveData $profile
	 * @param NurbsCurveData $rail
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function rationalTranslationalSurface ($profile, $rail) {
		#src/verb/eval/Make.hx:45: lines 45-49
		$pt0 = Eval_hx::rationalCurvePoint($rail, ArrayExtensions::first($rail->knots));
		$startu = ArrayExtensions::first($rail->knots);
		$endu = ArrayExtensions::last($rail->knots);
		$numSamples = 2 * $rail->controlPoints->length;
		$span = ($endu - $startu) / ($numSamples - 1);
		#src/verb/eval/Make.hx:51: characters 9-23
		$crvs = new \Array_hx();
		#src/verb/eval/Make.hx:53: characters 20-24
		$_g = 0;
		#src/verb/eval/Make.hx:53: characters 24-34
		$_g1 = $numSamples;
		#src/verb/eval/Make.hx:53: lines 53-60
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:53: characters 20-34
			$i = $_g++;
			#src/verb/eval/Make.hx:55: characters 13-89
			$pt = Vec::sub(Eval_hx::rationalCurvePoint($rail, $startu + $i * $span), $pt0);
			#src/verb/eval/Make.hx:57: characters 13-120
			$crv = Modify::rationalCurveTransform($profile, \Array_hx::wrap([
				\Array_hx::wrap([
					1,
					0,
					0,
					($pt->arr[0] ?? null),
				]),
				\Array_hx::wrap([
					0,
					1,
					0,
					($pt->arr[1] ?? null),
				]),
				\Array_hx::wrap([
					0,
					0,
					1,
					($pt->arr[2] ?? null),
				]),
				\Array_hx::wrap([
					0,
					0,
					0,
					1,
				]),
			]));
			#src/verb/eval/Make.hx:58: characters 13-29
			$crvs->arr[$crvs->length++] = $crv;
		}
		#src/verb/eval/Make.hx:62: characters 9-42
		return Make::loftedSurface($crvs);
	}

	/**
	 * @param NurbsCurveData $profile
	 * @param \Array_hx $center
	 * @param \Array_hx $axis
	 * @param float $theta
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function revolvedSurface ($profile, $center, $axis, $theta) {
		#src/verb/eval/Make.hx:463: lines 463-464
		$prof_controlPoints = Eval_hx::dehomogenize1d($profile->controlPoints);
		$prof_weights = Eval_hx::weight1d($profile->controlPoints);
		#src/verb/eval/Make.hx:466: characters 9-51
		$narcs = null;
		$knotsU = null;
		$controlPoints = null;
		$weights = null;
		#src/verb/eval/Make.hx:468: lines 468-488
		if ($theta <= (\Math::$PI / 2)) {
			#src/verb/eval/Make.hx:469: characters 13-22
			$narcs = 1;
			#src/verb/eval/Make.hx:470: characters 13-55
			$knotsU = Vec::zeros1d(6 + 2 * ($narcs - 1));
		} else if ($theta <= \Math::$PI) {
			#src/verb/eval/Make.hx:473: characters 17-26
			$narcs = 2;
			#src/verb/eval/Make.hx:474: characters 17-58
			$knotsU = Vec::zeros1d(6 + 2 * ($narcs - 1));
			#src/verb/eval/Make.hx:475: characters 17-43
			$knotsU->offsetSet(3, $knotsU->offsetSet(4, 0.5));
		} else if ($theta <= (3 * \Math::$PI / 2)) {
			#src/verb/eval/Make.hx:477: characters 17-26
			$narcs = 3;
			#src/verb/eval/Make.hx:478: characters 17-58
			$knotsU = Vec::zeros1d(6 + 2 * ($narcs - 1));
			#src/verb/eval/Make.hx:479: characters 17-43
			$knotsU->offsetSet(3, $knotsU->offsetSet(4, 0.33333333333333331));
			#src/verb/eval/Make.hx:480: characters 17-43
			$knotsU->offsetSet(5, $knotsU->offsetSet(6, 0.66666666666666663));
		} else {
			#src/verb/eval/Make.hx:482: characters 17-26
			$narcs = 4;
			#src/verb/eval/Make.hx:483: characters 17-58
			$knotsU = Vec::zeros1d(6 + 2 * ($narcs - 1));
			#src/verb/eval/Make.hx:484: characters 17-43
			$knotsU->offsetSet(3, $knotsU->offsetSet(4, 0.25));
			#src/verb/eval/Make.hx:485: characters 17-43
			$knotsU->offsetSet(5, $knotsU->offsetSet(6, 0.5));
			#src/verb/eval/Make.hx:486: characters 17-43
			$knotsU->offsetSet(7, $knotsU->offsetSet(8, 0.75));
		}
		#src/verb/eval/Make.hx:490: lines 490-491
		$dtheta = $theta / $narcs;
		$j = 3 + 2 * ($narcs - 1);
		#src/verb/eval/Make.hx:496: characters 13-28
		$knotsU->offsetSet(0, 0.0);
		#src/verb/eval/Make.hx:497: characters 13-30
		$knotsU->offsetSet($j, 1.0);
		#src/verb/eval/Make.hx:496: characters 13-28
		$knotsU->offsetSet(1, 0.0);
		#src/verb/eval/Make.hx:497: characters 13-30
		$knotsU->offsetSet($j + 1, 1.0);
		#src/verb/eval/Make.hx:496: characters 13-28
		$knotsU->offsetSet(2, 0.0);
		#src/verb/eval/Make.hx:497: characters 13-30
		$knotsU->offsetSet($j + 2, 1.0);
		#src/verb/eval/Make.hx:501: lines 501-507
		$n = 2 * $narcs;
		$wm = \cos($dtheta / 2.0);
		$angle = 0.0;
		$sines = Vec::zeros1d($narcs + 1);
		$cosines = Vec::zeros1d($narcs + 1);
		$controlPoints = Vec::zeros3d(2 * $narcs + 1, $prof_controlPoints->length, 3);
		$weights = Vec::zeros2d(2 * $narcs + 1, $prof_controlPoints->length);
		#src/verb/eval/Make.hx:510: characters 19-23
		$_g = 1;
		#src/verb/eval/Make.hx:510: characters 23-30
		$_g1 = $narcs + 1;
		#src/verb/eval/Make.hx:510: lines 510-514
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:510: characters 19-30
			$i = $_g++;
			#src/verb/eval/Make.hx:511: characters 13-28
			$angle += $dtheta;
			#src/verb/eval/Make.hx:512: characters 13-41
			$cosines->offsetSet($i, \cos($angle));
			#src/verb/eval/Make.hx:513: characters 13-39
			$sines->offsetSet($i, \sin($angle));
		}
		#src/verb/eval/Make.hx:518: characters 19-23
		$_g = 0;
		#src/verb/eval/Make.hx:518: characters 23-48
		$_g1 = $prof_controlPoints->length;
		#src/verb/eval/Make.hx:518: lines 518-577
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:518: characters 19-48
			$j = $_g++;
			#src/verb/eval/Make.hx:521: lines 521-527
			$O = Trig::rayClosestPoint(($prof_controlPoints->arr[$j] ?? null), $center, $axis);
			$X = Vec::sub(($prof_controlPoints->arr[$j] ?? null), $O);
			$r = Vec::norm($X);
			$Y = Vec::cross($axis, $X);
			#src/verb/eval/Make.hx:529: lines 529-532
			if ($r > Constants::$EPSILON) {
				#src/verb/eval/Make.hx:530: characters 17-39
				$X = Vec::mul(1 / $r, $X);
				#src/verb/eval/Make.hx:531: characters 17-39
				$Y = Vec::mul(1 / $r, $Y);
			}
			#src/verb/eval/Make.hx:535: characters 13-56
			($controlPoints->arr[0] ?? null)->offsetSet($j, ($prof_controlPoints->arr[$j] ?? null));
			#src/verb/eval/Make.hx:536: characters 13-44
			$P0 = ($prof_controlPoints->arr[$j] ?? null);
			#src/verb/eval/Make.hx:537: characters 13-44
			($weights->arr[0] ?? null)->offsetSet($j, ($prof_weights->arr[$j] ?? null));
			#src/verb/eval/Make.hx:540: lines 540-542
			$T0 = $Y;
			$index = 0;
			$angle = 0.0;
			#src/verb/eval/Make.hx:545: characters 23-27
			$_g2 = 1;
			#src/verb/eval/Make.hx:545: characters 27-34
			$_g3 = $narcs + 1;
			#src/verb/eval/Make.hx:545: lines 545-576
			while ($_g2 < $_g3) {
				#src/verb/eval/Make.hx:545: characters 23-34
				$i = $_g2++;
				#src/verb/eval/Make.hx:549: characters 17-119
				$P2 = (Boot::equal($r, 0) ? $O : Vec::add($O, Vec::add(Vec::mul($r * ($cosines->arr[$i] ?? null), $X), Vec::mul($r * ($sines->arr[$i] ?? null), $Y))));
				#src/verb/eval/Make.hx:551: characters 17-47
				($controlPoints->arr[$index + 2] ?? null)->offsetSet($j, $P2);
				#src/verb/eval/Make.hx:552: characters 17-54
				($weights->arr[$index + 2] ?? null)->offsetSet($j, ($prof_weights->arr[$j] ?? null));
				#src/verb/eval/Make.hx:555: characters 17-82
				$T2 = Vec::sub(Vec::mul(($cosines->arr[$i] ?? null), $Y), Vec::mul(($sines->arr[$i] ?? null), $X));
				#src/verb/eval/Make.hx:558: lines 558-566
				if (Boot::equal($r, 0)) {
					#src/verb/eval/Make.hx:559: characters 21-50
					($controlPoints->arr[$index + 1] ?? null)->offsetSet($j, $O);
				} else {
					#src/verb/eval/Make.hx:562: characters 21-121
					$inters = Intersect::rays($P0, Vec::mul(1 / Vec::norm($T0), $T0), $P2, Vec::mul(1 / Vec::norm($T2), $T2));
					#src/verb/eval/Make.hx:563: characters 21-67
					$P1 = Vec::add($P0, Vec::mul($inters->u0, $T0));
					#src/verb/eval/Make.hx:565: characters 21-51
					($controlPoints->arr[$index + 1] ?? null)->offsetSet($j, $P1);
				}
				#src/verb/eval/Make.hx:568: characters 17-59
				($weights->arr[$index + 1] ?? null)->offsetSet($j, $wm * ($prof_weights->arr[$j] ?? null));
				#src/verb/eval/Make.hx:570: characters 17-27
				$index += 2;
				#src/verb/eval/Make.hx:572: lines 572-575
				if ($i < $narcs) {
					#src/verb/eval/Make.hx:573: characters 21-28
					$P0 = $P2;
					#src/verb/eval/Make.hx:574: characters 21-28
					$T0 = $T2;
				}
			}
		}
		#src/verb/eval/Make.hx:579: characters 41-55
		$profile1 = $profile->degree;
		#src/verb/eval/Make.hx:579: characters 65-78
		$profile2 = $profile->knots;
		#src/verb/eval/Make.hx:579: characters 9-125
		return new NurbsSurfaceData(2, $profile1, $knotsU, $profile2, Eval_hx::homogenize2d($controlPoints, $weights));
	}

	/**
	 * @param \Array_hx $center
	 * @param \Array_hx $axis
	 * @param \Array_hx $xaxis
	 * @param float $radius
	 * 
	 * @return NurbsSurfaceData
	 */
	public static function sphericalSurface ($center, $axis, $xaxis, $radius) {
		#src/verb/eval/Make.hx:599: characters 9-84
		$arc = Make::arc($center, Vec::mul(-1.0, $axis), $xaxis, $radius, 0.0, \Math::$PI);
		#src/verb/eval/Make.hx:600: characters 9-65
		return Make::revolvedSurface($arc, $center, $axis, 2 * \Math::$PI);
	}

	/**
	 * @param NurbsSurfaceData $surface
	 * 
	 * @return \Array_hx
	 */
	public static function surfaceBoundaryCurves ($surface) {
		#src/verb/eval/Make.hx:74: characters 9-81
		$c0 = Make::surfaceIsocurve($surface, ArrayExtensions::first($surface->knotsU), false);
		#src/verb/eval/Make.hx:75: characters 9-80
		$c1 = Make::surfaceIsocurve($surface, ArrayExtensions::last($surface->knotsU), false);
		#src/verb/eval/Make.hx:76: characters 9-80
		$c2 = Make::surfaceIsocurve($surface, ArrayExtensions::first($surface->knotsV), true);
		#src/verb/eval/Make.hx:77: characters 9-79
		$c3 = Make::surfaceIsocurve($surface, ArrayExtensions::last($surface->knotsV), true);
		#src/verb/eval/Make.hx:79: characters 9-32
		return \Array_hx::wrap([
			$c0,
			$c1,
			$c2,
			$c3,
		]);
	}

	/**
	 * @param NurbsSurfaceData $surface
	 * @param float $u
	 * @param bool $useV
	 * 
	 * @return NurbsCurveData
	 */
	public static function surfaceIsocurve ($surface, $u, $useV = false) {
		#src/verb/eval/Make.hx:83: lines 83-121
		if ($useV === null) {
			$useV = false;
		}
		#src/verb/eval/Make.hx:85: characters 9-60
		$knots = ($useV ? $surface->knotsV : $surface->knotsU);
		#src/verb/eval/Make.hx:86: characters 9-63
		$degree = ($useV ? $surface->degreeV : $surface->degreeU);
		#src/verb/eval/Make.hx:88: characters 9-61
		$knotMults = Analyze::knotMultiplicities($knots);
		#src/verb/eval/Make.hx:91: characters 9-37
		$reqKnotIndex = -1;
		#src/verb/eval/Make.hx:92: characters 20-24
		$_g = 0;
		#src/verb/eval/Make.hx:92: characters 24-40
		$_g1 = $knotMults->length;
		#src/verb/eval/Make.hx:92: lines 92-97
		while ($_g < $_g1) {
			#src/verb/eval/Make.hx:92: characters 20-40
			$i = $_g++;
			#src/verb/eval/Make.hx:93: lines 93-96
			if (\abs($u - ($knotMults->arr[$i] ?? null)->knot) < Constants::$EPSILON) {
				#src/verb/eval/Make.hx:94: characters 17-33
				$reqKnotIndex = $i;
				#src/verb/eval/Make.hx:95: characters 17-22
				break;
			}
		}
		#src/verb/eval/Make.hx:99: characters 9-43
		$numKnotsToInsert = $degree + 1;
		#src/verb/eval/Make.hx:100: lines 100-102
		if ($reqKnotIndex >= 0) {
			#src/verb/eval/Make.hx:101: characters 13-79
			$numKnotsToInsert -= ($knotMults->arr[$reqKnotIndex] ?? null)->mult;
		}
		#src/verb/eval/Make.hx:105: characters 9-127
		$newSrf = ($numKnotsToInsert > 0 ? Modify::surfaceKnotRefine($surface, Vec::rep($numKnotsToInsert, $u), $useV) : $surface);
		#src/verb/eval/Make.hx:108: characters 9-54
		$span = Eval_hx::knotSpan($degree, $u, $knots);
		#src/verb/eval/Make.hx:110: lines 110-114
		if (\abs($u - ArrayExtensions::first($knots)) < Constants::$EPSILON) {
			#src/verb/eval/Make.hx:111: characters 13-21
			$span = 0;
		} else if (\abs($u - ArrayExtensions::last($knots)) < Constants::$EPSILON) {
			#src/verb/eval/Make.hx:113: characters 13-101
			$span = (($useV ? ($newSrf->controlPoints->arr[0] ?? null)->length : $newSrf->controlPoints->length)) - 1;
		}
		#src/verb/eval/Make.hx:116: lines 116-118
		if ($useV) {
			#src/verb/eval/Make.hx:117: characters 40-54
			$newSrf1 = $newSrf->degreeU;
			#src/verb/eval/Make.hx:117: characters 56-69
			$newSrf2 = $newSrf->knotsU;
			#src/verb/eval/Make.hx:117: characters 71-118
			$_g = new \Array_hx();
			#src/verb/eval/Make.hx:117: characters 73-116
			$_g1 = 0;
			$_g2 = $newSrf->controlPoints;
			while ($_g1 < $_g2->length) {
				#src/verb/eval/Make.hx:117: characters 78-81
				$row = ($_g2->arr[$_g1] ?? null);
				#src/verb/eval/Make.hx:117: characters 73-116
				++$_g1;
				#src/verb/eval/Make.hx:117: characters 107-116
				$row1 = ($row->arr[$span] ?? null);
				$_g->arr[$_g->length++] = $row1;
			}
			#src/verb/eval/Make.hx:117: characters 13-119
			return new NurbsCurveData($newSrf1, $newSrf2, $_g);
		}
		#src/verb/eval/Make.hx:120: characters 9-95
		return new NurbsCurveData($newSrf->degreeV, $newSrf->knotsV, ($newSrf->controlPoints->arr[$span] ?? null));
	}
}

Boot::registerClass(Make::class, 'verb.eval.Make');
