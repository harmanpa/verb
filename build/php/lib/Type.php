<?php
/**
 * Generated by Haxe 4.1.4
 */

use \php\Boot;
use \php\_Boot\HxClass;
use \haxe\Exception as HaxeException;
use \php\_Boot\HxClosure;
use \php\_Boot\HxEnum;

/**
 * The Haxe Reflection API allows retrieval of type information at runtime.
 * This class complements the more lightweight Reflect class, with a focus on
 * class and enum instances.
 * @see https://haxe.org/manual/types.html
 * @see https://haxe.org/manual/std-reflection.html
 */
class Type {
	/**
	 * Creates an instance of class `cl`.
	 * This function guarantees that the class constructor is not called.
	 * If `cl` is null, the result is unspecified.
	 * 
	 * @param Class $cl
	 * 
	 * @return mixed
	 */
	public static function createEmptyInstance ($cl) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:131: lines 131-132
		if (Boot::getClass('String') === $cl) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:132: characters 4-18
			return "";
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:133: lines 133-134
		if (Boot::getClass(\Array_hx::class) === $cl) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:134: characters 4-18
			return new \Array_hx();
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:136: characters 3-68
		$reflection = new \ReflectionClass($cl->phpClassName);
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:137: characters 3-52
		return $reflection->newInstanceWithoutConstructor();
	}

	/**
	 * Creates an instance of enum `e` by calling its constructor `constr` with
	 * arguments `params`.
	 * If `e` or `constr` is null, or if enum `e` has no constructor named
	 * `constr`, or if the number of elements in `params` does not match the
	 * expected number of constructor arguments, or if any argument has an
	 * invalid type, the result is unspecified.
	 * 
	 * @param Enum $e
	 * @param string $constr
	 * @param \Array_hx $params
	 * 
	 * @return mixed
	 */
	public static function createEnum ($e, $constr, $params = null) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:141: lines 141-142
		if (($e === null) || ($constr === null)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:142: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:144: characters 3-43
		$phpName = $e->phpClassName;
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:146: lines 146-148
		if (!in_array($constr, $phpName::__hx__list())) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:147: characters 4-9
			throw HaxeException::thrown("No such constructor " . ($constr??'null'));
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:150: characters 3-92
		$paramsCounts = $phpName::__hx__paramsCount();
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:151: lines 151-153
		if ((($params === null) && ($paramsCounts[$constr] !== 0)) || (($params !== null) && ($params->length !== $paramsCounts[$constr]))) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:152: characters 4-9
			throw HaxeException::thrown("Provided parameters count does not match expected parameters count");
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:155: lines 155-160
		if ($params === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:156: characters 4-45
			return $phpName::{$constr}();
		} else {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:158: characters 4-60
			$nativeArgs = $params->arr;
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:159: characters 4-71
			return $phpName::{$constr}(...$nativeArgs);
		}
	}

	/**
	 * Returns the name of class `c`, including its path.
	 * If `c` is inside a package, the package structure is returned dot-
	 * separated, with another dot separating the class name:
	 * `pack1.pack2.(...).packN.ClassName`
	 * If `c` is a sub-type of a Haxe module, that module is not part of the
	 * package structure.
	 * If `c` has no package, the class name is returned.
	 * If `c` is null, the result is unspecified.
	 * The class name does not include any type parameters.
	 * 
	 * @param Class $c
	 * 
	 * @return string
	 */
	public static function getClassName ($c) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:69: lines 69-70
		if ($c === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:70: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:71: characters 3-34
		return Boot::getHaxeName($c);
	}

	/**
	 * Returns a list of the names of all constructors of enum `e`.
	 * The order of the constructor names in the returned Array is preserved
	 * from the original syntax.
	 * If `e` is null, the result is unspecified.
	 * 
	 * @param Enum $e
	 * 
	 * @return \Array_hx
	 */
	public static function getEnumConstructs ($e) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:257: lines 257-258
		if ($e === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:258: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:259: characters 3-66
		return \Array_hx::wrap($e->__hx__list());
	}

	/**
	 * Returns the name of enum `e`, including its path.
	 * If `e` is inside a package, the package structure is returned dot-
	 * separated, with another dot separating the enum name:
	 * `pack1.pack2.(...).packN.EnumName`
	 * If `e` is a sub-type of a Haxe module, that module is not part of the
	 * package structure.
	 * If `e` has no package, the enum name is returned.
	 * If `e` is null, the result is unspecified.
	 * The enum name does not include any type parameters.
	 * 
	 * @param Enum $e
	 * 
	 * @return string
	 */
	public static function getEnumName ($e) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:75: characters 3-30
		return Type::getClassName($e);
	}

	/**
	 * Resolves a class by name.
	 * If `name` is the path of an existing class, that class is returned.
	 * Otherwise null is returned.
	 * If `name` is null or the path to a different type, the result is
	 * unspecified.
	 * The class name must not include any type parameters.
	 * 
	 * @param string $name
	 * 
	 * @return Class
	 */
	public static function resolveClass ($name) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:79: lines 79-80
		if ($name === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:80: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:81: lines 81-96
		if ($name === "Bool") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:89: characters 5-21
			return Boot::getClass('Bool');
		} else if ($name === "Class") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:93: characters 5-22
			return Boot::getClass('Class');
		} else if ($name === "Dynamic") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:83: characters 5-24
			return Boot::getClass('Dynamic');
		} else if ($name === "Enum") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:95: characters 5-21
			return Boot::getClass('Enum');
		} else if ($name === "Float") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:87: characters 5-22
			return Boot::getClass('Float');
		} else if ($name === "Int") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:85: characters 5-20
			return Boot::getClass('Int');
		} else if ($name === "String") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:91: characters 5-18
			return Boot::getClass('String');
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:98: characters 3-40
		$phpClass = Boot::getPhpName($name);
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:99: lines 99-100
		if (!class_exists($phpClass) && !interface_exists($phpClass)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:100: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:102: characters 3-41
		$hxClass = Boot::getClass($phpClass);
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:104: characters 3-22
		return $hxClass;
	}

	/**
	 * Resolves an enum by name.
	 * If `name` is the path of an existing enum, that enum is returned.
	 * Otherwise null is returned.
	 * If `name` is null the result is unspecified.
	 * If `name` is the path to a different type, null is returned.
	 * The enum name must not include any type parameters.
	 * 
	 * @param string $name
	 * 
	 * @return Enum
	 */
	public static function resolveEnum ($name) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:108: lines 108-109
		if ($name === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:109: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:110: lines 110-111
		if ($name === "Bool") {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:111: characters 4-20
			return Boot::getClass('Bool');
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:113: characters 3-40
		$phpClass = Boot::getPhpName($name);
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:114: lines 114-115
		if (!class_exists($phpClass)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:115: characters 4-15
			return null;
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:117: characters 3-41
		$hxClass = Boot::getClass($phpClass);
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:119: characters 3-22
		return $hxClass;
	}

	/**
	 * Returns the runtime type of value `v`.
	 * The result corresponds to the type `v` has at runtime, which may vary
	 * per platform. Assumptions regarding this should be minimized to avoid
	 * surprises.
	 * 
	 * @param mixed $v
	 * 
	 * @return \ValueType
	 */
	public static function typeof ($v) {
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:263: lines 263-264
		if ($v === null) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:264: characters 4-16
			return \ValueType::TNull();
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:266: lines 266-278
		if (is_object($v)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:267: lines 267-268
			if (($v instanceof \Closure) || ($v instanceof HxClosure)) {
				#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:268: characters 5-21
				return \ValueType::TFunction();
			}
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:269: lines 269-270
			if (($v instanceof \StdClass)) {
				#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:270: characters 5-19
				return \ValueType::TObject();
			}
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:271: lines 271-272
			if (($v instanceof HxClass)) {
				#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:272: characters 5-19
				return \ValueType::TObject();
			}
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:274: characters 4-53
			$hxClass = Boot::getClass(get_class($v));
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:275: lines 275-276
			if (($v instanceof HxEnum)) {
				#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:276: characters 5-31
				return \ValueType::TEnum($hxClass);
			}
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:277: characters 4-31
			return \ValueType::TClass($hxClass);
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:280: lines 280-281
		if (is_bool($v)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:281: characters 4-16
			return \ValueType::TBool();
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:282: lines 282-283
		if (is_int($v)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:283: characters 4-15
			return \ValueType::TInt();
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:284: lines 284-285
		if (is_float($v)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:285: characters 4-17
			return \ValueType::TFloat();
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:286: lines 286-287
		if (is_string($v)) {
			#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:287: characters 4-25
			return \ValueType::TClass(Boot::getClass('String'));
		}
		#C:\Tools\HaxeToolkit\haxe\std/php/_std/Type.hx:289: characters 3-18
		return \ValueType::TUnknown();
	}
}

Boot::registerClass(Type::class, 'Type');
