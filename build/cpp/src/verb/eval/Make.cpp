// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_CurveCurveIntersection
#include <verb/core/CurveCurveIntersection.h>
#endif
#ifndef INCLUDED_verb_core_Mat
#include <verb/core/Mat.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_Trig
#include <verb/core/Trig.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_Analyze
#include <verb/eval/Analyze.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif
#ifndef INCLUDED_verb_eval_Intersect
#include <verb/eval/Intersect.h>
#endif
#ifndef INCLUDED_verb_eval_KnotMultiplicity
#include <verb/eval/KnotMultiplicity.h>
#endif
#ifndef INCLUDED_verb_eval_Make
#include <verb/eval/Make.h>
#endif
#ifndef INCLUDED_verb_eval_Modify
#include <verb/eval/Modify.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_43_rationalTranslationalSurface,"verb.eval.Make","rationalTranslationalSurface",0x5c4bce3c,"verb.eval.Make.rationalTranslationalSurface","verb/eval/Make.hx",43,0x79d8136d)
static const Float _hx_array_data_a0e56f91_2[] = {
	(Float)0,(Float)0,(Float)0,(Float)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_71_surfaceBoundaryCurves,"verb.eval.Make","surfaceBoundaryCurves",0xb2d0a5de,"verb.eval.Make.surfaceBoundaryCurves","verb/eval/Make.hx",71,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_83_surfaceIsocurve,"verb.eval.Make","surfaceIsocurve",0x69bfddba,"verb.eval.Make.surfaceIsocurve","verb/eval/Make.hx",83,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_123_loftedSurface,"verb.eval.Make","loftedSurface",0x24b43d40,"verb.eval.Make.loftedSurface","verb/eval/Make.hx",123,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_156_clonedCurve,"verb.eval.Make","clonedCurve",0xf232006b,"verb.eval.Make.clonedCurve","verb/eval/Make.hx",156,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_172_rationalBezierCurve,"verb.eval.Make","rationalBezierCurve",0xc7d688a5,"verb.eval.Make.rationalBezierCurve","verb/eval/Make.hx",172,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_199_fourPointSurface,"verb.eval.Make","fourPointSurface",0x57b0ae40,"verb.eval.Make.fourPointSurface","verb/eval/Make.hx",199,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_243_ellipseArc,"verb.eval.Make","ellipseArc",0x21f821d1,"verb.eval.Make.ellipseArc","verb/eval/Make.hx",243,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_350_arc,"verb.eval.Make","arc",0x8d94daf5,"verb.eval.Make.arc","verb/eval/Make.hx",350,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_363_polyline,"verb.eval.Make","polyline",0xe59e20bd,"verb.eval.Make.polyline","verb/eval/Make.hx",363,0x79d8136d)
static const Float _hx_array_data_a0e56f91_24[] = {
	0.0,0.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_395_extrudedSurface,"verb.eval.Make","extrudedSurface",0xd2fcf771,"verb.eval.Make.extrudedSurface","verb/eval/Make.hx",395,0x79d8136d)
static const Float _hx_array_data_a0e56f91_27[] = {
	(Float)0,(Float)0,(Float)0,(Float)1,(Float)1,(Float)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_435_cylindricalSurface,"verb.eval.Make","cylindricalSurface",0xf0abd41c,"verb.eval.Make.cylindricalSurface","verb/eval/Make.hx",435,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_461_revolvedSurface,"verb.eval.Make","revolvedSurface",0xb4943ebb,"verb.eval.Make.revolvedSurface","verb/eval/Make.hx",461,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_597_sphericalSurface,"verb.eval.Make","sphericalSurface",0x512c1f8d,"verb.eval.Make.sphericalSurface","verb/eval/Make.hx",597,0x79d8136d)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_618_conicalSurface,"verb.eval.Make","conicalSurface",0xdb2e08a3,"verb.eval.Make.conicalSurface","verb/eval/Make.hx",618,0x79d8136d)
static const Float _hx_array_data_a0e56f91_35[] = {
	0.0,0.0,1.0,1.0,
};
static const Float _hx_array_data_a0e56f91_36[] = {
	1.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b6ec46f953fc72f4_635_rationalInterpCurve,"verb.eval.Make","rationalInterpCurve",0x89f7bed0,"verb.eval.Make.rationalInterpCurve","verb/eval/Make.hx",635,0x79d8136d)
static const Float _hx_array_data_a0e56f91_46[] = {
	0.0,
};
static const Float _hx_array_data_a0e56f91_47[] = {
	-1.0,1.0,
};
static const Float _hx_array_data_a0e56f91_48[] = {
	-1.0,1.0,
};
namespace verb{
namespace eval{

void Make_obj::__construct() { }

Dynamic Make_obj::__CreateEmpty() { return new Make_obj; }

void *Make_obj::_hx_vtable = 0;

Dynamic Make_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Make_obj > _hx_result = new Make_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Make_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x02effe09;
}

 ::verb::core::NurbsSurfaceData Make_obj::rationalTranslationalSurface( ::verb::core::NurbsCurveData profile, ::verb::core::NurbsCurveData rail){
            	HX_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_43_rationalTranslationalSurface)
HXLINE(  45)		::Array< Float > pt0 = ::verb::eval::Eval_obj::rationalCurvePoint(rail,( (Float)(::verb::core::ArrayExtensions_obj::first(rail->knots)) ));
HXDLIN(  45)		Float startu = ( (Float)(::verb::core::ArrayExtensions_obj::first(rail->knots)) );
HXDLIN(  45)		Float endu = ( (Float)(::verb::core::ArrayExtensions_obj::last(rail->knots)) );
HXDLIN(  45)		int numSamples = (2 * rail->controlPoints->length);
HXDLIN(  45)		Float span = ((endu - startu) / ( (Float)((numSamples - 1)) ));
HXLINE(  51)		::Array< ::Dynamic> crvs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  53)		{
HXLINE(  53)			int _g = 0;
HXDLIN(  53)			int _g1 = numSamples;
HXDLIN(  53)			while((_g < _g1)){
HXLINE(  53)				_g = (_g + 1);
HXDLIN(  53)				int i = (_g - 1);
HXLINE(  55)				::Array< Float > pt = ::verb::core::Vec_obj::sub(::verb::eval::Eval_obj::rationalCurvePoint(rail,(startu + (( (Float)(i) ) * span))),pt0);
HXLINE(  57)				 ::verb::core::NurbsCurveData crv = ::verb::eval::Modify_obj::rationalCurveTransform(profile,::Array_obj< ::Dynamic>::__new(4)->init(0,::Array_obj< Float >::__new(4)->init(0,1)->init(1,0)->init(2,0)->init(3,pt->__get(0)))->init(1,::Array_obj< Float >::__new(4)->init(0,0)->init(1,1)->init(2,0)->init(3,pt->__get(1)))->init(2,::Array_obj< Float >::__new(4)->init(0,0)->init(1,0)->init(2,1)->init(3,pt->__get(2)))->init(3,::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_2,4)));
HXLINE(  58)				crvs->push(crv);
            			}
            		}
HXLINE(  62)		return ::verb::eval::Make_obj::loftedSurface(crvs,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Make_obj,rationalTranslationalSurface,return )

::Array< ::Dynamic> Make_obj::surfaceBoundaryCurves( ::verb::core::NurbsSurfaceData surface){
            	HX_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_71_surfaceBoundaryCurves)
HXLINE(  74)		 ::verb::core::NurbsCurveData c0 = ::verb::eval::Make_obj::surfaceIsocurve(surface,( (Float)(::verb::core::ArrayExtensions_obj::first(surface->knotsU)) ),false);
HXLINE(  75)		 ::verb::core::NurbsCurveData c1 = ::verb::eval::Make_obj::surfaceIsocurve(surface,( (Float)(::verb::core::ArrayExtensions_obj::last(surface->knotsU)) ),false);
HXLINE(  76)		 ::verb::core::NurbsCurveData c2 = ::verb::eval::Make_obj::surfaceIsocurve(surface,( (Float)(::verb::core::ArrayExtensions_obj::first(surface->knotsV)) ),true);
HXLINE(  77)		 ::verb::core::NurbsCurveData c3 = ::verb::eval::Make_obj::surfaceIsocurve(surface,( (Float)(::verb::core::ArrayExtensions_obj::last(surface->knotsV)) ),true);
HXLINE(  79)		return ::Array_obj< ::Dynamic>::__new(4)->init(0,c0)->init(1,c1)->init(2,c2)->init(3,c3);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Make_obj,surfaceBoundaryCurves,return )

 ::verb::core::NurbsCurveData Make_obj::surfaceIsocurve( ::verb::core::NurbsSurfaceData surface,Float u,::hx::Null< bool >  __o_useV){
            		bool useV = __o_useV.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_83_surfaceIsocurve)
HXLINE(  85)		::Array< Float > knots;
HXDLIN(  85)		if (useV) {
HXLINE(  85)			knots = surface->knotsV;
            		}
            		else {
HXLINE(  85)			knots = surface->knotsU;
            		}
HXLINE(  86)		int degree;
HXDLIN(  86)		if (useV) {
HXLINE(  86)			degree = surface->degreeV;
            		}
            		else {
HXLINE(  86)			degree = surface->degreeU;
            		}
HXLINE(  88)		::Array< ::Dynamic> knotMults = ::verb::eval::Analyze_obj::knotMultiplicities(knots);
HXLINE(  91)		int reqKnotIndex = -1;
HXLINE(  92)		{
HXLINE(  92)			int _g = 0;
HXDLIN(  92)			int _g1 = knotMults->length;
HXDLIN(  92)			while((_g < _g1)){
HXLINE(  92)				_g = (_g + 1);
HXDLIN(  92)				int i = (_g - 1);
HXLINE(  93)				if ((::Math_obj::abs((u - knotMults->__get(i).StaticCast<  ::verb::eval::KnotMultiplicity >()->knot)) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE(  94)					reqKnotIndex = i;
HXLINE(  95)					goto _hx_goto_4;
            				}
            			}
            			_hx_goto_4:;
            		}
HXLINE(  99)		int numKnotsToInsert = (degree + 1);
HXLINE( 100)		if ((reqKnotIndex >= 0)) {
HXLINE( 101)			numKnotsToInsert = (numKnotsToInsert - knotMults->__get(reqKnotIndex).StaticCast<  ::verb::eval::KnotMultiplicity >()->mult);
            		}
HXLINE( 105)		 ::verb::core::NurbsSurfaceData newSrf;
HXDLIN( 105)		if ((numKnotsToInsert > 0)) {
HXLINE( 105)			newSrf = ::verb::eval::Modify_obj::surfaceKnotRefine(surface,::verb::core::Vec_obj::rep(numKnotsToInsert,u),useV);
            		}
            		else {
HXLINE( 105)			newSrf = surface;
            		}
HXLINE( 108)		int span = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXLINE( 110)		Float _hx_tmp = ::Math_obj::abs((u - ( (Float)(::verb::core::ArrayExtensions_obj::first(knots)) )));
HXDLIN( 110)		if ((_hx_tmp < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 111)			span = 0;
            		}
            		else {
HXLINE( 112)			Float _hx_tmp = ::Math_obj::abs((u - ( (Float)(::verb::core::ArrayExtensions_obj::last(knots)) )));
HXDLIN( 112)			if ((_hx_tmp < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 113)				int span1;
HXDLIN( 113)				if (useV) {
HXLINE( 113)					span1 = newSrf->controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length;
            				}
            				else {
HXLINE( 113)					span1 = newSrf->controlPoints->length;
            				}
HXDLIN( 113)				span = (span1 - 1);
            			}
            		}
HXLINE( 116)		if (useV) {
HXLINE( 117)			int newSrf1 = newSrf->degreeU;
HXDLIN( 117)			::Array< Float > newSrf2 = newSrf->knotsU;
HXDLIN( 117)			::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 117)			{
HXLINE( 117)				int _g1 = 0;
HXDLIN( 117)				::Array< ::Dynamic> _g2 = newSrf->controlPoints;
HXDLIN( 117)				while((_g1 < _g2->length)){
HXLINE( 117)					::Array< ::Dynamic> row = _g2->__get(_g1).StaticCast< ::Array< ::Dynamic> >();
HXDLIN( 117)					_g1 = (_g1 + 1);
HXDLIN( 117)					_g->push(row->__get(span).StaticCast< ::Array< Float > >());
            				}
            			}
HXDLIN( 117)			return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,newSrf1,newSrf2,_g);
            		}
HXLINE( 120)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,newSrf->degreeV,newSrf->knotsV,newSrf->controlPoints->__get(span).StaticCast< ::Array< ::Dynamic> >());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Make_obj,surfaceIsocurve,return )

 ::verb::core::NurbsSurfaceData Make_obj::loftedSurface(::Array< ::Dynamic> curves, ::Dynamic degreeV){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_123_loftedSurface)
HXLINE( 125)		curves = ::verb::eval::Modify_obj::unifyCurveKnotVectors(curves);
HXLINE( 128)		int degreeU = curves->__get(0).StaticCast<  ::verb::core::NurbsCurveData >()->degree;
HXLINE( 129)		if (::hx::IsNull( degreeV )) {
HXLINE( 129)			degreeV = 3;
            		}
HXLINE( 130)		if (::hx::IsGreater( degreeV,(curves->length - 1) )) {
HXLINE( 131)			degreeV = (curves->length - 1);
            		}
HXLINE( 135)		::Array< Float > knotsU = curves->__get(0).StaticCast<  ::verb::core::NurbsCurveData >()->knots;
HXLINE( 137)		::Array< Float > knotsV = ::Array_obj< Float >::__new(0);
HXLINE( 138)		::Array< ::Dynamic> controlPoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 139)		{
HXLINE( 139)			int _g = 0;
HXDLIN( 139)			int _g1 = curves->__get(0).StaticCast<  ::verb::core::NurbsCurveData >()->controlPoints->length;
HXDLIN( 139)			while((_g < _g1)){
HXLINE( 139)				_g = (_g + 1);
HXDLIN( 139)				int i = (_g - 1);
HXLINE( 142)				::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(curves->length);
HXDLIN( 142)				{
HXLINE( 142)					int _g1 = 0;
HXDLIN( 142)					int _g2 = curves->length;
HXDLIN( 142)					while((_g1 < _g2)){
HXLINE( 142)						_g1 = (_g1 + 1);
HXDLIN( 142)						int i1 = (_g1 - 1);
HXDLIN( 142)						{
HXLINE( 142)							::Array< Float > inValue = ( ( ::verb::core::NurbsCurveData)(_hx_array_unsafe_get(curves,i1)) )->controlPoints->__get(i).StaticCast< ::Array< Float > >();
HXDLIN( 142)							result->__unsafe_set(i1,inValue);
            						}
            					}
            				}
HXDLIN( 142)				::Array< ::Dynamic> points = result;
HXLINE( 147)				 ::verb::core::NurbsCurveData c = ::verb::eval::Make_obj::rationalInterpCurve(points,degreeV,true,null(),null());
HXLINE( 148)				controlPoints->push(c->controlPoints);
HXLINE( 149)				knotsV = c->knots;
            			}
            		}
HXLINE( 152)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,degreeU,( (int)(degreeV) ),knotsU,knotsV,controlPoints);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Make_obj,loftedSurface,return )

 ::verb::core::NurbsCurveData Make_obj::clonedCurve( ::verb::core::NurbsCurveData curve){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_156_clonedCurve)
HXDLIN( 156)		int curve1 = curve->degree;
HXDLIN( 156)		::Array< Float > _hx_tmp = curve->knots->copy();
HXDLIN( 156)		::Array< ::Dynamic> _this = curve->controlPoints;
HXDLIN( 156)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(_this->length);
HXDLIN( 156)		{
HXDLIN( 156)			int _g = 0;
HXDLIN( 156)			int _g1 = _this->length;
HXDLIN( 156)			while((_g < _g1)){
HXDLIN( 156)				_g = (_g + 1);
HXDLIN( 156)				int i = (_g - 1);
HXDLIN( 156)				{
HXDLIN( 156)					::Array< Float > inValue = ( (::Array< Float >)(_hx_array_unsafe_get(_this,i)) )->copy();
HXDLIN( 156)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN( 156)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,curve1,_hx_tmp,result);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Make_obj,clonedCurve,return )

 ::verb::core::NurbsCurveData Make_obj::rationalBezierCurve(::Array< ::Dynamic> controlPoints,::Array< Float > weights){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_172_rationalBezierCurve)
HXLINE( 174)		int degree = (controlPoints->length - 1);
HXLINE( 176)		::Array< Float > knots = ::Array_obj< Float >::__new(0);
HXLINE( 177)		{
HXLINE( 177)			int _g = 0;
HXDLIN( 177)			int _g1 = (degree + 1);
HXDLIN( 177)			while((_g < _g1)){
HXLINE( 177)				_g = (_g + 1);
HXDLIN( 177)				int i = (_g - 1);
HXDLIN( 177)				knots->push(((Float)0.0));
            			}
            		}
HXLINE( 178)		{
HXLINE( 178)			int _g2 = 0;
HXDLIN( 178)			int _g3 = (degree + 1);
HXDLIN( 178)			while((_g2 < _g3)){
HXLINE( 178)				_g2 = (_g2 + 1);
HXDLIN( 178)				int i = (_g2 - 1);
HXDLIN( 178)				knots->push(((Float)1.0));
            			}
            		}
HXLINE( 181)		if (::hx::IsNull( weights )) {
HXLINE( 181)			weights = ::verb::core::Vec_obj::rep(controlPoints->length,((Float)1.0));
            		}
HXLINE( 183)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots,::verb::eval::Eval_obj::homogenize1d(controlPoints,weights));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Make_obj,rationalBezierCurve,return )

 ::verb::core::NurbsSurfaceData Make_obj::fourPointSurface(::Array< Float > p1,::Array< Float > p2,::Array< Float > p3,::Array< Float > p4,::hx::Null< int >  __o_degree){
            		int degree = __o_degree.Default(3);
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_199_fourPointSurface)
HXLINE( 201)		Float degreeFloat = ( (Float)(degree) );
HXLINE( 203)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 204)		{
HXLINE( 204)			int _g = 0;
HXDLIN( 204)			int _g1 = (degree + 1);
HXDLIN( 204)			while((_g < _g1)){
HXLINE( 204)				_g = (_g + 1);
HXDLIN( 204)				int i = (_g - 1);
HXLINE( 206)				::Array< ::Dynamic> row = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 207)				{
HXLINE( 207)					int _g1 = 0;
HXDLIN( 207)					int _g2 = (degree + 1);
HXDLIN( 207)					while((_g1 < _g2)){
HXLINE( 207)						_g1 = (_g1 + 1);
HXDLIN( 207)						int j = (_g1 - 1);
HXLINE( 209)						Float l = (((Float)1.0) - (( (Float)(i) ) / degreeFloat));
HXLINE( 210)						::Array< Float > p1p2 = ::verb::core::Vec_obj::lerp(l,p1,p2);
HXLINE( 211)						::Array< Float > p4p3 = ::verb::core::Vec_obj::lerp(l,p4,p3);
HXLINE( 213)						::Array< Float > res = ::verb::core::Vec_obj::lerp((((Float)1.0) - (( (Float)(j) ) / degreeFloat)),p1p2,p4p3);
HXLINE( 214)						res->push(((Float)1.0));
HXLINE( 216)						row->push(res);
            					}
            				}
HXLINE( 219)				pts->push(row);
            			}
            		}
HXLINE( 222)		::Array< Float > zeros = ::verb::core::Vec_obj::rep((degree + 1),((Float)0.0));
HXLINE( 223)		::Array< Float > ones = ::verb::core::Vec_obj::rep((degree + 1),((Float)1.0));
HXLINE( 225)		::Array< Float > _hx_tmp = zeros->concat(ones);
HXDLIN( 225)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,degree,degree,_hx_tmp,zeros->concat(ones),pts);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Make_obj,fourPointSurface,return )

 ::verb::core::NurbsCurveData Make_obj::ellipseArc(::Array< Float > center,::Array< Float > xaxis,::Array< Float > yaxis,Float startAngle,Float endAngle){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_243_ellipseArc)
HXLINE( 245)		Float xradius = ::verb::core::Vec_obj::norm(xaxis);
HXLINE( 246)		Float yradius = ::verb::core::Vec_obj::norm(yaxis);
HXLINE( 248)		xaxis = ::verb::core::Vec_obj::normalized(xaxis);
HXLINE( 249)		yaxis = ::verb::core::Vec_obj::normalized(yaxis);
HXLINE( 252)		if ((endAngle < startAngle)) {
HXLINE( 252)			endAngle = ((((Float)2.0) * ::Math_obj::PI) + startAngle);
            		}
HXLINE( 254)		Float theta = (endAngle - startAngle);
HXDLIN( 254)		int numArcs = 0;
HXLINE( 258)		if ((theta <= (::Math_obj::PI / ( (Float)(2) )))) {
HXLINE( 259)			numArcs = 1;
            		}
            		else {
HXLINE( 261)			if ((theta <= ::Math_obj::PI)) {
HXLINE( 262)				numArcs = 2;
            			}
            			else {
HXLINE( 263)				if ((theta <= ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) )))) {
HXLINE( 264)					numArcs = 3;
            				}
            				else {
HXLINE( 266)					numArcs = 4;
            				}
            			}
            		}
HXLINE( 270)		Float dtheta = (theta / ( (Float)(numArcs) ));
HXDLIN( 270)		int n = (2 * numArcs);
HXDLIN( 270)		Float w1 = ::Math_obj::cos((dtheta / ( (Float)(2) )));
HXLINE( 273)		::Array< Float > P0 = ::verb::core::Vec_obj::mul((xradius * ::Math_obj::cos(startAngle)),xaxis);
HXLINE( 270)		::Array< Float > P01 = ::verb::core::Vec_obj::add(center,::verb::core::Vec_obj::add(P0,::verb::core::Vec_obj::mul((yradius * ::Math_obj::sin(startAngle)),yaxis)));
HXLINE( 274)		::Array< Float > T0 = ::verb::core::Vec_obj::mul(::Math_obj::cos(startAngle),yaxis);
HXLINE( 270)		::Array< Float > T01 = ::verb::core::Vec_obj::sub(T0,::verb::core::Vec_obj::mul(::Math_obj::sin(startAngle),xaxis));
HXDLIN( 270)		::Array< ::Dynamic> controlPoints = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 270)		::Array< Float > knots = ::verb::core::Vec_obj::zeros1d(((2 * numArcs) + 3));
HXDLIN( 270)		int index = 0;
HXDLIN( 270)		Float angle = startAngle;
HXDLIN( 270)		::Array< Float > weights = ::verb::core::Vec_obj::zeros1d((numArcs * 2));
HXLINE( 281)		controlPoints[0] = P01;
HXLINE( 282)		weights[0] = ((Float)1.0);
HXLINE( 284)		{
HXLINE( 284)			int _g = 1;
HXDLIN( 284)			int _g1 = (numArcs + 1);
HXDLIN( 284)			while((_g < _g1)){
HXLINE( 284)				_g = (_g + 1);
HXDLIN( 284)				int i = (_g - 1);
HXLINE( 286)				angle = (angle + dtheta);
HXLINE( 288)				::Array< Float > P2 = ::verb::core::Vec_obj::mul((xradius * ::Math_obj::cos(angle)),xaxis);
HXLINE( 287)				::Array< Float > P21 = ::verb::core::Vec_obj::add(center,::verb::core::Vec_obj::add(P2,::verb::core::Vec_obj::mul((yradius * ::Math_obj::sin(angle)),yaxis)));
HXLINE( 290)				weights[(index + 2)] = ( (Float)(1) );
HXLINE( 291)				controlPoints[(index + 2)] = P21;
HXLINE( 293)				::Array< Float > T2 = ::verb::core::Vec_obj::mul(::Math_obj::cos(angle),yaxis);
HXDLIN( 293)				::Array< Float > T21 = ::verb::core::Vec_obj::sub(T2,::verb::core::Vec_obj::mul(::Math_obj::sin(angle),xaxis));
HXLINE( 295)				::Array< Float > inters = ::verb::core::Vec_obj::mul((( (Float)(1) ) / ::verb::core::Vec_obj::norm(T01)),T01);
HXDLIN( 295)				 ::verb::core::CurveCurveIntersection inters1 = ::verb::eval::Intersect_obj::rays(P01,inters,P21,::verb::core::Vec_obj::mul((( (Float)(1) ) / ::verb::core::Vec_obj::norm(T21)),T21));
HXLINE( 296)				::Array< Float > P1 = ::verb::core::Vec_obj::add(P01,::verb::core::Vec_obj::mul(inters1->u0,T01));
HXLINE( 298)				weights[(index + 1)] = w1;
HXLINE( 299)				controlPoints[(index + 1)] = P1;
HXLINE( 301)				index = (index + 2);
HXLINE( 303)				if ((i < numArcs)) {
HXLINE( 304)					P01 = P21;
HXLINE( 305)					T01 = T21;
            				}
            			}
            		}
HXLINE( 309)		int j = ((2 * numArcs) + 1);
HXLINE( 311)		{
HXLINE( 311)			{
HXLINE( 312)				knots[0] = ((Float)0.0);
HXLINE( 313)				knots[j] = ((Float)1.0);
            			}
HXLINE( 311)			{
HXLINE( 312)				knots[1] = ((Float)0.0);
HXLINE( 313)				knots[(1 + j)] = ((Float)1.0);
            			}
HXLINE( 311)			{
HXLINE( 312)				knots[2] = ((Float)0.0);
HXLINE( 313)				knots[(2 + j)] = ((Float)1.0);
            			}
            		}
HXLINE( 316)		switch((int)(numArcs)){
            			case (int)2: {
HXLINE( 318)				knots[3] = (knots[4] = ((Float)0.5));
            			}
            			break;
            			case (int)3: {
HXLINE( 320)				knots[3] = (knots[4] = ((Float)0.33333333333333331));
HXLINE( 321)				knots[5] = (knots[6] = ((Float)0.66666666666666663));
            			}
            			break;
            			case (int)4: {
HXLINE( 323)				knots[3] = (knots[4] = ((Float)0.25));
HXLINE( 324)				knots[5] = (knots[6] = ((Float)0.5));
HXLINE( 325)				knots[7] = (knots[8] = ((Float)0.75));
            			}
            			break;
            		}
HXLINE( 328)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,2,knots,::verb::eval::Eval_obj::homogenize1d(controlPoints,weights));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Make_obj,ellipseArc,return )

 ::verb::core::NurbsCurveData Make_obj::arc(::Array< Float > center,::Array< Float > xaxis,::Array< Float > yaxis,Float radius,Float startAngle,Float endAngle){
            	HX_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_350_arc)
HXDLIN( 350)		::Array< Float > _hx_tmp = ::verb::core::Vec_obj::mul(radius,::verb::core::Vec_obj::normalized(xaxis));
HXDLIN( 350)		return ::verb::eval::Make_obj::ellipseArc(center,_hx_tmp,::verb::core::Vec_obj::mul(radius,::verb::core::Vec_obj::normalized(yaxis)),startAngle,endAngle);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Make_obj,arc,return )

 ::verb::core::NurbsCurveData Make_obj::polyline(::Array< ::Dynamic> pts){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_363_polyline)
HXLINE( 365)		::Array< Float > knots = ::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_24,2);
HXLINE( 366)		Float lsum = ((Float)0.0);
HXLINE( 368)		{
HXLINE( 368)			int _g = 0;
HXDLIN( 368)			int _g1 = (pts->length - 1);
HXDLIN( 368)			while((_g < _g1)){
HXLINE( 368)				_g = (_g + 1);
HXDLIN( 368)				int i = (_g - 1);
HXLINE( 369)				lsum = (lsum + ::verb::core::Vec_obj::dist(pts->__get(i).StaticCast< ::Array< Float > >(),pts->__get((i + 1)).StaticCast< ::Array< Float > >()));
HXLINE( 370)				knots->push(lsum);
            			}
            		}
HXLINE( 372)		knots->push(lsum);
HXLINE( 375)		knots = ::verb::core::Vec_obj::mul((( (Float)(1) ) / lsum),knots);
HXLINE( 377)		::Array< Float > _g2 = ::Array_obj< Float >::__new(0);
HXDLIN( 377)		{
HXLINE( 377)			int _g3 = 0;
HXDLIN( 377)			int _g4 = pts->length;
HXDLIN( 377)			while((_g3 < _g4)){
HXLINE( 377)				_g3 = (_g3 + 1);
HXDLIN( 377)				int i = (_g3 - 1);
HXDLIN( 377)				_g2->push(((Float)1.0));
            			}
            		}
HXDLIN( 377)		::Array< Float > weights = _g2;
HXLINE( 379)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,1,knots,::verb::eval::Eval_obj::homogenize1d(pts->slice(0,null()),weights));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Make_obj,polyline,return )

 ::verb::core::NurbsSurfaceData Make_obj::extrudedSurface(::Array< Float > axis,Float length, ::verb::core::NurbsCurveData profile){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_395_extrudedSurface)
HXLINE( 397)		::Array< ::Dynamic> controlPoints = ::Array_obj< ::Dynamic>::__new(3)->init(0,::Array_obj< ::Dynamic>::__new(0))->init(1,::Array_obj< ::Dynamic>::__new(0))->init(2,::Array_obj< ::Dynamic>::__new(0));
HXLINE( 398)		::Array< ::Dynamic> weights = ::Array_obj< ::Dynamic>::__new(3)->init(0,::Array_obj< Float >::__new(0))->init(1,::Array_obj< Float >::__new(0))->init(2,::Array_obj< Float >::__new(0));
HXLINE( 400)		::Array< ::Dynamic> prof_controlPoints = ::verb::eval::Eval_obj::dehomogenize1d(profile->controlPoints);
HXLINE( 401)		::Array< Float > prof_weights = ::verb::eval::Eval_obj::weight1d(profile->controlPoints);
HXLINE( 403)		::Array< Float > translation = ::verb::core::Vec_obj::mul(length,axis);
HXLINE( 404)		::Array< Float > halfTranslation = ::verb::core::Vec_obj::mul((((Float)0.5) * length),axis);
HXLINE( 407)		{
HXLINE( 407)			int _g = 0;
HXDLIN( 407)			int _g1 = prof_controlPoints->length;
HXDLIN( 407)			while((_g < _g1)){
HXLINE( 407)				_g = (_g + 1);
HXDLIN( 407)				int j = (_g - 1);
HXLINE( 409)				controlPoints->__get(2).StaticCast< ::Array< ::Dynamic> >()[j] = prof_controlPoints->__get(j).StaticCast< ::Array< Float > >();
HXLINE( 410)				controlPoints->__get(1).StaticCast< ::Array< ::Dynamic> >()[j] = ::verb::core::Vec_obj::add(halfTranslation,prof_controlPoints->__get(j).StaticCast< ::Array< Float > >());
HXLINE( 411)				controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()[j] = ::verb::core::Vec_obj::add(translation,prof_controlPoints->__get(j).StaticCast< ::Array< Float > >());
HXLINE( 413)				weights->__get(0).StaticCast< ::Array< Float > >()[j] = prof_weights->__get(j);
HXLINE( 414)				weights->__get(1).StaticCast< ::Array< Float > >()[j] = prof_weights->__get(j);
HXLINE( 415)				weights->__get(2).StaticCast< ::Array< Float > >()[j] = prof_weights->__get(j);
            			}
            		}
HXLINE( 418)		int profile1 = profile->degree;
HXDLIN( 418)		::Array< Float > profile2 = profile->knots;
HXDLIN( 418)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,2,profile1,::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_27,6),profile2,::verb::eval::Eval_obj::homogenize2d(controlPoints,weights));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Make_obj,extrudedSurface,return )

 ::verb::core::NurbsSurfaceData Make_obj::cylindricalSurface(::Array< Float > axis,::Array< Float > xaxis,::Array< Float > base,Float height,Float radius){
            	HX_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_435_cylindricalSurface)
HXLINE( 437)		::Array< Float > yaxis = ::verb::core::Vec_obj::cross(axis,xaxis);
HXDLIN( 437)		Float angle = (((Float)2.0) * ::Math_obj::PI);
HXDLIN( 437)		 ::verb::core::NurbsCurveData circ = ::verb::eval::Make_obj::arc(base,xaxis,yaxis,radius,((Float)0.0),(( (Float)(2) ) * ::Math_obj::PI));
HXLINE( 441)		return ::verb::eval::Make_obj::extrudedSurface(axis,height,circ);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Make_obj,cylindricalSurface,return )

 ::verb::core::NurbsSurfaceData Make_obj::revolvedSurface( ::verb::core::NurbsCurveData profile,::Array< Float > center,::Array< Float > axis,Float theta){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_461_revolvedSurface)
HXLINE( 463)		::Array< ::Dynamic> prof_controlPoints = ::verb::eval::Eval_obj::dehomogenize1d(profile->controlPoints);
HXDLIN( 463)		::Array< Float > prof_weights = ::verb::eval::Eval_obj::weight1d(profile->controlPoints);
HXLINE( 466)		int narcs;
HXDLIN( 466)		::Array< Float > knotsU;
HXDLIN( 466)		 ::Dynamic controlPoints;
HXDLIN( 466)		 ::Dynamic weights;
HXLINE( 468)		if ((theta <= (::Math_obj::PI / ( (Float)(2) )))) {
HXLINE( 469)			narcs = 1;
HXLINE( 470)			knotsU = ::verb::core::Vec_obj::zeros1d((6 + (2 * (narcs - 1))));
            		}
            		else {
HXLINE( 472)			if ((theta <= ::Math_obj::PI)) {
HXLINE( 473)				narcs = 2;
HXLINE( 474)				knotsU = ::verb::core::Vec_obj::zeros1d((6 + (2 * (narcs - 1))));
HXLINE( 475)				knotsU[3] = (knotsU[4] = ((Float)0.5));
            			}
            			else {
HXLINE( 476)				if ((theta <= ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) )))) {
HXLINE( 477)					narcs = 3;
HXLINE( 478)					knotsU = ::verb::core::Vec_obj::zeros1d((6 + (2 * (narcs - 1))));
HXLINE( 479)					knotsU[3] = (knotsU[4] = ((Float)0.33333333333333331));
HXLINE( 480)					knotsU[5] = (knotsU[6] = ((Float)0.66666666666666663));
            				}
            				else {
HXLINE( 482)					narcs = 4;
HXLINE( 483)					knotsU = ::verb::core::Vec_obj::zeros1d((6 + (2 * (narcs - 1))));
HXLINE( 484)					knotsU[3] = (knotsU[4] = ((Float)0.25));
HXLINE( 485)					knotsU[5] = (knotsU[6] = ((Float)0.5));
HXLINE( 486)					knotsU[7] = (knotsU[8] = ((Float)0.75));
            				}
            			}
            		}
HXLINE( 490)		Float dtheta = (theta / ( (Float)(narcs) ));
HXDLIN( 490)		int j = (3 + (2 * (narcs - 1)));
HXLINE( 495)		{
HXLINE( 495)			{
HXLINE( 496)				knotsU[0] = ((Float)0.0);
HXLINE( 497)				knotsU[j] = ((Float)1.0);
            			}
HXLINE( 495)			{
HXLINE( 496)				knotsU[1] = ((Float)0.0);
HXLINE( 497)				knotsU[(j + 1)] = ((Float)1.0);
            			}
HXLINE( 495)			{
HXLINE( 496)				knotsU[2] = ((Float)0.0);
HXLINE( 497)				knotsU[(j + 2)] = ((Float)1.0);
            			}
            		}
HXLINE( 501)		int n = (2 * narcs);
HXDLIN( 501)		Float wm = ::Math_obj::cos((dtheta / ((Float)2.0)));
HXDLIN( 501)		Float angle = ((Float)0.0);
HXDLIN( 501)		::Array< Float > sines = ::verb::core::Vec_obj::zeros1d((narcs + 1));
HXDLIN( 501)		::Array< Float > cosines = ::verb::core::Vec_obj::zeros1d((narcs + 1));
HXDLIN( 501)		::Array< ::Dynamic> controlPoints1 = ::verb::core::Vec_obj::zeros3d(((2 * narcs) + 1),prof_controlPoints->length,3);
HXDLIN( 501)		::Array< ::Dynamic> weights1 = ::verb::core::Vec_obj::zeros2d(((2 * narcs) + 1),prof_controlPoints->length);
HXLINE( 510)		{
HXLINE( 510)			int _g = 1;
HXDLIN( 510)			int _g1 = (narcs + 1);
HXDLIN( 510)			while((_g < _g1)){
HXLINE( 510)				_g = (_g + 1);
HXDLIN( 510)				int i = (_g - 1);
HXLINE( 511)				angle = (angle + dtheta);
HXLINE( 512)				cosines[i] = ::Math_obj::cos(angle);
HXLINE( 513)				sines[i] = ::Math_obj::sin(angle);
            			}
            		}
HXLINE( 518)		{
HXLINE( 518)			int _g2 = 0;
HXDLIN( 518)			int _g3 = prof_controlPoints->length;
HXDLIN( 518)			while((_g2 < _g3)){
HXLINE( 518)				_g2 = (_g2 + 1);
HXDLIN( 518)				int j = (_g2 - 1);
HXLINE( 521)				::Array< Float > O = ::verb::core::Trig_obj::rayClosestPoint(prof_controlPoints->__get(j).StaticCast< ::Array< Float > >(),center,axis);
HXDLIN( 521)				::Array< Float > X = ::verb::core::Vec_obj::sub(prof_controlPoints->__get(j).StaticCast< ::Array< Float > >(),O);
HXDLIN( 521)				Float r = ::verb::core::Vec_obj::norm(X);
HXDLIN( 521)				::Array< Float > Y = ::verb::core::Vec_obj::cross(axis,X);
HXLINE( 529)				if ((r > ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 530)					X = ::verb::core::Vec_obj::mul((( (Float)(1) ) / r),X);
HXLINE( 531)					Y = ::verb::core::Vec_obj::mul((( (Float)(1) ) / r),Y);
            				}
HXLINE( 535)				controlPoints1->__get(0).StaticCast< ::Array< ::Dynamic> >()[j] = prof_controlPoints->__get(j).StaticCast< ::Array< Float > >();
HXLINE( 536)				::Array< Float > P0 = prof_controlPoints->__get(j).StaticCast< ::Array< Float > >();
HXLINE( 537)				weights1->__get(0).StaticCast< ::Array< Float > >()[j] = prof_weights->__get(j);
HXLINE( 540)				::Array< Float > T0 = Y;
HXDLIN( 540)				int index = 0;
HXDLIN( 540)				Float angle = ((Float)0.0);
HXLINE( 545)				{
HXLINE( 545)					int _g = 1;
HXDLIN( 545)					int _g1 = (narcs + 1);
HXDLIN( 545)					while((_g < _g1)){
HXLINE( 545)						_g = (_g + 1);
HXDLIN( 545)						int i = (_g - 1);
HXLINE( 549)						::Array< Float > P2;
HXDLIN( 549)						if ((r == 0)) {
HXLINE( 549)							P2 = O;
            						}
            						else {
HXLINE( 549)							::Array< Float > P21 = ::verb::core::Vec_obj::mul((r * cosines->__get(i)),X);
HXDLIN( 549)							P2 = ::verb::core::Vec_obj::add(O,::verb::core::Vec_obj::add(P21,::verb::core::Vec_obj::mul((r * sines->__get(i)),Y)));
            						}
HXLINE( 551)						controlPoints1->__get((index + 2)).StaticCast< ::Array< ::Dynamic> >()[j] = P2;
HXLINE( 552)						weights1->__get((index + 2)).StaticCast< ::Array< Float > >()[j] = prof_weights->__get(j);
HXLINE( 555)						::Array< Float > T2 = ::verb::core::Vec_obj::mul(cosines->__get(i),Y);
HXDLIN( 555)						::Array< Float > T21 = ::verb::core::Vec_obj::sub(T2,::verb::core::Vec_obj::mul(sines->__get(i),X));
HXLINE( 558)						if ((r == 0)) {
HXLINE( 559)							controlPoints1->__get((index + 1)).StaticCast< ::Array< ::Dynamic> >()[j] = O;
            						}
            						else {
HXLINE( 562)							::Array< Float > inters = ::verb::core::Vec_obj::mul((( (Float)(1) ) / ::verb::core::Vec_obj::norm(T0)),T0);
HXDLIN( 562)							 ::verb::core::CurveCurveIntersection inters1 = ::verb::eval::Intersect_obj::rays(P0,inters,P2,::verb::core::Vec_obj::mul((( (Float)(1) ) / ::verb::core::Vec_obj::norm(T21)),T21));
HXLINE( 563)							::Array< Float > P1 = ::verb::core::Vec_obj::add(P0,::verb::core::Vec_obj::mul(inters1->u0,T0));
HXLINE( 565)							controlPoints1->__get((index + 1)).StaticCast< ::Array< ::Dynamic> >()[j] = P1;
            						}
HXLINE( 568)						weights1->__get((index + 1)).StaticCast< ::Array< Float > >()[j] = (wm * prof_weights->__get(j));
HXLINE( 570)						index = (index + 2);
HXLINE( 572)						if ((i < narcs)) {
HXLINE( 573)							P0 = P2;
HXLINE( 574)							T0 = T21;
            						}
            					}
            				}
            			}
            		}
HXLINE( 579)		int profile1 = profile->degree;
HXDLIN( 579)		::Array< Float > profile2 = profile->knots;
HXDLIN( 579)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,2,profile1,knotsU,profile2,::verb::eval::Eval_obj::homogenize2d(controlPoints1,weights1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Make_obj,revolvedSurface,return )

 ::verb::core::NurbsSurfaceData Make_obj::sphericalSurface(::Array< Float > center,::Array< Float > axis,::Array< Float > xaxis,Float radius){
            	HX_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_597_sphericalSurface)
HXLINE( 599)		::Array< Float > arc = ::verb::core::Vec_obj::mul(((Float)-1.0),axis);
HXDLIN( 599)		 ::verb::core::NurbsCurveData arc1 = ::verb::eval::Make_obj::arc(center,arc,xaxis,radius,((Float)0.0),::Math_obj::PI);
HXLINE( 600)		return ::verb::eval::Make_obj::revolvedSurface(arc1,center,axis,(( (Float)(2) ) * ::Math_obj::PI));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Make_obj,sphericalSurface,return )

 ::verb::core::NurbsSurfaceData Make_obj::conicalSurface(::Array< Float > axis,::Array< Float > xaxis,::Array< Float > base,Float height,Float radius){
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_618_conicalSurface)
HXLINE( 620)		Float angle = (( (Float)(2) ) * ::Math_obj::PI);
HXDLIN( 620)		int prof_degree = 1;
HXLINE( 622)		::Array< Float > prof_ctrl_pts = ::verb::core::Vec_obj::add(base,::verb::core::Vec_obj::mul(height,axis));
HXLINE( 620)		::Array< ::Dynamic> prof_ctrl_pts1 = ::Array_obj< ::Dynamic>::__new(2)->init(0,prof_ctrl_pts)->init(1,::verb::core::Vec_obj::add(base,::verb::core::Vec_obj::mul(radius,xaxis)));
HXDLIN( 620)		::Array< Float > prof_knots = ::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_35,4);
HXDLIN( 620)		::Array< Float > prof_weights = ::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_36,2);
HXDLIN( 620)		 ::verb::core::NurbsCurveData prof =  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,prof_degree,prof_knots,::verb::eval::Eval_obj::homogenize1d(prof_ctrl_pts1,prof_weights));
HXLINE( 627)		return ::verb::eval::Make_obj::revolvedSurface(prof,base,axis,angle);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Make_obj,conicalSurface,return )

 ::verb::core::NurbsCurveData Make_obj::rationalInterpCurve(::Array< ::Dynamic> points,::hx::Null< int >  __o_degree,::hx::Null< bool >  __o_homogeneousPoints,::Array< Float > start_tangent,::Array< Float > end_tangent){
            		int degree = __o_degree.Default(3);
            		bool homogeneousPoints = __o_homogeneousPoints.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_b6ec46f953fc72f4_635_rationalInterpCurve)
HXLINE( 646)		if ((points->length < (degree + 1))) {
HXLINE( 647)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(((HX_("You need to supply at least degree + 1 points! You only supplied ",9a,66,d9,9d) + points->length) + HX_(" points.",8b,10,70,77))));
            		}
HXLINE( 650)		::Array< Float > us = ::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_46,1);
HXLINE( 651)		{
HXLINE( 651)			int _g = 1;
HXDLIN( 651)			int _g1 = points->length;
HXDLIN( 651)			while((_g < _g1)){
HXLINE( 651)				_g = (_g + 1);
HXDLIN( 651)				int i = (_g - 1);
HXLINE( 652)				Float chord = ::verb::core::Vec_obj::norm(::verb::core::Vec_obj::sub(points->__get(i).StaticCast< ::Array< Float > >(),points->__get((i - 1)).StaticCast< ::Array< Float > >()));
HXLINE( 653)				Float last = us->__get((us->length - 1));
HXLINE( 654)				us->push((last + chord));
            			}
            		}
HXLINE( 658)		Float max = us->__get((us->length - 1));
HXLINE( 659)		{
HXLINE( 659)			int _g2 = 0;
HXDLIN( 659)			int _g3 = us->length;
HXDLIN( 659)			while((_g2 < _g3)){
HXLINE( 659)				_g2 = (_g2 + 1);
HXDLIN( 659)				int i = (_g2 - 1);
HXLINE( 660)				us[i] = (us->__get(i) / max);
            			}
            		}
HXLINE( 663)		::Array< Float > knotsStart = ::verb::core::Vec_obj::rep((degree + 1),((Float)0.0));
HXLINE( 667)		bool hasTangents;
HXDLIN( 667)		if (::hx::IsNotNull( start_tangent )) {
HXLINE( 667)			hasTangents = ::hx::IsNotNull( end_tangent );
            		}
            		else {
HXLINE( 667)			hasTangents = false;
            		}
HXLINE( 668)		int start;
HXDLIN( 668)		if (hasTangents) {
HXLINE( 668)			start = 0;
            		}
            		else {
HXLINE( 668)			start = 1;
            		}
HXLINE( 669)		int end;
HXDLIN( 669)		if (hasTangents) {
HXLINE( 669)			end = ((us->length - degree) + 1);
            		}
            		else {
HXLINE( 669)			end = (us->length - degree);
            		}
HXLINE( 671)		{
HXLINE( 671)			int _g4 = start;
HXDLIN( 671)			int _g5 = end;
HXDLIN( 671)			while((_g4 < _g5)){
HXLINE( 671)				_g4 = (_g4 + 1);
HXDLIN( 671)				int i = (_g4 - 1);
HXLINE( 672)				Float weightSums = ((Float)0.0);
HXLINE( 673)				{
HXLINE( 673)					int _g = 0;
HXDLIN( 673)					int _g1 = degree;
HXDLIN( 673)					while((_g < _g1)){
HXLINE( 673)						_g = (_g + 1);
HXDLIN( 673)						int j = (_g - 1);
HXLINE( 674)						weightSums = (weightSums + us->__get((i + j)));
            					}
            				}
HXLINE( 677)				knotsStart->push(((( (Float)(1) ) / ( (Float)(degree) )) * weightSums));
            			}
            		}
HXLINE( 680)		::Array< Float > knots = knotsStart->concat(::verb::core::Vec_obj::rep((degree + 1),((Float)1.0)));
HXLINE( 683)		::Array< ::Dynamic> A = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 684)		int n;
HXDLIN( 684)		if (hasTangents) {
HXLINE( 684)			n = (points->length + 1);
            		}
            		else {
HXLINE( 684)			n = (points->length - 1);
            		}
HXLINE( 686)		int lst;
HXDLIN( 686)		if (hasTangents) {
HXLINE( 686)			lst = 1;
            		}
            		else {
HXLINE( 686)			lst = 0;
            		}
HXLINE( 687)		int ld;
HXDLIN( 687)		if (hasTangents) {
HXLINE( 687)			ld = (points->length - (degree - 1));
            		}
            		else {
HXLINE( 687)			ld = (points->length - (degree + 1));
            		}
HXLINE( 689)		{
HXLINE( 689)			int _g6 = 0;
HXDLIN( 689)			while((_g6 < us->length)){
HXLINE( 689)				Float u = us->__get(_g6);
HXDLIN( 689)				_g6 = (_g6 + 1);
HXLINE( 690)				int span = ::verb::eval::Eval_obj::knotSpanGivenN(n,degree,u,knots);
HXLINE( 691)				::Array< Float > basisFuncs = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(span,u,degree,knots);
HXLINE( 693)				int ls = (span - degree);
HXLINE( 695)				::Array< Float > rowstart = ::verb::core::Vec_obj::zeros1d(ls);
HXLINE( 696)				::Array< Float > rowend = ::verb::core::Vec_obj::zeros1d((ld - ls));
HXLINE( 698)				A->push(rowstart->concat(basisFuncs)->concat(rowend));
            			}
            		}
HXLINE( 701)		if (hasTangents) {
HXLINE( 702)			int ln = (A->__get(0).StaticCast< ::Array< Float > >()->length - 2);
HXLINE( 704)			::Array< Float > tanRow0 = ::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_47,2)->concat(::verb::core::Vec_obj::zeros1d(ln));
HXLINE( 705)			::Array< Float > tanRow1 = ::verb::core::Vec_obj::zeros1d(ln)->concat(::Array_obj< Float >::fromData( _hx_array_data_a0e56f91_48,2));
HXLINE( 707)			::verb::core::ArrayExtensions_obj::spliceAndInsert(A,1,0,tanRow0);
HXLINE( 708)			::verb::core::ArrayExtensions_obj::spliceAndInsert(A,(A->length - 1),0,tanRow1);
            		}
HXLINE( 712)		int dim = points->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE( 713)		::Array< ::Dynamic> xs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 715)		Float mult1 = ((( (Float)(1) ) - knots->__get(((knots->length - degree) - 2))) / ( (Float)(degree) ));
HXLINE( 716)		Float mult0 = (knots->__get((degree + 1)) / ( (Float)(degree) ));
HXLINE( 718)		{
HXLINE( 718)			int _g7 = 0;
HXDLIN( 718)			int _g8 = dim;
HXDLIN( 718)			while((_g7 < _g8)){
HXLINE( 718)				_g7 = (_g7 + 1);
HXDLIN( 718)				int i = (_g7 - 1);
HXLINE( 719)				::Array< Float > b;
HXLINE( 721)				if (!(hasTangents)) {
HXLINE( 722)					::Array< Float > result = ::Array_obj< Float >::__new(points->length);
HXDLIN( 722)					{
HXLINE( 722)						int _g = 0;
HXDLIN( 722)						int _g1 = points->length;
HXDLIN( 722)						while((_g < _g1)){
HXLINE( 722)							_g = (_g + 1);
HXDLIN( 722)							int i1 = (_g - 1);
HXDLIN( 722)							{
HXLINE( 722)								Float inValue = ( (Float)(_hx_array_unsafe_get(points,i1)->__GetItem(i)) );
HXDLIN( 722)								result->__unsafe_set(i1,inValue);
            							}
            						}
            					}
HXDLIN( 722)					b = result;
            				}
            				else {
HXLINE( 727)					b = ::Array_obj< Float >::__new(1)->init(0,points->__get(0).StaticCast< ::Array< Float > >()->__get(i));
HXLINE( 728)					b->push((mult0 * start_tangent->__get(i)));
HXLINE( 729)					{
HXLINE( 729)						int _g = 1;
HXDLIN( 729)						int _g1 = (points->length - 1);
HXDLIN( 729)						while((_g < _g1)){
HXLINE( 729)							_g = (_g + 1);
HXDLIN( 729)							int j = (_g - 1);
HXDLIN( 729)							b->push(points->__get(j).StaticCast< ::Array< Float > >()->__get(i));
            						}
            					}
HXLINE( 730)					b->push((mult1 * end_tangent->__get(i)));
HXLINE( 731)					b->push(::verb::core::ArrayExtensions_obj::last(points)->__GetItem(i));
            				}
HXLINE( 734)				::Array< Float > x = ::verb::core::Mat_obj::solve(A,b);
HXLINE( 735)				xs->push(x);
            			}
            		}
HXLINE( 738)		::Array< ::Dynamic> controlPts = ::verb::core::Mat_obj::transpose(xs);
HXLINE( 740)		if (!(homogeneousPoints)) {
HXLINE( 741)			::Array< Float > weights = ::verb::core::Vec_obj::rep(controlPts->length,((Float)1.0));
HXLINE( 742)			controlPts = ::verb::eval::Eval_obj::homogenize1d(controlPts,weights);
            		}
HXLINE( 745)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots,controlPts);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Make_obj,rationalInterpCurve,return )


Make_obj::Make_obj()
{
}

bool Make_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"arc") ) { outValue = arc_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"polyline") ) { outValue = polyline_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"ellipseArc") ) { outValue = ellipseArc_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"clonedCurve") ) { outValue = clonedCurve_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"loftedSurface") ) { outValue = loftedSurface_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"conicalSurface") ) { outValue = conicalSurface_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"surfaceIsocurve") ) { outValue = surfaceIsocurve_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"extrudedSurface") ) { outValue = extrudedSurface_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"revolvedSurface") ) { outValue = revolvedSurface_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fourPointSurface") ) { outValue = fourPointSurface_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sphericalSurface") ) { outValue = sphericalSurface_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"cylindricalSurface") ) { outValue = cylindricalSurface_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"rationalBezierCurve") ) { outValue = rationalBezierCurve_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rationalInterpCurve") ) { outValue = rationalInterpCurve_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"surfaceBoundaryCurves") ) { outValue = surfaceBoundaryCurves_dyn(); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"rationalTranslationalSurface") ) { outValue = rationalTranslationalSurface_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Make_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Make_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Make_obj::__mClass;

static ::String Make_obj_sStaticFields[] = {
	HX_("rationalTranslationalSurface",3f,4d,a5,87),
	HX_("surfaceBoundaryCurves",7b,e4,4a,96),
	HX_("surfaceIsocurve",97,18,0b,40),
	HX_("loftedSurface",dd,16,20,25),
	HX_("clonedCurve",c8,48,f5,44),
	HX_("rationalBezierCurve",02,f6,d4,9c),
	HX_("fourPointSurface",c3,f4,38,03),
	HX_("ellipseArc",14,d4,d0,4c),
	HX_("arc",52,fe,49,00),
	HX_("polyline",40,ac,9a,2f),
	HX_("extrudedSurface",4e,32,48,a9),
	HX_("cylindricalSurface",5f,01,b5,c3),
	HX_("revolvedSurface",98,79,df,8a),
	HX_("sphericalSurface",10,66,b4,fc),
	HX_("conicalSurface",66,98,20,39),
	HX_("rationalInterpCurve",2d,2c,f6,5e),
	::String(null())
};

void Make_obj::__register()
{
	Make_obj _hx_dummy;
	Make_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Make",91,6f,e5,a0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Make_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Make_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Make_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Make_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Make_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
