// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_MeshData
#include <verb/core/MeshData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_SurfacePoint
#include <verb/core/SurfacePoint.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_AdaptiveRefinementNode
#include <verb/eval/AdaptiveRefinementNode.h>
#endif
#ifndef INCLUDED_verb_eval_AdaptiveRefinementOptions
#include <verb/eval/AdaptiveRefinementOptions.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a8787bb72260b6b7_410_new,"verb.eval.AdaptiveRefinementNode","new",0xd1d20b98,"verb.eval.AdaptiveRefinementNode.new","verb/eval/Tess.hx",410,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_435_isLeaf,"verb.eval.AdaptiveRefinementNode","isLeaf",0x3af36070,"verb.eval.AdaptiveRefinementNode.isLeaf","verb/eval/Tess.hx",435,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_439_center,"verb.eval.AdaptiveRefinementNode","center",0xdbb7bd9d,"verb.eval.AdaptiveRefinementNode.center","verb/eval/Tess.hx",439,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_442_evalCorners,"verb.eval.AdaptiveRefinementNode","evalCorners",0x00c075fa,"verb.eval.AdaptiveRefinementNode.evalCorners","verb/eval/Tess.hx",442,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_459_evalSrf,"verb.eval.AdaptiveRefinementNode","evalSrf",0x02bd53e3,"verb.eval.AdaptiveRefinementNode.evalSrf","verb/eval/Tess.hx",459,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_478_getEdgeCorners,"verb.eval.AdaptiveRefinementNode","getEdgeCorners",0x604f1f13,"verb.eval.AdaptiveRefinementNode.getEdgeCorners","verb/eval/Tess.hx",478,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_531_getAllCorners,"verb.eval.AdaptiveRefinementNode","getAllCorners",0xd6936d4b,"verb.eval.AdaptiveRefinementNode.getAllCorners","verb/eval/Tess.hx",531,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_532_getAllCorners,"verb.eval.AdaptiveRefinementNode","getAllCorners",0xd6936d4b,"verb.eval.AdaptiveRefinementNode.getAllCorners","verb/eval/Tess.hx",532,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_513_getAllCorners,"verb.eval.AdaptiveRefinementNode","getAllCorners",0xd6936d4b,"verb.eval.AdaptiveRefinementNode.getAllCorners","verb/eval/Tess.hx",513,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_542_midpoint,"verb.eval.AdaptiveRefinementNode","midpoint",0xa3102f90,"verb.eval.AdaptiveRefinementNode.midpoint","verb/eval/Tess.hx",542,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_563_hasBadNormals,"verb.eval.AdaptiveRefinementNode","hasBadNormals",0x438f0259,"verb.eval.AdaptiveRefinementNode.hasBadNormals","verb/eval/Tess.hx",563,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_566_fixNormals,"verb.eval.AdaptiveRefinementNode","fixNormals",0x891906df,"verb.eval.AdaptiveRefinementNode.fixNormals","verb/eval/Tess.hx",566,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_583_shouldDivide,"verb.eval.AdaptiveRefinementNode","shouldDivide",0x47f691d4,"verb.eval.AdaptiveRefinementNode.shouldDivide","verb/eval/Tess.hx",583,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_610_divide,"verb.eval.AdaptiveRefinementNode","divide",0x94eec741,"verb.eval.AdaptiveRefinementNode.divide","verb/eval/Tess.hx",610,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_621__divide,"verb.eval.AdaptiveRefinementNode","_divide",0x78b17850,"verb.eval.AdaptiveRefinementNode._divide","verb/eval/Tess.hx",621,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_670_triangulate,"verb.eval.AdaptiveRefinementNode","triangulate",0x311d9864,"verb.eval.AdaptiveRefinementNode.triangulate","verb/eval/Tess.hx",670,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_a8787bb72260b6b7_685_triangulateLeaf,"verb.eval.AdaptiveRefinementNode","triangulateLeaf",0x3264ca22,"verb.eval.AdaptiveRefinementNode.triangulateLeaf","verb/eval/Tess.hx",685,0xdad164ea)
namespace verb{
namespace eval{

void AdaptiveRefinementNode_obj::__construct( ::verb::core::NurbsSurfaceData srf,::Array< ::Dynamic> corners,::Array< ::Dynamic> neighbors){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_410_new)
HXLINE( 413)		this->srf = srf;
HXLINE( 414)		::Array< ::Dynamic> _hx_tmp;
HXDLIN( 414)		if (::hx::IsNull( neighbors )) {
HXLINE( 414)			_hx_tmp = ::Array_obj< ::Dynamic>::__new(4)->init(0,null())->init(1,null())->init(2,null())->init(3,null());
            		}
            		else {
HXLINE( 414)			_hx_tmp = neighbors;
            		}
HXDLIN( 414)		this->neighbors = _hx_tmp;
HXLINE( 416)		this->corners = corners;
HXLINE( 419)		if (::hx::IsNull( this->corners )) {
HXLINE( 420)			Float u0 = srf->knotsU->__get(0);
HXLINE( 421)			Float u1 = ( (Float)(::verb::core::ArrayExtensions_obj::last(srf->knotsU)) );
HXLINE( 422)			Float v0 = srf->knotsV->__get(0);
HXLINE( 423)			Float v1 = ( (Float)(::verb::core::ArrayExtensions_obj::last(srf->knotsV)) );
HXLINE( 426)			 ::verb::core::SurfacePoint _hx_tmp = ::verb::core::SurfacePoint_obj::fromUv(u0,v0);
HXLINE( 427)			 ::verb::core::SurfacePoint _hx_tmp1 = ::verb::core::SurfacePoint_obj::fromUv(u1,v0);
HXLINE( 428)			 ::verb::core::SurfacePoint _hx_tmp2 = ::verb::core::SurfacePoint_obj::fromUv(u1,v1);
HXLINE( 425)			this->corners = ::Array_obj< ::Dynamic>::__new(4)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,_hx_tmp2)->init(3,::verb::core::SurfacePoint_obj::fromUv(u0,v1));
            		}
            	}

Dynamic AdaptiveRefinementNode_obj::__CreateEmpty() { return new AdaptiveRefinementNode_obj; }

void *AdaptiveRefinementNode_obj::_hx_vtable = 0;

Dynamic AdaptiveRefinementNode_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AdaptiveRefinementNode_obj > _hx_result = new AdaptiveRefinementNode_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool AdaptiveRefinementNode_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x513e2c1e;
}

bool AdaptiveRefinementNode_obj::isLeaf(){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_435_isLeaf)
HXDLIN( 435)		return ::hx::IsNull( this->children );
            	}


HX_DEFINE_DYNAMIC_FUNC0(AdaptiveRefinementNode_obj,isLeaf,return )

 ::verb::core::SurfacePoint AdaptiveRefinementNode_obj::center(){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_439_center)
HXDLIN( 439)		if (::hx::IsNotNull( this->centerPoint )) {
HXDLIN( 439)			return this->centerPoint;
            		}
            		else {
HXDLIN( 439)			return this->evalSrf(this->u05,this->v05,null());
            		}
HXDLIN( 439)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(AdaptiveRefinementNode_obj,center,return )

void AdaptiveRefinementNode_obj::evalCorners(){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_442_evalCorners)
HXLINE( 445)		this->u05 = ((this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0) + this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0)) / ( (Float)(2) ));
HXLINE( 446)		this->v05 = ((this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1) + this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1)) / ( (Float)(2) ));
HXLINE( 449)		{
HXLINE( 451)			if (::hx::IsNull( this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->point )) {
HXLINE( 453)				 ::verb::core::SurfacePoint c = this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 454)				this->evalSrf(c->uv->__get(0),c->uv->__get(1),c);
            			}
HXLINE( 451)			if (::hx::IsNull( this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->point )) {
HXLINE( 453)				 ::verb::core::SurfacePoint c = this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 454)				this->evalSrf(c->uv->__get(0),c->uv->__get(1),c);
            			}
HXLINE( 451)			if (::hx::IsNull( this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->point )) {
HXLINE( 453)				 ::verb::core::SurfacePoint c = this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 454)				this->evalSrf(c->uv->__get(0),c->uv->__get(1),c);
            			}
HXLINE( 451)			if (::hx::IsNull( this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >()->point )) {
HXLINE( 453)				 ::verb::core::SurfacePoint c = this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 454)				this->evalSrf(c->uv->__get(0),c->uv->__get(1),c);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(AdaptiveRefinementNode_obj,evalCorners,(void))

 ::verb::core::SurfacePoint AdaptiveRefinementNode_obj::evalSrf(Float u,Float v, ::verb::core::SurfacePoint srfPt){
            	HX_GC_STACKFRAME(&_hx_pos_a8787bb72260b6b7_459_evalSrf)
HXLINE( 461)		::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(this->srf,u,v,1);
HXLINE( 462)		::Array< Float > pt = derivs->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 463)		::Array< Float > norm = ::verb::core::Vec_obj::cross(derivs->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >(),derivs->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >());
HXLINE( 464)		bool degen = ::verb::core::Vec_obj::isZero(norm);
HXLINE( 466)		if (!(degen)) {
HXLINE( 466)			norm = ::verb::core::Vec_obj::normalized(norm);
            		}
HXLINE( 468)		if (::hx::IsNotNull( srfPt )) {
HXLINE( 469)			srfPt->degen = degen;
HXLINE( 470)			srfPt->point = pt;
HXLINE( 471)			srfPt->normal = norm;
HXLINE( 472)			return srfPt;
            		}
            		else {
HXLINE( 474)			return  ::verb::core::SurfacePoint_obj::__alloc( HX_CTX ,pt,norm,::Array_obj< Float >::__new(2)->init(0,u)->init(1,v),-1,degen);
            		}
HXLINE( 468)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC3(AdaptiveRefinementNode_obj,evalSrf,return )

::Array< ::Dynamic> AdaptiveRefinementNode_obj::getEdgeCorners(int edgeIndex){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_478_getEdgeCorners)
HXLINE( 481)		if (this->isLeaf()) {
HXLINE( 481)			return ::Array_obj< ::Dynamic>::__new(1)->init(0,this->corners->__get(edgeIndex).StaticCast<  ::verb::core::SurfacePoint >());
            		}
HXLINE( 483)		if (this->horizontal) {
HXLINE( 485)			switch((int)(edgeIndex)){
            				case (int)0: {
HXLINE( 487)					return this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(0);
            				}
            				break;
            				case (int)1: {
HXLINE( 489)					::Array< ::Dynamic> _hx_tmp = this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(1);
HXDLIN( 489)					return _hx_tmp->concat(this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(1));
            				}
            				break;
            				case (int)2: {
HXLINE( 491)					return this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(2);
            				}
            				break;
            				case (int)3: {
HXLINE( 493)					::Array< ::Dynamic> _hx_tmp = this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(3);
HXDLIN( 493)					return _hx_tmp->concat(this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(3));
            				}
            				break;
            			}
            		}
HXLINE( 499)		switch((int)(edgeIndex)){
            			case (int)0: {
HXLINE( 501)				::Array< ::Dynamic> _hx_tmp = this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(0);
HXDLIN( 501)				return _hx_tmp->concat(this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(0));
            			}
            			break;
            			case (int)1: {
HXLINE( 503)				return this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(1);
            			}
            			break;
            			case (int)2: {
HXLINE( 505)				::Array< ::Dynamic> _hx_tmp = this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(2);
HXDLIN( 505)				return _hx_tmp->concat(this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(2));
            			}
            			break;
            			case (int)3: {
HXLINE( 507)				return this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(3);
            			}
            			break;
            		}
HXLINE( 510)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,getEdgeCorners,return )

::Array< ::Dynamic> AdaptiveRefinementNode_obj::getAllCorners(int edgeIndex){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::verb::eval::AdaptiveRefinementNode,that,Float,e) HXARGC(1)
            		bool _hx_run( ::verb::core::SurfacePoint c){
            			HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_531_getAllCorners)
HXLINE( 531)			if ((c->uv->__get(0) > (that->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0) + e))) {
HXLINE( 531)				return (c->uv->__get(0) < (that->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0) - e));
            			}
            			else {
HXLINE( 531)				return false;
            			}
HXDLIN( 531)			return false;
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::verb::eval::AdaptiveRefinementNode,that,Float,e) HXARGC(1)
            		bool _hx_run( ::verb::core::SurfacePoint c){
            			HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_532_getAllCorners)
HXLINE( 532)			if ((c->uv->__get(1) > (that->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1) + e))) {
HXLINE( 532)				return (c->uv->__get(1) < (that->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1) - e));
            			}
            			else {
HXLINE( 532)				return false;
            			}
HXDLIN( 532)			return false;
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_513_getAllCorners)
HXLINE( 515)		::Array< ::Dynamic> baseArr = ::Array_obj< ::Dynamic>::__new(1)->init(0,this->corners->__get(edgeIndex).StaticCast<  ::verb::core::SurfacePoint >());
HXLINE( 517)		if (::hx::IsNull( this->neighbors->__get(edgeIndex).StaticCast<  ::verb::eval::AdaptiveRefinementNode >() )) {
HXLINE( 518)			return baseArr;
            		}
HXLINE( 522)		::Array< ::Dynamic> corners = this->neighbors->__get(edgeIndex).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->getEdgeCorners(::hx::Mod((edgeIndex + 2),4));
HXLINE( 524)		int funcIndex = ::hx::Mod(edgeIndex,2);
HXLINE( 526)		Float e = ::verb::core::Constants_obj::EPSILON;
HXLINE( 527)		 ::verb::eval::AdaptiveRefinementNode that = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 530)		::Array< ::Dynamic> rangeFuncMap = ::Array_obj< ::Dynamic>::__new(2)->init(0, ::Dynamic(new _hx_Closure_0(that,e)))->init(1, ::Dynamic(new _hx_Closure_1(that,e)));
HXLINE( 536)		 ::Dynamic f = rangeFuncMap->__get(funcIndex);
HXDLIN( 536)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 536)		{
HXLINE( 536)			int _g1 = 0;
HXDLIN( 536)			::Array< ::Dynamic> _g2 = corners;
HXDLIN( 536)			while((_g1 < _g2->length)){
HXLINE( 536)				 ::verb::core::SurfacePoint v = _g2->__get(_g1).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 536)				_g1 = (_g1 + 1);
HXDLIN( 536)				if (( (bool)(f(v)) )) {
HXLINE( 536)					_g->push(v);
            				}
            			}
            		}
HXDLIN( 536)		::Array< ::Dynamic> cornercopy = _g;
HXLINE( 537)		cornercopy->reverse();
HXLINE( 538)		return baseArr->concat(cornercopy);
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,getAllCorners,return )

 ::verb::core::SurfacePoint AdaptiveRefinementNode_obj::midpoint(int index){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_542_midpoint)
HXLINE( 544)		if (::hx::IsNull( this->midPoints )) {
HXLINE( 544)			this->midPoints = ::Array_obj< ::Dynamic>::__new(4)->init(0,null())->init(1,null())->init(2,null())->init(3,null());
            		}
HXLINE( 545)		if (::hx::IsNotNull( this->midPoints->__get(index).StaticCast<  ::verb::core::SurfacePoint >() )) {
HXLINE( 545)			return this->midPoints->__get(index).StaticCast<  ::verb::core::SurfacePoint >();
            		}
HXLINE( 547)		switch((int)(index)){
            			case (int)0: {
HXLINE( 549)				this->midPoints[0] = this->evalSrf(this->u05,this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1),null());
            			}
            			break;
            			case (int)1: {
HXLINE( 551)				this->midPoints[1] = this->evalSrf(this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0),this->v05,null());
            			}
            			break;
            			case (int)2: {
HXLINE( 553)				this->midPoints[2] = this->evalSrf(this->u05,this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(1),null());
            			}
            			break;
            			case (int)3: {
HXLINE( 555)				this->midPoints[3] = this->evalSrf(this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->uv->__get(0),this->v05,null());
            			}
            			break;
            		}
HXLINE( 558)		return this->midPoints->__get(index).StaticCast<  ::verb::core::SurfacePoint >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,midpoint,return )

bool AdaptiveRefinementNode_obj::hasBadNormals(){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_563_hasBadNormals)
HXDLIN( 563)		bool _hx_tmp;
HXDLIN( 563)		bool _hx_tmp1;
HXDLIN( 563)		if (!(this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->degen)) {
HXDLIN( 563)			_hx_tmp1 = this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->degen;
            		}
            		else {
HXDLIN( 563)			_hx_tmp1 = true;
            		}
HXDLIN( 563)		if (!(_hx_tmp1)) {
HXDLIN( 563)			_hx_tmp = this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->degen;
            		}
            		else {
HXDLIN( 563)			_hx_tmp = true;
            		}
HXDLIN( 563)		if (!(_hx_tmp)) {
HXDLIN( 563)			return this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >()->degen;
            		}
            		else {
HXDLIN( 563)			return true;
            		}
HXDLIN( 563)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(AdaptiveRefinementNode_obj,hasBadNormals,return )

void AdaptiveRefinementNode_obj::fixNormals(){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_566_fixNormals)
HXLINE( 567)		int l = this->corners->length;
HXLINE( 569)		{
HXLINE( 569)			int _g = 0;
HXDLIN( 569)			int _g1 = l;
HXDLIN( 569)			while((_g < _g1)){
HXLINE( 569)				_g = (_g + 1);
HXDLIN( 569)				int i = (_g - 1);
HXLINE( 570)				 ::verb::core::SurfacePoint corn = this->corners->__get(i).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 572)				if (this->corners->__get(i).StaticCast<  ::verb::core::SurfacePoint >()->degen) {
HXLINE( 574)					 ::verb::core::SurfacePoint v1 = this->corners->__get(::hx::Mod((i + 1),l)).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 575)					 ::verb::core::SurfacePoint v2 = this->corners->__get(::hx::Mod((i + 3),l)).StaticCast<  ::verb::core::SurfacePoint >();
HXLINE( 578)					::Array< Float > _hx_tmp;
HXDLIN( 578)					if (v1->degen) {
HXLINE( 578)						_hx_tmp = v2->normal;
            					}
            					else {
HXLINE( 578)						_hx_tmp = v1->normal;
            					}
HXDLIN( 578)					this->corners->__get(i).StaticCast<  ::verb::core::SurfacePoint >()->normal = _hx_tmp;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(AdaptiveRefinementNode_obj,fixNormals,(void))

bool AdaptiveRefinementNode_obj::shouldDivide( ::verb::eval::AdaptiveRefinementOptions options,int currentDepth){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_583_shouldDivide)
HXLINE( 585)		if ((currentDepth < options->minDepth)) {
HXLINE( 585)			return true;
            		}
HXLINE( 586)		if ((currentDepth >= options->maxDepth)) {
HXLINE( 586)			return false;
            		}
HXLINE( 588)		if (this->hasBadNormals()) {
HXLINE( 589)			this->fixNormals();
HXLINE( 591)			return false;
            		}
HXLINE( 594)		bool _hx_tmp;
HXDLIN( 594)		Float _hx_tmp1 = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->normal,this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXDLIN( 594)		if (!((_hx_tmp1 > options->normTol))) {
HXLINE( 595)			Float _hx_tmp1 = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->normal,this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXLINE( 594)			_hx_tmp = (_hx_tmp1 > options->normTol);
            		}
            		else {
HXLINE( 594)			_hx_tmp = true;
            		}
HXDLIN( 594)		this->splitVert = _hx_tmp;
HXLINE( 597)		bool _hx_tmp2;
HXDLIN( 597)		Float _hx_tmp3 = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->normal,this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXDLIN( 597)		if (!((_hx_tmp3 > options->normTol))) {
HXLINE( 598)			Float _hx_tmp = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >()->normal,this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXLINE( 597)			_hx_tmp2 = (_hx_tmp > options->normTol);
            		}
            		else {
HXLINE( 597)			_hx_tmp2 = true;
            		}
HXDLIN( 597)		this->splitHoriz = _hx_tmp2;
HXLINE( 600)		bool _hx_tmp4;
HXDLIN( 600)		if (!(this->splitVert)) {
HXLINE( 600)			_hx_tmp4 = this->splitHoriz;
            		}
            		else {
HXLINE( 600)			_hx_tmp4 = true;
            		}
HXDLIN( 600)		if (_hx_tmp4) {
HXLINE( 600)			return true;
            		}
HXLINE( 602)		 ::verb::core::SurfacePoint center = this->center();
HXLINE( 604)		bool _hx_tmp5;
HXDLIN( 604)		bool _hx_tmp6;
HXDLIN( 604)		Float _hx_tmp7 = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(center->normal,this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXDLIN( 604)		if (!((_hx_tmp7 > options->normTol))) {
HXLINE( 605)			Float _hx_tmp = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(center->normal,this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXLINE( 604)			_hx_tmp6 = (_hx_tmp > options->normTol);
            		}
            		else {
HXLINE( 604)			_hx_tmp6 = true;
            		}
HXDLIN( 604)		if (!(_hx_tmp6)) {
HXLINE( 606)			Float _hx_tmp = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(center->normal,this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXLINE( 604)			_hx_tmp5 = (_hx_tmp > options->normTol);
            		}
            		else {
HXLINE( 604)			_hx_tmp5 = true;
            		}
HXDLIN( 604)		if (!(_hx_tmp5)) {
HXLINE( 607)			Float _hx_tmp = ::verb::core::Vec_obj::normSquared(::verb::core::Vec_obj::sub(center->normal,this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >()->normal));
HXDLIN( 607)			return (_hx_tmp > options->normTol);
            		}
            		else {
HXLINE( 604)			return true;
            		}
HXDLIN( 604)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(AdaptiveRefinementNode_obj,shouldDivide,return )

void AdaptiveRefinementNode_obj::divide( ::verb::eval::AdaptiveRefinementOptions options){
            	HX_GC_STACKFRAME(&_hx_pos_a8787bb72260b6b7_610_divide)
HXLINE( 611)		if (::hx::IsNull( options )) {
HXLINE( 611)			options =  ::verb::eval::AdaptiveRefinementOptions_obj::__alloc( HX_CTX );
            		}
HXLINE( 618)		this->_divide(options,0,true);
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,divide,(void))

void AdaptiveRefinementNode_obj::_divide( ::verb::eval::AdaptiveRefinementOptions options,int currentDepth,bool horiz){
            	HX_GC_STACKFRAME(&_hx_pos_a8787bb72260b6b7_621__divide)
HXLINE( 623)		this->evalCorners();
HXLINE( 625)		if (!(this->shouldDivide(options,currentDepth))) {
HXLINE( 625)			return;
            		}
HXLINE( 627)		currentDepth = (currentDepth + 1);
HXLINE( 630)		bool _hx_tmp;
HXDLIN( 630)		if (this->splitVert) {
HXLINE( 630)			_hx_tmp = !(this->splitHoriz);
            		}
            		else {
HXLINE( 630)			_hx_tmp = false;
            		}
HXDLIN( 630)		if (_hx_tmp) {
HXLINE( 631)			horiz = false;
            		}
            		else {
HXLINE( 632)			bool _hx_tmp;
HXDLIN( 632)			if (!(this->splitVert)) {
HXLINE( 632)				_hx_tmp = this->splitHoriz;
            			}
            			else {
HXLINE( 632)				_hx_tmp = false;
            			}
HXDLIN( 632)			if (_hx_tmp) {
HXLINE( 633)				horiz = true;
            			}
            		}
HXLINE( 636)		this->horizontal = horiz;
HXLINE( 638)		if (this->horizontal) {
HXLINE( 640)			 ::verb::core::SurfacePoint bott = this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 640)			 ::verb::core::SurfacePoint bott1 = this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 640)			 ::verb::core::SurfacePoint bott2 = this->midpoint(1);
HXDLIN( 640)			::Array< ::Dynamic> bott3 = ::Array_obj< ::Dynamic>::__new(4)->init(0,bott)->init(1,bott1)->init(2,bott2)->init(3,this->midpoint(3));
HXLINE( 641)			 ::verb::core::SurfacePoint top = this->midpoint(3);
HXDLIN( 641)			 ::verb::core::SurfacePoint top1 = this->midpoint(1);
HXDLIN( 641)			::Array< ::Dynamic> top2 = ::Array_obj< ::Dynamic>::__new(4)->init(0,top)->init(1,top1)->init(2,this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >())->init(3,this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >());
HXLINE( 643)			 ::verb::eval::AdaptiveRefinementNode _hx_tmp =  ::verb::eval::AdaptiveRefinementNode_obj::__alloc( HX_CTX ,this->srf,bott3,null());
HXDLIN( 643)			this->children = ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::verb::eval::AdaptiveRefinementNode_obj::__alloc( HX_CTX ,this->srf,top2,null()));
HXLINE( 646)			this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->neighbors = ::Array_obj< ::Dynamic>::__new(4)->init(0,this->neighbors->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(1,this->neighbors->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(2,this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(3,this->neighbors->__get(3).StaticCast<  ::verb::eval::AdaptiveRefinementNode >());
HXLINE( 649)			this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->neighbors = ::Array_obj< ::Dynamic>::__new(4)->init(0,this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(1,this->neighbors->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(2,this->neighbors->__get(2).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(3,this->neighbors->__get(3).StaticCast<  ::verb::eval::AdaptiveRefinementNode >());
            		}
            		else {
HXLINE( 653)			 ::verb::core::SurfacePoint left = this->corners->__get(0).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 653)			 ::verb::core::SurfacePoint left1 = this->midpoint(0);
HXDLIN( 653)			 ::verb::core::SurfacePoint left2 = this->midpoint(2);
HXDLIN( 653)			::Array< ::Dynamic> left3 = ::Array_obj< ::Dynamic>::__new(4)->init(0,left)->init(1,left1)->init(2,left2)->init(3,this->corners->__get(3).StaticCast<  ::verb::core::SurfacePoint >());
HXLINE( 654)			 ::verb::core::SurfacePoint right = this->midpoint(0);
HXDLIN( 654)			 ::verb::core::SurfacePoint right1 = this->corners->__get(1).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 654)			 ::verb::core::SurfacePoint right2 = this->corners->__get(2).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 654)			::Array< ::Dynamic> right3 = ::Array_obj< ::Dynamic>::__new(4)->init(0,right)->init(1,right1)->init(2,right2)->init(3,this->midpoint(2));
HXLINE( 656)			 ::verb::eval::AdaptiveRefinementNode _hx_tmp =  ::verb::eval::AdaptiveRefinementNode_obj::__alloc( HX_CTX ,this->srf,left3,null());
HXDLIN( 656)			this->children = ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::verb::eval::AdaptiveRefinementNode_obj::__alloc( HX_CTX ,this->srf,right3,null()));
HXLINE( 658)			this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->neighbors = ::Array_obj< ::Dynamic>::__new(4)->init(0,this->neighbors->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(1,this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(2,this->neighbors->__get(2).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(3,this->neighbors->__get(3).StaticCast<  ::verb::eval::AdaptiveRefinementNode >());
HXLINE( 659)			this->children->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->neighbors = ::Array_obj< ::Dynamic>::__new(4)->init(0,this->neighbors->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(1,this->neighbors->__get(1).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(2,this->neighbors->__get(2).StaticCast<  ::verb::eval::AdaptiveRefinementNode >())->init(3,this->children->__get(0).StaticCast<  ::verb::eval::AdaptiveRefinementNode >());
            		}
HXLINE( 664)		{
HXLINE( 664)			int _g = 0;
HXDLIN( 664)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 664)			while((_g < _g1->length)){
HXLINE( 664)				 ::verb::eval::AdaptiveRefinementNode child = _g1->__get(_g).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
HXDLIN( 664)				_g = (_g + 1);
HXLINE( 665)				child->_divide(options,currentDepth,!(horiz));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(AdaptiveRefinementNode_obj,_divide,(void))

 ::verb::core::MeshData AdaptiveRefinementNode_obj::triangulate( ::verb::core::MeshData mesh){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_670_triangulate)
HXLINE( 672)		if (::hx::IsNull( mesh )) {
HXLINE( 672)			mesh = ::verb::core::MeshData_obj::empty();
            		}
HXLINE( 674)		if (this->isLeaf()) {
HXLINE( 674)			return this->triangulateLeaf(mesh);
            		}
HXLINE( 677)		{
HXLINE( 677)			int _g = 0;
HXDLIN( 677)			::Array< ::Dynamic> _g1 = this->children;
HXDLIN( 677)			while((_g < _g1->length)){
HXLINE( 677)				 ::verb::eval::AdaptiveRefinementNode x = _g1->__get(_g).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
HXDLIN( 677)				_g = (_g + 1);
HXLINE( 678)				if (::hx::IsNull( x )) {
HXLINE( 678)					goto _hx_goto_18;
            				}
HXLINE( 679)				x->triangulate(mesh);
            			}
            			_hx_goto_18:;
            		}
HXLINE( 682)		return mesh;
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,triangulate,return )

 ::verb::core::MeshData AdaptiveRefinementNode_obj::triangulateLeaf( ::verb::core::MeshData mesh){
            	HX_STACKFRAME(&_hx_pos_a8787bb72260b6b7_685_triangulateLeaf)
HXLINE( 687)		int baseIndex = mesh->points->length;
HXDLIN( 687)		::Array< ::Dynamic> uvs = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 687)		::Array< int > ids = ::Array_obj< int >::__new(0);
HXDLIN( 687)		int splitid = 0;
HXLINE( 693)		{
HXLINE( 693)			{
HXLINE( 695)				::Array< ::Dynamic> edgeCorners = this->getAllCorners(0);
HXLINE( 698)				if ((edgeCorners->length == 2)) {
HXLINE( 698)					splitid = 1;
            				}
HXLINE( 700)				{
HXLINE( 700)					int _g = 0;
HXDLIN( 700)					int _g1 = edgeCorners->length;
HXDLIN( 700)					while((_g < _g1)){
HXLINE( 700)						_g = (_g + 1);
HXDLIN( 700)						int j = (_g - 1);
HXLINE( 701)						uvs->push(edgeCorners->__get(j).StaticCast<  ::verb::core::SurfacePoint >());
            					}
            				}
            			}
HXLINE( 693)			{
HXLINE( 695)				::Array< ::Dynamic> edgeCorners1 = this->getAllCorners(1);
HXLINE( 698)				if ((edgeCorners1->length == 2)) {
HXLINE( 698)					splitid = 2;
            				}
HXLINE( 700)				{
HXLINE( 700)					int _g2 = 0;
HXDLIN( 700)					int _g3 = edgeCorners1->length;
HXDLIN( 700)					while((_g2 < _g3)){
HXLINE( 700)						_g2 = (_g2 + 1);
HXDLIN( 700)						int j = (_g2 - 1);
HXLINE( 701)						uvs->push(edgeCorners1->__get(j).StaticCast<  ::verb::core::SurfacePoint >());
            					}
            				}
            			}
HXLINE( 693)			{
HXLINE( 695)				::Array< ::Dynamic> edgeCorners2 = this->getAllCorners(2);
HXLINE( 698)				if ((edgeCorners2->length == 2)) {
HXLINE( 698)					splitid = 3;
            				}
HXLINE( 700)				{
HXLINE( 700)					int _g4 = 0;
HXDLIN( 700)					int _g5 = edgeCorners2->length;
HXDLIN( 700)					while((_g4 < _g5)){
HXLINE( 700)						_g4 = (_g4 + 1);
HXDLIN( 700)						int j = (_g4 - 1);
HXLINE( 701)						uvs->push(edgeCorners2->__get(j).StaticCast<  ::verb::core::SurfacePoint >());
            					}
            				}
            			}
HXLINE( 693)			{
HXLINE( 695)				::Array< ::Dynamic> edgeCorners3 = this->getAllCorners(3);
HXLINE( 698)				if ((edgeCorners3->length == 2)) {
HXLINE( 698)					splitid = 4;
            				}
HXLINE( 700)				{
HXLINE( 700)					int _g6 = 0;
HXDLIN( 700)					int _g7 = edgeCorners3->length;
HXDLIN( 700)					while((_g6 < _g7)){
HXLINE( 700)						_g6 = (_g6 + 1);
HXDLIN( 700)						int j = (_g6 - 1);
HXLINE( 701)						uvs->push(edgeCorners3->__get(j).StaticCast<  ::verb::core::SurfacePoint >());
            					}
            				}
            			}
            		}
HXLINE( 705)		{
HXLINE( 705)			int _g8 = 0;
HXDLIN( 705)			while((_g8 < uvs->length)){
HXLINE( 705)				 ::verb::core::SurfacePoint corner = uvs->__get(_g8).StaticCast<  ::verb::core::SurfacePoint >();
HXDLIN( 705)				_g8 = (_g8 + 1);
HXLINE( 708)				if ((corner->id != -1)) {
HXLINE( 709)					ids->push(corner->id);
HXLINE( 710)					continue;
            				}
HXLINE( 713)				mesh->uvs->push(corner->uv);
HXLINE( 714)				mesh->points->push(corner->point);
HXLINE( 715)				mesh->normals->push(corner->normal);
HXLINE( 717)				corner->id = baseIndex;
HXLINE( 718)				ids->push(baseIndex);
HXLINE( 720)				baseIndex = (baseIndex + 1);
            			}
            		}
HXLINE( 723)		if ((uvs->length == 4)) {
HXLINE( 727)			mesh->faces->push(::Array_obj< int >::__new(3)->init(0,ids->__get(0))->init(1,ids->__get(3))->init(2,ids->__get(1)));
HXLINE( 728)			mesh->faces->push(::Array_obj< int >::__new(3)->init(0,ids->__get(3))->init(1,ids->__get(2))->init(2,ids->__get(1)));
HXLINE( 731)			return mesh;
            		}
            		else {
HXLINE( 733)			if ((uvs->length == 5)) {
HXLINE( 736)				int il = ids->length;
HXLINE( 739)				mesh->faces->push(::Array_obj< int >::__new(3)->init(0,ids->__get(splitid))->init(1,ids->__get(::hx::Mod((splitid + 2),il)))->init(2,ids->__get(::hx::Mod((splitid + 1),il))));
HXLINE( 740)				mesh->faces->push(::Array_obj< int >::__new(3)->init(0,ids->__get(::hx::Mod((splitid + 4),il)))->init(1,ids->__get(::hx::Mod((splitid + 3),il)))->init(2,ids->__get(splitid)));
HXLINE( 741)				mesh->faces->push(::Array_obj< int >::__new(3)->init(0,ids->__get(splitid))->init(1,ids->__get(::hx::Mod((splitid + 3),il)))->init(2,ids->__get(::hx::Mod((splitid + 2),il))));
HXLINE( 743)				return mesh;
            			}
            		}
HXLINE( 748)		 ::verb::core::SurfacePoint center = this->center();
HXLINE( 750)		mesh->uvs->push(center->uv);
HXLINE( 751)		mesh->points->push(center->point);
HXLINE( 752)		mesh->normals->push(center->normal);
HXLINE( 755)		int centerIndex = (mesh->points->length - 1);
HXLINE( 758)		int i = 0;
HXLINE( 759)		int j = (uvs->length - 1);
HXLINE( 760)		while((i < uvs->length)){
HXLINE( 761)			mesh->faces->push(::Array_obj< int >::__new(3)->init(0,centerIndex)->init(1,ids->__get(i))->init(2,ids->__get(j)));
HXLINE( 762)			i = (i + 1);
HXDLIN( 762)			j = (i - 1);
            		}
HXLINE( 765)		return mesh;
            	}


HX_DEFINE_DYNAMIC_FUNC1(AdaptiveRefinementNode_obj,triangulateLeaf,return )


::hx::ObjectPtr< AdaptiveRefinementNode_obj > AdaptiveRefinementNode_obj::__new( ::verb::core::NurbsSurfaceData srf,::Array< ::Dynamic> corners,::Array< ::Dynamic> neighbors) {
	::hx::ObjectPtr< AdaptiveRefinementNode_obj > __this = new AdaptiveRefinementNode_obj();
	__this->__construct(srf,corners,neighbors);
	return __this;
}

::hx::ObjectPtr< AdaptiveRefinementNode_obj > AdaptiveRefinementNode_obj::__alloc(::hx::Ctx *_hx_ctx, ::verb::core::NurbsSurfaceData srf,::Array< ::Dynamic> corners,::Array< ::Dynamic> neighbors) {
	AdaptiveRefinementNode_obj *__this = (AdaptiveRefinementNode_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(AdaptiveRefinementNode_obj), true, "verb.eval.AdaptiveRefinementNode"));
	*(void **)__this = AdaptiveRefinementNode_obj::_hx_vtable;
	__this->__construct(srf,corners,neighbors);
	return __this;
}

AdaptiveRefinementNode_obj::AdaptiveRefinementNode_obj()
{
}

void AdaptiveRefinementNode_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(AdaptiveRefinementNode);
	HX_MARK_MEMBER_NAME(srf,"srf");
	HX_MARK_MEMBER_NAME(neighbors,"neighbors");
	HX_MARK_MEMBER_NAME(children,"children");
	HX_MARK_MEMBER_NAME(corners,"corners");
	HX_MARK_MEMBER_NAME(midPoints,"midPoints");
	HX_MARK_MEMBER_NAME(centerPoint,"centerPoint");
	HX_MARK_MEMBER_NAME(splitVert,"splitVert");
	HX_MARK_MEMBER_NAME(splitHoriz,"splitHoriz");
	HX_MARK_MEMBER_NAME(horizontal,"horizontal");
	HX_MARK_MEMBER_NAME(u05,"u05");
	HX_MARK_MEMBER_NAME(v05,"v05");
	HX_MARK_END_CLASS();
}

void AdaptiveRefinementNode_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(srf,"srf");
	HX_VISIT_MEMBER_NAME(neighbors,"neighbors");
	HX_VISIT_MEMBER_NAME(children,"children");
	HX_VISIT_MEMBER_NAME(corners,"corners");
	HX_VISIT_MEMBER_NAME(midPoints,"midPoints");
	HX_VISIT_MEMBER_NAME(centerPoint,"centerPoint");
	HX_VISIT_MEMBER_NAME(splitVert,"splitVert");
	HX_VISIT_MEMBER_NAME(splitHoriz,"splitHoriz");
	HX_VISIT_MEMBER_NAME(horizontal,"horizontal");
	HX_VISIT_MEMBER_NAME(u05,"u05");
	HX_VISIT_MEMBER_NAME(v05,"v05");
}

::hx::Val AdaptiveRefinementNode_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"srf") ) { return ::hx::Val( srf ); }
		if (HX_FIELD_EQ(inName,"u05") ) { return ::hx::Val( u05 ); }
		if (HX_FIELD_EQ(inName,"v05") ) { return ::hx::Val( v05 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"isLeaf") ) { return ::hx::Val( isLeaf_dyn() ); }
		if (HX_FIELD_EQ(inName,"center") ) { return ::hx::Val( center_dyn() ); }
		if (HX_FIELD_EQ(inName,"divide") ) { return ::hx::Val( divide_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"corners") ) { return ::hx::Val( corners ); }
		if (HX_FIELD_EQ(inName,"evalSrf") ) { return ::hx::Val( evalSrf_dyn() ); }
		if (HX_FIELD_EQ(inName,"_divide") ) { return ::hx::Val( _divide_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"children") ) { return ::hx::Val( children ); }
		if (HX_FIELD_EQ(inName,"midpoint") ) { return ::hx::Val( midpoint_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"neighbors") ) { return ::hx::Val( neighbors ); }
		if (HX_FIELD_EQ(inName,"midPoints") ) { return ::hx::Val( midPoints ); }
		if (HX_FIELD_EQ(inName,"splitVert") ) { return ::hx::Val( splitVert ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"splitHoriz") ) { return ::hx::Val( splitHoriz ); }
		if (HX_FIELD_EQ(inName,"horizontal") ) { return ::hx::Val( horizontal ); }
		if (HX_FIELD_EQ(inName,"fixNormals") ) { return ::hx::Val( fixNormals_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"centerPoint") ) { return ::hx::Val( centerPoint ); }
		if (HX_FIELD_EQ(inName,"evalCorners") ) { return ::hx::Val( evalCorners_dyn() ); }
		if (HX_FIELD_EQ(inName,"triangulate") ) { return ::hx::Val( triangulate_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"shouldDivide") ) { return ::hx::Val( shouldDivide_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getAllCorners") ) { return ::hx::Val( getAllCorners_dyn() ); }
		if (HX_FIELD_EQ(inName,"hasBadNormals") ) { return ::hx::Val( hasBadNormals_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getEdgeCorners") ) { return ::hx::Val( getEdgeCorners_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"triangulateLeaf") ) { return ::hx::Val( triangulateLeaf_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val AdaptiveRefinementNode_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"srf") ) { srf=inValue.Cast<  ::verb::core::NurbsSurfaceData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"u05") ) { u05=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"v05") ) { v05=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"corners") ) { corners=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"children") ) { children=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"neighbors") ) { neighbors=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"midPoints") ) { midPoints=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"splitVert") ) { splitVert=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"splitHoriz") ) { splitHoriz=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"horizontal") ) { horizontal=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"centerPoint") ) { centerPoint=inValue.Cast<  ::verb::core::SurfacePoint >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void AdaptiveRefinementNode_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("srf",e7,a6,57,00));
	outFields->push(HX_("neighbors",41,df,79,94));
	outFields->push(HX_("children",3f,19,6a,70));
	outFields->push(HX_("corners",fe,9a,1a,63));
	outFields->push(HX_("midPoints",cb,6d,9f,b0));
	outFields->push(HX_("centerPoint",3b,ba,5f,98));
	outFields->push(HX_("splitVert",ab,c0,ab,52));
	outFields->push(HX_("splitHoriz",02,cf,9c,fa));
	outFields->push(HX_("horizontal",e4,fc,c3,15));
	outFields->push(HX_("u05",ba,f1,58,00));
	outFields->push(HX_("v05",fb,b3,59,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo AdaptiveRefinementNode_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::verb::core::NurbsSurfaceData */ ,(int)offsetof(AdaptiveRefinementNode_obj,srf),HX_("srf",e7,a6,57,00)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(AdaptiveRefinementNode_obj,neighbors),HX_("neighbors",41,df,79,94)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(AdaptiveRefinementNode_obj,children),HX_("children",3f,19,6a,70)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(AdaptiveRefinementNode_obj,corners),HX_("corners",fe,9a,1a,63)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(AdaptiveRefinementNode_obj,midPoints),HX_("midPoints",cb,6d,9f,b0)},
	{::hx::fsObject /*  ::verb::core::SurfacePoint */ ,(int)offsetof(AdaptiveRefinementNode_obj,centerPoint),HX_("centerPoint",3b,ba,5f,98)},
	{::hx::fsBool,(int)offsetof(AdaptiveRefinementNode_obj,splitVert),HX_("splitVert",ab,c0,ab,52)},
	{::hx::fsBool,(int)offsetof(AdaptiveRefinementNode_obj,splitHoriz),HX_("splitHoriz",02,cf,9c,fa)},
	{::hx::fsBool,(int)offsetof(AdaptiveRefinementNode_obj,horizontal),HX_("horizontal",e4,fc,c3,15)},
	{::hx::fsFloat,(int)offsetof(AdaptiveRefinementNode_obj,u05),HX_("u05",ba,f1,58,00)},
	{::hx::fsFloat,(int)offsetof(AdaptiveRefinementNode_obj,v05),HX_("v05",fb,b3,59,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *AdaptiveRefinementNode_obj_sStaticStorageInfo = 0;
#endif

static ::String AdaptiveRefinementNode_obj_sMemberFields[] = {
	HX_("srf",e7,a6,57,00),
	HX_("neighbors",41,df,79,94),
	HX_("children",3f,19,6a,70),
	HX_("corners",fe,9a,1a,63),
	HX_("midPoints",cb,6d,9f,b0),
	HX_("centerPoint",3b,ba,5f,98),
	HX_("splitVert",ab,c0,ab,52),
	HX_("splitHoriz",02,cf,9c,fa),
	HX_("horizontal",e4,fc,c3,15),
	HX_("u05",ba,f1,58,00),
	HX_("v05",fb,b3,59,00),
	HX_("isLeaf",a8,c8,16,65),
	HX_("center",d5,25,db,05),
	HX_("evalCorners",c2,42,40,b9),
	HX_("evalSrf",ab,1c,95,b7),
	HX_("getEdgeCorners",4b,7f,e9,1c),
	HX_("getAllCorners",13,fc,35,88),
	HX_("midpoint",c8,15,08,2b),
	HX_("hasBadNormals",21,91,31,f5),
	HX_("fixNormals",17,eb,80,eb),
	HX_("shouldDivide",0c,f4,49,ff),
	HX_("divide",79,2f,12,bf),
	HX_("_divide",18,41,89,2d),
	HX_("triangulate",2c,65,9d,e9),
	HX_("triangulateLeaf",ea,9a,de,7c),
	::String(null()) };

::hx::Class AdaptiveRefinementNode_obj::__mClass;

void AdaptiveRefinementNode_obj::__register()
{
	AdaptiveRefinementNode_obj _hx_dummy;
	AdaptiveRefinementNode_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.AdaptiveRefinementNode",a6,9f,56,05);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AdaptiveRefinementNode_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AdaptiveRefinementNode_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AdaptiveRefinementNode_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AdaptiveRefinementNode_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
