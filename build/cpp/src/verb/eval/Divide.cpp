// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_Mat
#include <verb/core/Mat.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_Analyze
#include <verb/eval/Analyze.h>
#endif
#ifndef INCLUDED_verb_eval_CurveLengthSample
#include <verb/eval/CurveLengthSample.h>
#endif
#ifndef INCLUDED_verb_eval_Divide
#include <verb/eval/Divide.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif
#ifndef INCLUDED_verb_eval_Modify
#include <verb/eval/Modify.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_eda4d4f7dfd5faf7_27_surfaceSplit,"verb.eval.Divide","surfaceSplit",0xdc8e713f,"verb.eval.Divide.surfaceSplit","verb/eval/Divide.hx",27,0x85f5d802)
HX_LOCAL_STACK_FRAME(_hx_pos_eda4d4f7dfd5faf7_85_curveSplit,"verb.eval.Divide","curveSplit",0xa694bafd,"verb.eval.Divide.curveSplit","verb/eval/Divide.hx",85,0x85f5d802)
HX_LOCAL_STACK_FRAME(_hx_pos_eda4d4f7dfd5faf7_122_rationalCurveByEqualArcLength,"verb.eval.Divide","rationalCurveByEqualArcLength",0xccb755ea,"verb.eval.Divide.rationalCurveByEqualArcLength","verb/eval/Divide.hx",122,0x85f5d802)
HX_LOCAL_STACK_FRAME(_hx_pos_eda4d4f7dfd5faf7_142_rationalCurveByArcLength,"verb.eval.Divide","rationalCurveByArcLength",0xf443ff32,"verb.eval.Divide.rationalCurveByArcLength","verb/eval/Divide.hx",142,0x85f5d802)
namespace verb{
namespace eval{

void Divide_obj::__construct() { }

Dynamic Divide_obj::__CreateEmpty() { return new Divide_obj; }

void *Divide_obj::_hx_vtable = 0;

Dynamic Divide_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Divide_obj > _hx_result = new Divide_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Divide_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0dad7ab8;
}

::Array< ::Dynamic> Divide_obj::surfaceSplit( ::verb::core::NurbsSurfaceData surface,Float u,::hx::Null< bool >  __o_useV){
            		bool useV = __o_useV.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_eda4d4f7dfd5faf7_27_surfaceSplit)
HXLINE(  29)		::Array< Float > knots;
HXDLIN(  29)		int degree;
HXDLIN(  29)		::Array< ::Dynamic> controlPoints;
HXLINE(  33)		if (!(useV)) {
HXLINE(  34)			controlPoints = ::verb::core::Mat_obj::transposeN(surface->controlPoints);
HXLINE(  35)			knots = surface->knotsU;
HXLINE(  36)			degree = surface->degreeU;
            		}
            		else {
HXLINE(  38)			controlPoints = surface->controlPoints;
HXLINE(  39)			knots = surface->knotsV;
HXLINE(  40)			degree = surface->degreeV;
            		}
HXLINE(  43)		::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN(  43)		{
HXLINE(  43)			int _g1 = 0;
HXDLIN(  43)			int _g2 = (degree + 1);
HXDLIN(  43)			while((_g1 < _g2)){
HXLINE(  43)				_g1 = (_g1 + 1);
HXDLIN(  43)				int i = (_g1 - 1);
HXDLIN(  43)				_g->push(u);
            			}
            		}
HXDLIN(  43)		::Array< Float > knots_to_insert = _g;
HXLINE(  45)		::Array< ::Dynamic> newpts0 = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  45)		::Array< ::Dynamic> newpts1 = ::Array_obj< ::Dynamic>::__new();
HXLINE(  48)		int s = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXLINE(  49)		 ::verb::core::NurbsCurveData res = null();
HXLINE(  51)		{
HXLINE(  51)			int _g3 = 0;
HXDLIN(  51)			while((_g3 < controlPoints->length)){
HXLINE(  51)				::Array< ::Dynamic> cps = controlPoints->__get(_g3).StaticCast< ::Array< ::Dynamic> >();
HXDLIN(  51)				_g3 = (_g3 + 1);
HXLINE(  52)				res = ::verb::eval::Modify_obj::curveKnotRefine( ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots,cps),knots_to_insert);
HXLINE(  54)				newpts0->push(res->controlPoints->slice(0,(s + 1)));
HXLINE(  55)				newpts1->push(res->controlPoints->slice((s + 1),null()));
            			}
            		}
HXLINE(  58)		::Array< Float > knots0 = res->knots->slice(0,((s + degree) + 2));
HXLINE(  59)		::Array< Float > knots1 = res->knots->slice((s + 1),null());
HXLINE(  61)		if (!(useV)) {
HXLINE(  62)			newpts0 = ::verb::core::Mat_obj::transposeN(newpts0);
HXLINE(  63)			newpts1 = ::verb::core::Mat_obj::transposeN(newpts1);
HXLINE(  65)			int surface1 = surface->degreeV;
HXDLIN(  65)			 ::verb::core::NurbsSurfaceData _hx_tmp =  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,degree,surface1,knots0,surface->knotsV->copy(),newpts0);
HXLINE(  66)			int surface2 = surface->degreeV;
HXLINE(  65)			return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,degree,surface2,knots1,surface->knotsV->copy(),newpts1));
            		}
HXLINE(  70)		int surface1 = surface->degreeU;
HXDLIN(  70)		 ::verb::core::NurbsSurfaceData _hx_tmp =  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,degree,surface->knotsU->copy(),knots0,newpts0);
HXLINE(  71)		int surface2 = surface->degreeU;
HXLINE(  70)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface2,degree,surface->knotsU->copy(),knots1,newpts1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Divide_obj,surfaceSplit,return )

::Array< ::Dynamic> Divide_obj::curveSplit( ::verb::core::NurbsCurveData curve,Float u){
            	HX_GC_STACKFRAME(&_hx_pos_eda4d4f7dfd5faf7_85_curveSplit)
HXLINE(  87)		int degree = curve->degree;
HXDLIN(  87)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN(  87)		::Array< Float > knots = curve->knots;
HXLINE(  91)		::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN(  91)		{
HXLINE(  91)			int _g1 = 0;
HXDLIN(  91)			int _g2 = (degree + 1);
HXDLIN(  91)			while((_g1 < _g2)){
HXLINE(  91)				_g1 = (_g1 + 1);
HXDLIN(  91)				int i = (_g1 - 1);
HXDLIN(  91)				_g->push(u);
            			}
            		}
HXDLIN(  91)		::Array< Float > knots_to_insert = _g;
HXLINE(  92)		 ::verb::core::NurbsCurveData res = ::verb::eval::Modify_obj::curveKnotRefine(curve,knots_to_insert);
HXLINE(  94)		int s = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXLINE(  96)		::Array< Float > knots0 = res->knots->slice(0,((s + degree) + 2));
HXLINE(  97)		::Array< Float > knots1 = res->knots->slice((s + 1),null());
HXLINE(  99)		::Array< ::Dynamic> cpts0 = res->controlPoints->slice(0,(s + 1));
HXLINE( 100)		::Array< ::Dynamic> cpts1 = res->controlPoints->slice((s + 1),null());
HXLINE( 103)		 ::verb::core::NurbsCurveData _hx_tmp =  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots0,cpts0);
HXLINE( 102)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots1,cpts1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Divide_obj,curveSplit,return )

::Array< ::Dynamic> Divide_obj::rationalCurveByEqualArcLength( ::verb::core::NurbsCurveData curve,int num){
            	HX_STACKFRAME(&_hx_pos_eda4d4f7dfd5faf7_122_rationalCurveByEqualArcLength)
HXLINE( 124)		Float tlen = ::verb::eval::Analyze_obj::rationalCurveArcLength(curve,null(),null());
HXLINE( 125)		Float inc = (tlen / ( (Float)(num) ));
HXLINE( 127)		return ::verb::eval::Divide_obj::rationalCurveByArcLength(curve,inc);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Divide_obj,rationalCurveByEqualArcLength,return )

::Array< ::Dynamic> Divide_obj::rationalCurveByArcLength( ::verb::core::NurbsCurveData curve,Float l){
            	HX_GC_STACKFRAME(&_hx_pos_eda4d4f7dfd5faf7_142_rationalCurveByArcLength)
HXLINE( 144)		::Array< ::Dynamic> crvs = ::verb::eval::Modify_obj::decomposeCurveIntoBeziers(curve);
HXLINE( 145)		::Array< Float > result = ::Array_obj< Float >::__new(crvs->length);
HXDLIN( 145)		{
HXLINE( 145)			int _g = 0;
HXDLIN( 145)			int _g1 = crvs->length;
HXDLIN( 145)			while((_g < _g1)){
HXLINE( 145)				_g = (_g + 1);
HXDLIN( 145)				int i = (_g - 1);
HXDLIN( 145)				{
HXLINE( 145)					Float inValue = ::verb::eval::Analyze_obj::rationalBezierCurveArcLength(( ( ::verb::core::NurbsCurveData)(_hx_array_unsafe_get(crvs,i)) ),null(),null());
HXDLIN( 145)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXLINE( 144)		::Array< Float > crvlens = result;
HXDLIN( 144)		Float totlen = ::verb::core::Vec_obj::sum(crvlens);
HXDLIN( 144)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(1)->init(0, ::verb::eval::CurveLengthSample_obj::__alloc( HX_CTX ,curve->knots->__get(0),((Float)0.0)));
HXLINE( 149)		if ((l > totlen)) {
HXLINE( 149)			return pts;
            		}
HXLINE( 151)		Float inc = l;
HXDLIN( 151)		int i = 0;
HXDLIN( 151)		Float lc = inc;
HXDLIN( 151)		Float runsum = ((Float)0.0);
HXDLIN( 151)		Float runsum1 = ((Float)0.0);
HXDLIN( 151)		Float u;
HXLINE( 158)		while((i < crvs->length)){
HXLINE( 160)			runsum = (runsum + crvlens->__get(i));
HXLINE( 162)			while((lc < (runsum + ::verb::core::Constants_obj::EPSILON))){
HXLINE( 164)				u = ::verb::eval::Analyze_obj::rationalBezierCurveParamAtArcLength(crvs->__get(i).StaticCast<  ::verb::core::NurbsCurveData >(),(lc - runsum1),::verb::core::Constants_obj::TOLERANCE,crvlens->__get(i));
HXLINE( 166)				pts->push( ::verb::eval::CurveLengthSample_obj::__alloc( HX_CTX ,u,lc));
HXLINE( 167)				lc = (lc + inc);
            			}
HXLINE( 171)			runsum1 = (runsum1 + crvlens->__get(i));
HXLINE( 173)			i = (i + 1);
            		}
HXLINE( 177)		return pts;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Divide_obj,rationalCurveByArcLength,return )


Divide_obj::Divide_obj()
{
}

bool Divide_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"curveSplit") ) { outValue = curveSplit_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"surfaceSplit") ) { outValue = surfaceSplit_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"rationalCurveByArcLength") ) { outValue = rationalCurveByArcLength_dyn(); return true; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"rationalCurveByEqualArcLength") ) { outValue = rationalCurveByEqualArcLength_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Divide_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Divide_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Divide_obj::__mClass;

static ::String Divide_obj_sStaticFields[] = {
	HX_("surfaceSplit",6d,71,90,53),
	HX_("curveSplit",ab,b3,24,df),
	HX_("rationalCurveByEqualArcLength",fc,41,6a,a1),
	HX_("rationalCurveByArcLength",60,8c,dc,6e),
	::String(null())
};

void Divide_obj::__register()
{
	Divide_obj _hx_dummy;
	Divide_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Divide",dc,53,14,c2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Divide_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Divide_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Divide_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Divide_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Divide_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
