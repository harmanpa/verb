// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_Binomial
#include <verb/core/Binomial.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_Pair
#include <verb/core/Pair.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_core_VolumeData
#include <verb/core/VolumeData.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_32_rationalCurveTangent,"verb.eval.Eval","rationalCurveTangent",0xdc731d33,"verb.eval.Eval.rationalCurveTangent","verb/eval/Eval.hx",32,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_49_rationalSurfaceNormal,"verb.eval.Eval","rationalSurfaceNormal",0xec8bbc37,"verb.eval.Eval.rationalSurfaceNormal","verb/eval/Eval.hx",49,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_70_rationalSurfaceDerivatives,"verb.eval.Eval","rationalSurfaceDerivatives",0x743b4e7c,"verb.eval.Eval.rationalSurfaceDerivatives","verb/eval/Eval.hx",70,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_126_rationalSurfacePoint,"verb.eval.Eval","rationalSurfacePoint",0xad005c40,"verb.eval.Eval.rationalSurfacePoint","verb/eval/Eval.hx",126,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_141_rationalCurveDerivatives,"verb.eval.Eval","rationalCurveDerivatives",0x15ad61fa,"verb.eval.Eval.rationalCurveDerivatives","verb/eval/Eval.hx",141,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_180_rationalCurvePoint,"verb.eval.Eval","rationalCurvePoint",0x91f69d3e,"verb.eval.Eval.rationalCurvePoint","verb/eval/Eval.hx",180,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_196_surfaceDerivatives,"verb.eval.Eval","surfaceDerivatives",0xfcec6f2e,"verb.eval.Eval.surfaceDerivatives","verb/eval/Eval.hx",196,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_225_surfaceDerivativesGivenNM,"verb.eval.Eval","surfaceDerivativesGivenNM",0x976b816e,"verb.eval.Eval.surfaceDerivativesGivenNM","verb/eval/Eval.hx",225,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_286_surfacePoint,"verb.eval.Eval","surfacePoint",0x40d30b72,"verb.eval.Eval.surfacePoint","verb/eval/Eval.hx",286,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_310_surfacePointGivenNM,"verb.eval.Eval","surfacePointGivenNM",0x2b36b5aa,"verb.eval.Eval.surfacePointGivenNM","verb/eval/Eval.hx",310,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_351_curveRegularSamplePoints,"verb.eval.Eval","curveRegularSamplePoints",0x64663a09,"verb.eval.Eval.curveRegularSamplePoints","verb/eval/Eval.hx",351,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_387_curveRegularSamplePoints2,"verb.eval.Eval","curveRegularSamplePoints2",0x750c8e09,"verb.eval.Eval.curveRegularSamplePoints2","verb/eval/Eval.hx",387,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_435_rationalSurfaceRegularSampleDerivatives,"verb.eval.Eval","rationalSurfaceRegularSampleDerivatives",0xb0995a96,"verb.eval.Eval.rationalSurfaceRegularSampleDerivatives","verb/eval/Eval.hx",435,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_505_surfaceRegularSampleDerivatives,"verb.eval.Eval","surfaceRegularSampleDerivatives",0xd43832a4,"verb.eval.Eval.surfaceRegularSampleDerivatives","verb/eval/Eval.hx",505,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_552_rationalSurfaceRegularSamplePoints,"verb.eval.Eval","rationalSurfaceRegularSamplePoints",0x0721c659,"verb.eval.Eval.rationalSurfaceRegularSamplePoints","verb/eval/Eval.hx",552,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_568_surfaceRegularSamplePoints,"verb.eval.Eval","surfaceRegularSamplePoints",0x01cde90b,"verb.eval.Eval.surfaceRegularSamplePoints","verb/eval/Eval.hx",568,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_601_regularlySpacedBasisFunctions,"verb.eval.Eval","regularlySpacedBasisFunctions",0x6bb50a55,"verb.eval.Eval.regularlySpacedBasisFunctions","verb/eval/Eval.hx",601,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_623_regularlySpacedDerivativeBasisFunctions,"verb.eval.Eval","regularlySpacedDerivativeBasisFunctions",0x359a9ebc,"verb.eval.Eval.regularlySpacedDerivativeBasisFunctions","verb/eval/Eval.hx",623,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_652_surfacePointGivenBasesKnotSpans,"verb.eval.Eval","surfacePointGivenBasesKnotSpans",0x8211062a,"verb.eval.Eval.surfacePointGivenBasesKnotSpans","verb/eval/Eval.hx",652,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_685_surfaceDerivativesGivenBasesKnotSpans,"verb.eval.Eval","surfaceDerivativesGivenBasesKnotSpans",0x772a67ee,"verb.eval.Eval.surfaceDerivativesGivenBasesKnotSpans","verb/eval/Eval.hx",685,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_730_curveDerivatives,"verb.eval.Eval","curveDerivatives",0xe40c922c,"verb.eval.Eval.curveDerivatives","verb/eval/Eval.hx",730,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_750_curveDerivativesGivenN,"verb.eval.Eval","curveDerivativesGivenN",0xff2c337d,"verb.eval.Eval.curveDerivativesGivenN","verb/eval/Eval.hx",750,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_787_curvePoint,"verb.eval.Eval","curvePoint",0x5c7ebbf0,"verb.eval.Eval.curvePoint","verb/eval/Eval.hx",787,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_806_areValidRelations,"verb.eval.Eval","areValidRelations",0xd0ca6020,"verb.eval.Eval.areValidRelations","verb/eval/Eval.hx",806,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_822_curvePointGivenN,"verb.eval.Eval","curvePointGivenN",0x1f920841,"verb.eval.Eval.curvePointGivenN","verb/eval/Eval.hx",822,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_857_volumePoint,"verb.eval.Eval","volumePoint",0x52ffba67,"verb.eval.Eval.volumePoint","verb/eval/Eval.hx",857,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_884_volumePointGivenNML,"verb.eval.Eval","volumePointGivenNML",0xb93c6b57,"verb.eval.Eval.volumePointGivenNML","verb/eval/Eval.hx",884,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_950_derivativeBasisFunctions,"verb.eval.Eval","derivativeBasisFunctions",0x5156c933,"verb.eval.Eval.derivativeBasisFunctions","verb/eval/Eval.hx",950,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_975_derivativeBasisFunctionsGivenNI,"verb.eval.Eval","derivativeBasisFunctionsGivenNI",0xde5ca205,"verb.eval.Eval.derivativeBasisFunctionsGivenNI","verb/eval/Eval.hx",975,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1086_basisFunctions,"verb.eval.Eval","basisFunctions",0x606dca0c,"verb.eval.Eval.basisFunctions","verb/eval/Eval.hx",1086,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1110_basisFunctionsGivenKnotSpanIndex,"verb.eval.Eval","basisFunctionsGivenKnotSpanIndex",0xc641d2af,"verb.eval.Eval.basisFunctionsGivenKnotSpanIndex","verb/eval/Eval.hx",1110,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1151_knotSpan,"verb.eval.Eval","knotSpan",0x4fa5b581,"verb.eval.Eval.knotSpan","verb/eval/Eval.hx",1151,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1170_knotSpanGivenN,"verb.eval.Eval","knotSpanGivenN",0xe1620492,"verb.eval.Eval.knotSpanGivenN","verb/eval/Eval.hx",1170,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1211_dehomogenize,"verb.eval.Eval","dehomogenize",0xc51f92fd,"verb.eval.Eval.dehomogenize","verb/eval/Eval.hx",1211,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1236_rational1d,"verb.eval.Eval","rational1d",0xb8258210,"verb.eval.Eval.rational1d","verb/eval/Eval.hx",1236,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1253_rational2d,"verb.eval.Eval","rational2d",0xb82582ef,"verb.eval.Eval.rational2d","verb/eval/Eval.hx",1253,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1267_weight1d,"verb.eval.Eval","weight1d",0xb34c879a,"verb.eval.Eval.weight1d","verb/eval/Eval.hx",1267,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1284_weight2d,"verb.eval.Eval","weight2d",0xb34c8879,"verb.eval.Eval.weight2d","verb/eval/Eval.hx",1284,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1298_dehomogenize1d,"verb.eval.Eval","dehomogenize1d",0xfa683750,"verb.eval.Eval.dehomogenize1d","verb/eval/Eval.hx",1298,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1312_dehomogenize2d,"verb.eval.Eval","dehomogenize2d",0xfa68382f,"verb.eval.Eval.dehomogenize2d","verb/eval/Eval.hx",1312,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1328_homogenize1d,"verb.eval.Eval","homogenize1d",0xc141a08f,"verb.eval.Eval.homogenize1d","verb/eval/Eval.hx",1328,0xd549a27f)
HX_LOCAL_STACK_FRAME(_hx_pos_3844315661bdc8bc_1369_homogenize2d,"verb.eval.Eval","homogenize2d",0xc141a16e,"verb.eval.Eval.homogenize2d","verb/eval/Eval.hx",1369,0xd549a27f)
namespace verb{
namespace eval{

void Eval_obj::__construct() { }

Dynamic Eval_obj::__CreateEmpty() { return new Eval_obj; }

void *Eval_obj::_hx_vtable = 0;

Dynamic Eval_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Eval_obj > _hx_result = new Eval_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Eval_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7ac88223;
}

::Array< Float > Eval_obj::rationalCurveTangent( ::verb::core::NurbsCurveData curve,Float u){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_32_rationalCurveTangent)
HXLINE(  33)		::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::rationalCurveDerivatives(curve,u,1);
HXLINE(  34)		return derivs->__get(1).StaticCast< ::Array< Float > >();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,rationalCurveTangent,return )

::Array< Float > Eval_obj::rationalSurfaceNormal( ::verb::core::NurbsSurfaceData surface,Float u,Float v){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_49_rationalSurfaceNormal)
HXLINE(  50)		::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface,u,v,1);
HXLINE(  51)		return ::verb::core::Vec_obj::cross(derivs->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >(),derivs->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,rationalSurfaceNormal,return )

::Array< ::Dynamic> Eval_obj::rationalSurfaceDerivatives( ::verb::core::NurbsSurfaceData surface,Float u,Float v,::hx::Null< int >  __o_numDerivs){
            		int numDerivs = __o_numDerivs.Default(1);
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_70_rationalSurfaceDerivatives)
HXLINE(  72)		::Array< ::Dynamic> ders = ::verb::eval::Eval_obj::surfaceDerivatives(surface,u,v,numDerivs);
HXDLIN(  72)		::Array< ::Dynamic> Aders = ::verb::eval::Eval_obj::rational2d(ders);
HXDLIN(  72)		::Array< ::Dynamic> wders = ::verb::eval::Eval_obj::weight2d(ders);
HXDLIN(  72)		::Array< ::Dynamic> SKL = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  72)		int dim = Aders->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE(  78)		{
HXLINE(  78)			int _g = 0;
HXDLIN(  78)			int _g1 = (numDerivs + 1);
HXDLIN(  78)			while((_g < _g1)){
HXLINE(  78)				_g = (_g + 1);
HXDLIN(  78)				int k = (_g - 1);
HXLINE(  79)				SKL->push(::Array_obj< ::Dynamic>::__new());
HXLINE(  81)				{
HXLINE(  81)					int _g1 = 0;
HXDLIN(  81)					int _g2 = ((numDerivs - k) + 1);
HXDLIN(  81)					while((_g1 < _g2)){
HXLINE(  81)						_g1 = (_g1 + 1);
HXDLIN(  81)						int l = (_g1 - 1);
HXLINE(  82)						::Array< Float > v = Aders->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >();
HXLINE(  84)						{
HXLINE(  84)							int _g = 1;
HXDLIN(  84)							int _g2 = (l + 1);
HXDLIN(  84)							while((_g < _g2)){
HXLINE(  84)								_g = (_g + 1);
HXDLIN(  84)								int j = (_g - 1);
HXLINE(  85)								Float _hx_tmp = ::verb::core::Binomial_obj::get(l,j);
HXDLIN(  85)								::verb::core::Vec_obj::subMulMutate(v,(_hx_tmp * wders->__get(0).StaticCast< ::Array< Float > >()->__get(j)),SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get((l - j)).StaticCast< ::Array< Float > >());
            							}
            						}
HXLINE(  88)						{
HXLINE(  88)							int _g3 = 1;
HXDLIN(  88)							int _g4 = (k + 1);
HXDLIN(  88)							while((_g3 < _g4)){
HXLINE(  88)								_g3 = (_g3 + 1);
HXDLIN(  88)								int i = (_g3 - 1);
HXLINE(  89)								Float _hx_tmp = ::verb::core::Binomial_obj::get(k,i);
HXDLIN(  89)								::verb::core::Vec_obj::subMulMutate(v,(_hx_tmp * wders->__get(i).StaticCast< ::Array< Float > >()->__get(0)),SKL->__get((k - i)).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >());
HXLINE(  91)								::Array< Float > v2 = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE(  93)								{
HXLINE(  93)									int _g = 1;
HXDLIN(  93)									int _g1 = (l + 1);
HXDLIN(  93)									while((_g < _g1)){
HXLINE(  93)										_g = (_g + 1);
HXDLIN(  93)										int j = (_g - 1);
HXLINE(  94)										Float _hx_tmp = ::verb::core::Binomial_obj::get(l,j);
HXDLIN(  94)										::verb::core::Vec_obj::addMulMutate(v2,(_hx_tmp * wders->__get(i).StaticCast< ::Array< Float > >()->__get(j)),SKL->__get((k - i)).StaticCast< ::Array< ::Dynamic> >()->__get((l - j)).StaticCast< ::Array< Float > >());
            									}
            								}
HXLINE(  97)								::verb::core::Vec_obj::subMulMutate(v,::verb::core::Binomial_obj::get(k,i),v2);
            							}
            						}
HXLINE( 100)						::verb::core::Vec_obj::mulMutate((( (Float)(1) ) / wders->__get(0).StaticCast< ::Array< Float > >()->__get(0)),v);
HXLINE( 101)						SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->push(v);
            					}
            				}
            			}
            		}
HXLINE( 105)		return SKL;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,rationalSurfaceDerivatives,return )

::Array< Float > Eval_obj::rationalSurfacePoint( ::verb::core::NurbsSurfaceData surface,Float u,Float v){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_126_rationalSurfacePoint)
HXDLIN( 126)		return ::verb::eval::Eval_obj::dehomogenize(::verb::eval::Eval_obj::surfacePoint(surface,u,v));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,rationalSurfacePoint,return )

::Array< ::Dynamic> Eval_obj::rationalCurveDerivatives( ::verb::core::NurbsCurveData curve,Float u,::hx::Null< int >  __o_numDerivs){
            		int numDerivs = __o_numDerivs.Default(1);
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_141_rationalCurveDerivatives)
HXLINE( 143)		::Array< ::Dynamic> ders = ::verb::eval::Eval_obj::curveDerivatives(curve,u,numDerivs);
HXDLIN( 143)		::Array< ::Dynamic> Aders = ::verb::eval::Eval_obj::rational1d(ders);
HXDLIN( 143)		::Array< Float > wders = ::verb::eval::Eval_obj::weight1d(ders);
HXDLIN( 143)		int k = 0;
HXDLIN( 143)		int i = 0;
HXDLIN( 143)		::Array< ::Dynamic> CK = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 150)		{
HXLINE( 150)			int _g = 0;
HXDLIN( 150)			int _g1 = (numDerivs + 1);
HXDLIN( 150)			while((_g < _g1)){
HXLINE( 150)				_g = (_g + 1);
HXDLIN( 150)				int k = (_g - 1);
HXLINE( 151)				::Array< Float > v = Aders->__get(k).StaticCast< ::Array< Float > >();
HXLINE( 153)				{
HXLINE( 153)					int _g1 = 1;
HXDLIN( 153)					int _g2 = (k + 1);
HXDLIN( 153)					while((_g1 < _g2)){
HXLINE( 153)						_g1 = (_g1 + 1);
HXDLIN( 153)						int i = (_g1 - 1);
HXLINE( 154)						Float _hx_tmp = ::verb::core::Binomial_obj::get(k,i);
HXDLIN( 154)						::verb::core::Vec_obj::subMulMutate(v,(_hx_tmp * wders->__get(i)),CK->__get((k - i)).StaticCast< ::Array< Float > >());
            					}
            				}
HXLINE( 157)				::verb::core::Vec_obj::mulMutate((( (Float)(1) ) / wders->__get(0)),v);
HXLINE( 158)				CK->push(v);
            			}
            		}
HXLINE( 161)		return CK;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,rationalCurveDerivatives,return )

::Array< Float > Eval_obj::rationalCurvePoint( ::verb::core::NurbsCurveData curve,Float u){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_180_rationalCurvePoint)
HXDLIN( 180)		return ::verb::eval::Eval_obj::dehomogenize(::verb::eval::Eval_obj::curvePoint(curve,u));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,rationalCurvePoint,return )

::Array< ::Dynamic> Eval_obj::surfaceDerivatives( ::verb::core::NurbsSurfaceData surface,Float u,Float v,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_196_surfaceDerivatives)
HXLINE( 198)		int n = ((surface->knotsU->length - surface->degreeU) - 2);
HXDLIN( 198)		int m = ((surface->knotsV->length - surface->degreeV) - 2);
HXLINE( 201)		return ::verb::eval::Eval_obj::surfaceDerivativesGivenNM(n,m,surface,u,v,numDerivs);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,surfaceDerivatives,return )

::Array< ::Dynamic> Eval_obj::surfaceDerivativesGivenNM(int n,int m, ::verb::core::NurbsSurfaceData surface,Float u,Float v,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_225_surfaceDerivativesGivenNM)
HXLINE( 227)		int degreeU = surface->degreeU;
HXDLIN( 227)		int degreeV = surface->degreeV;
HXDLIN( 227)		::Array< ::Dynamic> controlPoints = surface->controlPoints;
HXDLIN( 227)		::Array< Float > knotsU = surface->knotsU;
HXDLIN( 227)		::Array< Float > knotsV = surface->knotsV;
HXLINE( 233)		bool _hx_tmp;
HXDLIN( 233)		if (::verb::eval::Eval_obj::areValidRelations(degreeU,controlPoints->length,knotsU->length)) {
HXLINE( 233)			_hx_tmp = !(::verb::eval::Eval_obj::areValidRelations(degreeV,controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length,knotsV->length));
            		}
            		else {
HXLINE( 233)			_hx_tmp = true;
            		}
HXDLIN( 233)		if (_hx_tmp) {
HXLINE( 236)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid relations between control points, knot vector, and n",7a,6a,aa,fe)));
            		}
HXLINE( 239)		int dim = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN( 239)		int du;
HXLINE( 240)		if ((numDerivs < degreeU)) {
HXLINE( 239)			du = numDerivs;
            		}
            		else {
HXLINE( 239)			du = degreeU;
            		}
HXDLIN( 239)		int dv;
HXLINE( 241)		if ((numDerivs < degreeV)) {
HXLINE( 239)			dv = numDerivs;
            		}
            		else {
HXLINE( 239)			dv = degreeV;
            		}
HXDLIN( 239)		::Array< ::Dynamic> SKL = ::verb::core::Vec_obj::zeros3d((numDerivs + 1),(numDerivs + 1),dim);
HXDLIN( 239)		int knotSpan_index_u = ::verb::eval::Eval_obj::knotSpanGivenN(n,degreeU,u,knotsU);
HXDLIN( 239)		int knotSpan_index_v = ::verb::eval::Eval_obj::knotSpanGivenN(m,degreeV,v,knotsV);
HXDLIN( 239)		::Array< ::Dynamic> uders = ::verb::eval::Eval_obj::derivativeBasisFunctionsGivenNI(knotSpan_index_u,u,degreeU,n,knotsU);
HXDLIN( 239)		::Array< ::Dynamic> vders = ::verb::eval::Eval_obj::derivativeBasisFunctionsGivenNI(knotSpan_index_v,v,degreeV,m,knotsV);
HXDLIN( 239)		::Array< ::Dynamic> temp = ::verb::core::Vec_obj::zeros2d((degreeV + 1),dim);
HXDLIN( 239)		int dd = 0;
HXLINE( 250)		{
HXLINE( 250)			int _g = 0;
HXDLIN( 250)			int _g1 = (du + 1);
HXDLIN( 250)			while((_g < _g1)){
HXLINE( 250)				_g = (_g + 1);
HXDLIN( 250)				int k = (_g - 1);
HXLINE( 251)				{
HXLINE( 251)					int _g1 = 0;
HXDLIN( 251)					int _g2 = (degreeV + 1);
HXDLIN( 251)					while((_g1 < _g2)){
HXLINE( 251)						_g1 = (_g1 + 1);
HXDLIN( 251)						int s = (_g1 - 1);
HXLINE( 252)						temp[s] = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 254)						{
HXLINE( 254)							int _g = 0;
HXDLIN( 254)							int _g2 = (degreeU + 1);
HXDLIN( 254)							while((_g < _g2)){
HXLINE( 254)								_g = (_g + 1);
HXDLIN( 254)								int r = (_g - 1);
HXLINE( 255)								::verb::core::Vec_obj::addMulMutate(temp->__get(s).StaticCast< ::Array< Float > >(),uders->__get(k).StaticCast< ::Array< Float > >()->__get(r),controlPoints->__get(((knotSpan_index_u - degreeU) + r)).StaticCast< ::Array< ::Dynamic> >()->__get(((knotSpan_index_v - degreeV) + s)).StaticCast< ::Array< Float > >());
            							}
            						}
            					}
            				}
HXLINE( 259)				int nk = (numDerivs - k);
HXLINE( 260)				if ((nk < dv)) {
HXLINE( 260)					dd = nk;
            				}
            				else {
HXLINE( 260)					dd = dv;
            				}
HXLINE( 262)				{
HXLINE( 262)					int _g3 = 0;
HXDLIN( 262)					int _g4 = (dd + 1);
HXDLIN( 262)					while((_g3 < _g4)){
HXLINE( 262)						_g3 = (_g3 + 1);
HXDLIN( 262)						int l = (_g3 - 1);
HXLINE( 263)						SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()[l] = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 265)						{
HXLINE( 265)							int _g = 0;
HXDLIN( 265)							int _g1 = (degreeV + 1);
HXDLIN( 265)							while((_g < _g1)){
HXLINE( 265)								_g = (_g + 1);
HXDLIN( 265)								int s = (_g - 1);
HXLINE( 266)								::verb::core::Vec_obj::addMulMutate(SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >(),vders->__get(l).StaticCast< ::Array< Float > >()->__get(s),temp->__get(s).StaticCast< ::Array< Float > >());
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 271)		return SKL;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Eval_obj,surfaceDerivativesGivenNM,return )

::Array< Float > Eval_obj::surfacePoint( ::verb::core::NurbsSurfaceData surface,Float u,Float v){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_286_surfacePoint)
HXLINE( 288)		int n = ((surface->knotsU->length - surface->degreeU) - 2);
HXDLIN( 288)		int m = ((surface->knotsV->length - surface->degreeV) - 2);
HXLINE( 291)		return ::verb::eval::Eval_obj::surfacePointGivenNM(n,m,surface,u,v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,surfacePoint,return )

::Array< Float > Eval_obj::surfacePointGivenNM(int n,int m, ::verb::core::NurbsSurfaceData surface,Float u,Float v){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_310_surfacePointGivenNM)
HXLINE( 312)		int degreeU = surface->degreeU;
HXDLIN( 312)		int degreeV = surface->degreeV;
HXDLIN( 312)		::Array< ::Dynamic> controlPoints = surface->controlPoints;
HXDLIN( 312)		::Array< Float > knotsU = surface->knotsU;
HXDLIN( 312)		::Array< Float > knotsV = surface->knotsV;
HXLINE( 318)		bool _hx_tmp;
HXDLIN( 318)		if (::verb::eval::Eval_obj::areValidRelations(degreeU,controlPoints->length,knotsU->length)) {
HXLINE( 318)			_hx_tmp = !(::verb::eval::Eval_obj::areValidRelations(degreeV,controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length,knotsV->length));
            		}
            		else {
HXLINE( 318)			_hx_tmp = true;
            		}
HXDLIN( 318)		if (_hx_tmp) {
HXLINE( 321)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid relations between control points, knot vector, and n",7a,6a,aa,fe)));
            		}
HXLINE( 324)		int dim = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN( 324)		int knotSpan_index_u = ::verb::eval::Eval_obj::knotSpanGivenN(n,degreeU,u,knotsU);
HXDLIN( 324)		int knotSpan_index_v = ::verb::eval::Eval_obj::knotSpanGivenN(m,degreeV,v,knotsV);
HXDLIN( 324)		::Array< Float > u_basis_vals = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
HXDLIN( 324)		::Array< Float > v_basis_vals = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
HXDLIN( 324)		int uind = (knotSpan_index_u - degreeU);
HXDLIN( 324)		int vind = knotSpan_index_v;
HXDLIN( 324)		::Array< Float > position = ::verb::core::Vec_obj::zeros1d(dim);
HXDLIN( 324)		::Array< Float > temp = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 334)		{
HXLINE( 334)			int _g = 0;
HXDLIN( 334)			int _g1 = (degreeV + 1);
HXDLIN( 334)			while((_g < _g1)){
HXLINE( 334)				_g = (_g + 1);
HXDLIN( 334)				int l = (_g - 1);
HXLINE( 336)				temp = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 337)				vind = ((knotSpan_index_v - degreeV) + l);
HXLINE( 340)				{
HXLINE( 340)					int _g1 = 0;
HXDLIN( 340)					int _g2 = (degreeU + 1);
HXDLIN( 340)					while((_g1 < _g2)){
HXLINE( 340)						_g1 = (_g1 + 1);
HXDLIN( 340)						int k = (_g1 - 1);
HXLINE( 341)						::verb::core::Vec_obj::addMulMutate(temp,u_basis_vals->__get(k),controlPoints->__get((uind + k)).StaticCast< ::Array< ::Dynamic> >()->__get(vind).StaticCast< ::Array< Float > >());
            					}
            				}
HXLINE( 345)				::verb::core::Vec_obj::addMulMutate(position,v_basis_vals->__get(l),temp);
            			}
            		}
HXLINE( 348)		return position;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Eval_obj,surfacePointGivenNM,return )

::Array< ::Dynamic> Eval_obj::curveRegularSamplePoints( ::verb::core::NurbsCurveData crv,int divs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_351_curveRegularSamplePoints)
HXLINE( 354)		::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::curveDerivatives(crv,crv->knots->__get(0),crv->degree);
HXLINE( 358)		Float t = (((Float)1.0) / ( (Float)(divs) ));
HXLINE( 359)		Float temp = (t * t);
HXLINE( 361)		::Array< Float > f = derivs->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 362)		::Array< Float > fd = ::verb::core::Vec_obj::mul(t,derivs->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 363)		::Array< Float > fdd_per2 = ::verb::core::Vec_obj::mul((temp * ((Float)0.5)),derivs->__get(2).StaticCast< ::Array< Float > >());
HXLINE( 364)		::Array< Float > fddd_per2 = ::verb::core::Vec_obj::mul(((temp * t) * ((Float)0.5)),derivs->__get(3).StaticCast< ::Array< Float > >());
HXLINE( 366)		::Array< Float > fdd = ::verb::core::Vec_obj::add(fdd_per2,fdd_per2);
HXLINE( 367)		::Array< Float > fddd = ::verb::core::Vec_obj::add(fddd_per2,fddd_per2);
HXLINE( 368)		::Array< Float > fddd_per6 = ::verb::core::Vec_obj::mul(((Float)0.33333333333333331),fddd_per2);
HXLINE( 371)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 373)		{
HXLINE( 373)			int _g = 0;
HXDLIN( 373)			int _g1 = (divs + 1);
HXDLIN( 373)			while((_g < _g1)){
HXLINE( 373)				_g = (_g + 1);
HXDLIN( 373)				int i = (_g - 1);
HXLINE( 375)				pts->push(::verb::eval::Eval_obj::dehomogenize(f));
HXLINE( 377)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(4)->init(0,f)->init(1,fd)->init(2,fdd_per2)->init(3,fddd_per6));
HXLINE( 378)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(3)->init(0,fd)->init(1,fdd)->init(2,fddd_per2));
HXLINE( 379)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(2)->init(0,fdd)->init(1,fddd));
HXLINE( 380)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(2)->init(0,fdd_per2)->init(1,fddd_per2));
            			}
            		}
HXLINE( 383)		return pts;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,curveRegularSamplePoints,return )

::Array< ::Dynamic> Eval_obj::curveRegularSamplePoints2( ::verb::core::NurbsCurveData crv,int divs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_387_curveRegularSamplePoints2)
HXLINE( 390)		::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::curveDerivatives(crv,crv->knots->__get(0),crv->degree);
HXLINE( 394)		Float t = (((Float)1.0) / ( (Float)(divs) ));
HXLINE( 395)		Float temp = (t * t);
HXLINE( 397)		::Array< Float > f = derivs->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 398)		::Array< Float > fd = ::verb::core::Vec_obj::mul(t,derivs->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 399)		::Array< Float > fdd_per2 = ::verb::core::Vec_obj::mul((temp * ((Float)0.5)),derivs->__get(2).StaticCast< ::Array< Float > >());
HXLINE( 400)		::Array< Float > fddd_per2 = ::verb::core::Vec_obj::mul(((temp * t) * ((Float)0.5)),derivs->__get(3).StaticCast< ::Array< Float > >());
HXLINE( 402)		::Array< Float > fdd = ::verb::core::Vec_obj::add(fdd_per2,fdd_per2);
HXLINE( 403)		::Array< Float > fddd = ::verb::core::Vec_obj::add(fddd_per2,fddd_per2);
HXLINE( 404)		::Array< Float > fddd_per6 = ::verb::core::Vec_obj::mul(((Float)0.33333333333333331),fddd_per2);
HXLINE( 407)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 409)		{
HXLINE( 409)			int _g = 0;
HXDLIN( 409)			int _g1 = (divs + 1);
HXDLIN( 409)			while((_g < _g1)){
HXLINE( 409)				_g = (_g + 1);
HXDLIN( 409)				int i = (_g - 1);
HXLINE( 410)				pts->push(::verb::eval::Eval_obj::dehomogenize(f));
HXLINE( 412)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(4)->init(0,f)->init(1,fd)->init(2,fdd_per2)->init(3,fddd_per6));
HXLINE( 413)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(3)->init(0,fd)->init(1,fdd)->init(2,fddd_per2));
HXLINE( 414)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(2)->init(0,fdd)->init(1,fddd));
HXLINE( 415)				::verb::core::Vec_obj::addAllMutate(::Array_obj< ::Dynamic>::__new(2)->init(0,fdd_per2)->init(1,fddd_per2));
            			}
            		}
HXLINE( 418)		return pts;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,curveRegularSamplePoints2,return )

::Array< ::Dynamic> Eval_obj::rationalSurfaceRegularSampleDerivatives( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_435_rationalSurfaceRegularSampleDerivatives)
HXLINE( 437)		::Array< ::Dynamic> allders = ::verb::eval::Eval_obj::surfaceRegularSampleDerivatives(surface,divsU,divsV,numDerivs);
HXLINE( 439)		::Array< ::Dynamic> allratders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 440)		int divsU1 = (divsU + 1);
HXLINE( 441)		int divsV1 = (divsV + 1);
HXLINE( 442)		int numDerivs1 = (numDerivs + 1);
HXLINE( 444)		{
HXLINE( 444)			int _g = 0;
HXDLIN( 444)			int _g1 = divsU1;
HXDLIN( 444)			while((_g < _g1)){
HXLINE( 444)				_g = (_g + 1);
HXDLIN( 444)				int i = (_g - 1);
HXLINE( 446)				::Array< ::Dynamic> rowders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 447)				allratders->push(rowders);
HXLINE( 449)				{
HXLINE( 449)					int _g1 = 0;
HXDLIN( 449)					int _g2 = divsV1;
HXDLIN( 449)					while((_g1 < _g2)){
HXLINE( 449)						_g1 = (_g1 + 1);
HXDLIN( 449)						int j = (_g1 - 1);
HXLINE( 451)						::Array< ::Dynamic> ders = allders->__get(i).StaticCast< ::Array< ::Dynamic> >()->__get(j).StaticCast< ::Array< ::Dynamic> >();
HXDLIN( 451)						::Array< ::Dynamic> Aders = ::verb::eval::Eval_obj::rational2d(ders);
HXDLIN( 451)						::Array< ::Dynamic> wders = ::verb::eval::Eval_obj::weight2d(ders);
HXDLIN( 451)						::Array< ::Dynamic> SKL = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 451)						int dim = Aders->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE( 457)						{
HXLINE( 457)							int _g = 0;
HXDLIN( 457)							int _g2 = numDerivs1;
HXDLIN( 457)							while((_g < _g2)){
HXLINE( 457)								_g = (_g + 1);
HXDLIN( 457)								int k = (_g - 1);
HXLINE( 458)								SKL->push(::Array_obj< ::Dynamic>::__new());
HXLINE( 460)								{
HXLINE( 460)									int _g1 = 0;
HXDLIN( 460)									int _g2 = (numDerivs1 - k);
HXDLIN( 460)									while((_g1 < _g2)){
HXLINE( 460)										_g1 = (_g1 + 1);
HXDLIN( 460)										int l = (_g1 - 1);
HXLINE( 461)										::Array< Float > v = Aders->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >();
HXLINE( 463)										{
HXLINE( 463)											int _g = 1;
HXDLIN( 463)											int _g2 = (l + 1);
HXDLIN( 463)											while((_g < _g2)){
HXLINE( 463)												_g = (_g + 1);
HXDLIN( 463)												int j = (_g - 1);
HXLINE( 464)												Float _hx_tmp = ::verb::core::Binomial_obj::get(l,j);
HXDLIN( 464)												::verb::core::Vec_obj::subMulMutate(v,(_hx_tmp * wders->__get(0).StaticCast< ::Array< Float > >()->__get(j)),SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get((l - j)).StaticCast< ::Array< Float > >());
            											}
            										}
HXLINE( 467)										{
HXLINE( 467)											int _g3 = 1;
HXDLIN( 467)											int _g4 = (k + 1);
HXDLIN( 467)											while((_g3 < _g4)){
HXLINE( 467)												_g3 = (_g3 + 1);
HXDLIN( 467)												int i = (_g3 - 1);
HXLINE( 468)												Float _hx_tmp = ::verb::core::Binomial_obj::get(k,i);
HXDLIN( 468)												::verb::core::Vec_obj::subMulMutate(v,(_hx_tmp * wders->__get(i).StaticCast< ::Array< Float > >()->__get(0)),SKL->__get((k - i)).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >());
HXLINE( 470)												::Array< Float > v2 = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 472)												{
HXLINE( 472)													int _g = 1;
HXDLIN( 472)													int _g1 = (l + 1);
HXDLIN( 472)													while((_g < _g1)){
HXLINE( 472)														_g = (_g + 1);
HXDLIN( 472)														int j = (_g - 1);
HXLINE( 473)														Float _hx_tmp = ::verb::core::Binomial_obj::get(l,j);
HXDLIN( 473)														::verb::core::Vec_obj::addMulMutate(v2,(_hx_tmp * wders->__get(i).StaticCast< ::Array< Float > >()->__get(j)),SKL->__get((k - i)).StaticCast< ::Array< ::Dynamic> >()->__get((l - j)).StaticCast< ::Array< Float > >());
            													}
            												}
HXLINE( 476)												::verb::core::Vec_obj::subMulMutate(v,::verb::core::Binomial_obj::get(k,i),v2);
            											}
            										}
HXLINE( 480)										::verb::core::Vec_obj::mulMutate((( (Float)(1) ) / wders->__get(0).StaticCast< ::Array< Float > >()->__get(0)),v);
HXLINE( 481)										SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->push(v);
            									}
            								}
            							}
            						}
HXLINE( 485)						rowders->push(SKL);
            					}
            				}
            			}
            		}
HXLINE( 489)		return allratders;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,rationalSurfaceRegularSampleDerivatives,return )

::Array< ::Dynamic> Eval_obj::surfaceRegularSampleDerivatives( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_505_surfaceRegularSampleDerivatives)
HXLINE( 507)		int degreeU = surface->degreeU;
HXDLIN( 507)		int degreeV = surface->degreeV;
HXDLIN( 507)		::Array< ::Dynamic> controlPoints = surface->controlPoints;
HXDLIN( 507)		::Array< Float > knotsU = surface->knotsU;
HXDLIN( 507)		::Array< Float > knotsV = surface->knotsV;
HXLINE( 513)		int dim = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE( 514)		Float spanU = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsU)) );
HXLINE( 513)		Float spanU1 = ((spanU - knotsU->__get(0)) / ( (Float)(divsU) ));
HXLINE( 515)		Float spanV = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsV)) );
HXLINE( 513)		Float spanV1 = ((spanV - knotsV->__get(0)) / ( (Float)(divsV) ));
HXDLIN( 513)		 ::verb::core::Pair knotSpansBasesU = ::verb::eval::Eval_obj::regularlySpacedDerivativeBasisFunctions(degreeU,knotsU,divsU);
HXDLIN( 513)		::Array< int > knotSpansU = ( (::Array< int >)(knotSpansBasesU->item0) );
HXDLIN( 513)		::Array< ::Dynamic> basesU = ( (::Array< ::Dynamic>)(knotSpansBasesU->item1) );
HXDLIN( 513)		 ::verb::core::Pair knotSpansBasesV = ::verb::eval::Eval_obj::regularlySpacedDerivativeBasisFunctions(degreeV,knotsV,divsV);
HXDLIN( 513)		::Array< int > knotSpansV = ( (::Array< int >)(knotSpansBasesV->item0) );
HXDLIN( 513)		::Array< ::Dynamic> basesV = ( (::Array< ::Dynamic>)(knotSpansBasesV->item1) );
HXDLIN( 513)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 513)		int divsU1 = (divsU + 1);
HXDLIN( 513)		int divsV1 = (divsV + 1);
HXLINE( 526)		{
HXLINE( 526)			int _g = 0;
HXDLIN( 526)			int _g1 = divsU1;
HXDLIN( 526)			while((_g < _g1)){
HXLINE( 526)				_g = (_g + 1);
HXDLIN( 526)				int i = (_g - 1);
HXLINE( 527)				::Array< ::Dynamic> ptsi = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 528)				pts->push(ptsi);
HXLINE( 530)				{
HXLINE( 530)					int _g1 = 0;
HXDLIN( 530)					int _g2 = divsV1;
HXDLIN( 530)					while((_g1 < _g2)){
HXLINE( 530)						_g1 = (_g1 + 1);
HXDLIN( 530)						int j = (_g1 - 1);
HXLINE( 531)						ptsi->push(::verb::eval::Eval_obj::surfaceDerivativesGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU->__get(i),knotSpansV->__get(j),basesU->__get(i).StaticCast< ::Array< ::Dynamic> >(),basesV->__get(j).StaticCast< ::Array< ::Dynamic> >(),dim,numDerivs));
            					}
            				}
            			}
            		}
HXLINE( 535)		return pts;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,surfaceRegularSampleDerivatives,return )

::Array< ::Dynamic> Eval_obj::rationalSurfaceRegularSamplePoints( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_552_rationalSurfaceRegularSamplePoints)
HXDLIN( 552)		return ::verb::eval::Eval_obj::dehomogenize2d(::verb::eval::Eval_obj::surfaceRegularSamplePoints(surface,divsU,divsV));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,rationalSurfaceRegularSamplePoints,return )

::Array< ::Dynamic> Eval_obj::surfaceRegularSamplePoints( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_568_surfaceRegularSamplePoints)
HXLINE( 570)		int degreeU = surface->degreeU;
HXDLIN( 570)		int degreeV = surface->degreeV;
HXDLIN( 570)		::Array< ::Dynamic> controlPoints = surface->controlPoints;
HXDLIN( 570)		::Array< Float > knotsU = surface->knotsU;
HXDLIN( 570)		::Array< Float > knotsV = surface->knotsV;
HXLINE( 576)		int dim = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE( 577)		Float spanU = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsU)) );
HXLINE( 576)		Float spanU1 = ((spanU - knotsU->__get(0)) / ( (Float)(divsU) ));
HXLINE( 578)		Float spanV = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsV)) );
HXLINE( 576)		Float spanV1 = ((spanV - knotsV->__get(0)) / ( (Float)(divsV) ));
HXDLIN( 576)		 ::verb::core::Pair knotSpansBasesU = ::verb::eval::Eval_obj::regularlySpacedBasisFunctions(degreeU,knotsU,divsU);
HXDLIN( 576)		::Array< int > knotSpansU = ( (::Array< int >)(knotSpansBasesU->item0) );
HXDLIN( 576)		::Array< ::Dynamic> basesU = ( (::Array< ::Dynamic>)(knotSpansBasesU->item1) );
HXDLIN( 576)		 ::verb::core::Pair knotSpansBasesV = ::verb::eval::Eval_obj::regularlySpacedBasisFunctions(degreeV,knotsV,divsV);
HXDLIN( 576)		::Array< int > knotSpansV = ( (::Array< int >)(knotSpansBasesV->item0) );
HXDLIN( 576)		::Array< ::Dynamic> basesV = ( (::Array< ::Dynamic>)(knotSpansBasesV->item1) );
HXDLIN( 576)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 576)		int divsU1 = (divsU + 1);
HXDLIN( 576)		int divsV1 = (divsV + 1);
HXLINE( 589)		{
HXLINE( 589)			int _g = 0;
HXDLIN( 589)			int _g1 = divsU1;
HXDLIN( 589)			while((_g < _g1)){
HXLINE( 589)				_g = (_g + 1);
HXDLIN( 589)				int i = (_g - 1);
HXLINE( 590)				::Array< ::Dynamic> ptsi = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 591)				pts->push(ptsi);
HXLINE( 593)				{
HXLINE( 593)					int _g1 = 0;
HXDLIN( 593)					int _g2 = divsV1;
HXDLIN( 593)					while((_g1 < _g2)){
HXLINE( 593)						_g1 = (_g1 + 1);
HXDLIN( 593)						int j = (_g1 - 1);
HXLINE( 594)						ptsi->push(::verb::eval::Eval_obj::surfacePointGivenBasesKnotSpans(degreeU,degreeV,controlPoints,knotSpansU->__get(i),knotSpansV->__get(j),basesU->__get(i).StaticCast< ::Array< Float > >(),basesV->__get(j).StaticCast< ::Array< Float > >(),dim));
            					}
            				}
            			}
            		}
HXLINE( 598)		return pts;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,surfaceRegularSamplePoints,return )

 ::verb::core::Pair Eval_obj::regularlySpacedBasisFunctions(int degree,::Array< Float > knots,int divs){
            	HX_GC_STACKFRAME(&_hx_pos_3844315661bdc8bc_601_regularlySpacedBasisFunctions)
HXLINE( 603)		int n = ((knots->length - degree) - 2);
HXLINE( 604)		Float span = ( (Float)(::verb::core::ArrayExtensions_obj::last(knots)) );
HXDLIN( 604)		Float span1 = ((span - knots->__get(0)) / ( (Float)(divs) ));
HXLINE( 606)		::Array< ::Dynamic> bases = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 607)		::Array< int > knotspans = ::Array_obj< int >::__new(0);
HXLINE( 608)		Float u = knots->__get(0);
HXLINE( 609)		int knotIndex = ::verb::eval::Eval_obj::knotSpanGivenN(n,degree,u,knots);
HXLINE( 610)		int div1 = (divs + 1);
HXLINE( 613)		{
HXLINE( 613)			int _g = 0;
HXDLIN( 613)			int _g1 = div1;
HXDLIN( 613)			while((_g < _g1)){
HXLINE( 613)				_g = (_g + 1);
HXDLIN( 613)				int i = (_g - 1);
HXLINE( 614)				while((u >= knots->__get((knotIndex + 1)))){
HXLINE( 614)					knotIndex = (knotIndex + 1);
            				}
HXLINE( 615)				knotspans->push(knotIndex);
HXLINE( 616)				bases->push(::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotIndex,u,degree,knots));
HXLINE( 617)				u = (u + span1);
            			}
            		}
HXLINE( 620)		return  ::verb::core::Pair_obj::__alloc( HX_CTX ,knotspans,bases);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,regularlySpacedBasisFunctions,return )

 ::verb::core::Pair Eval_obj::regularlySpacedDerivativeBasisFunctions(int degree,::Array< Float > knots,int divs){
            	HX_GC_STACKFRAME(&_hx_pos_3844315661bdc8bc_623_regularlySpacedDerivativeBasisFunctions)
HXLINE( 625)		int n = ((knots->length - degree) - 2);
HXLINE( 626)		Float span = ( (Float)(::verb::core::ArrayExtensions_obj::last(knots)) );
HXDLIN( 626)		Float span1 = ((span - knots->__get(0)) / ( (Float)(divs) ));
HXLINE( 628)		::Array< ::Dynamic> bases = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 629)		::Array< int > knotspans = ::Array_obj< int >::__new(0);
HXLINE( 630)		Float u = knots->__get(0);
HXLINE( 631)		int knotIndex = ::verb::eval::Eval_obj::knotSpanGivenN(n,degree,u,knots);
HXLINE( 632)		int div1 = (divs + 1);
HXLINE( 635)		{
HXLINE( 635)			int _g = 0;
HXDLIN( 635)			int _g1 = div1;
HXDLIN( 635)			while((_g < _g1)){
HXLINE( 635)				_g = (_g + 1);
HXDLIN( 635)				int i = (_g - 1);
HXLINE( 636)				while((u >= knots->__get((knotIndex + 1)))){
HXLINE( 636)					knotIndex = (knotIndex + 1);
            				}
HXLINE( 637)				knotspans->push(knotIndex);
HXLINE( 638)				bases->push(::verb::eval::Eval_obj::derivativeBasisFunctionsGivenNI(knotIndex,u,degree,n,knots));
HXLINE( 639)				u = (u + span1);
            			}
            		}
HXLINE( 642)		return  ::verb::core::Pair_obj::__alloc( HX_CTX ,knotspans,bases);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,regularlySpacedDerivativeBasisFunctions,return )

::Array< Float > Eval_obj::surfacePointGivenBasesKnotSpans(int degreeU,int degreeV,::Array< ::Dynamic> controlPoints,int knotSpanU,int knotSpanV,::Array< Float > basesU,::Array< Float > basesV,int dim){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_652_surfacePointGivenBasesKnotSpans)
HXLINE( 654)		::Array< Float > position = ::verb::core::Vec_obj::zeros1d(dim);
HXDLIN( 654)		::Array< Float > temp;
HXLINE( 658)		int uind = (knotSpanU - degreeU);
HXLINE( 659)		int vind = (knotSpanV - degreeV);
HXLINE( 661)		{
HXLINE( 661)			int _g = 0;
HXDLIN( 661)			int _g1 = (degreeV + 1);
HXDLIN( 661)			while((_g < _g1)){
HXLINE( 661)				_g = (_g + 1);
HXDLIN( 661)				int l = (_g - 1);
HXLINE( 663)				temp = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 665)				{
HXLINE( 665)					int _g1 = 0;
HXDLIN( 665)					int _g2 = (degreeU + 1);
HXDLIN( 665)					while((_g1 < _g2)){
HXLINE( 665)						_g1 = (_g1 + 1);
HXDLIN( 665)						int k = (_g1 - 1);
HXLINE( 666)						::verb::core::Vec_obj::addMulMutate(temp,basesU->__get(k),controlPoints->__get((uind + k)).StaticCast< ::Array< ::Dynamic> >()->__get(vind).StaticCast< ::Array< Float > >());
            					}
            				}
HXLINE( 669)				vind = (vind + 1);
HXLINE( 671)				::verb::core::Vec_obj::addMulMutate(position,basesV->__get(l),temp);
            			}
            		}
HXLINE( 674)		return position;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Eval_obj,surfacePointGivenBasesKnotSpans,return )

::Array< ::Dynamic> Eval_obj::surfaceDerivativesGivenBasesKnotSpans(int degreeU,int degreeV,::Array< ::Dynamic> controlPoints,int knotSpanU,int knotSpanV,::Array< ::Dynamic> basesU,::Array< ::Dynamic> basesV,int dim,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_685_surfaceDerivativesGivenBasesKnotSpans)
HXLINE( 687)		int dim1 = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN( 687)		int du;
HXLINE( 688)		if ((numDerivs < degreeU)) {
HXLINE( 687)			du = numDerivs;
            		}
            		else {
HXLINE( 687)			du = degreeU;
            		}
HXDLIN( 687)		int dv;
HXLINE( 689)		if ((numDerivs < degreeV)) {
HXLINE( 687)			dv = numDerivs;
            		}
            		else {
HXLINE( 687)			dv = degreeV;
            		}
HXDLIN( 687)		::Array< ::Dynamic> SKL = ::verb::core::Vec_obj::zeros3d((du + 1),(dv + 1),dim1);
HXDLIN( 687)		::Array< ::Dynamic> temp = ::verb::core::Vec_obj::zeros2d((degreeV + 1),dim1);
HXDLIN( 687)		int dd = 0;
HXLINE( 694)		{
HXLINE( 694)			int _g = 0;
HXDLIN( 694)			int _g1 = (du + 1);
HXDLIN( 694)			while((_g < _g1)){
HXLINE( 694)				_g = (_g + 1);
HXDLIN( 694)				int k = (_g - 1);
HXLINE( 695)				{
HXLINE( 695)					int _g1 = 0;
HXDLIN( 695)					int _g2 = (degreeV + 1);
HXDLIN( 695)					while((_g1 < _g2)){
HXLINE( 695)						_g1 = (_g1 + 1);
HXDLIN( 695)						int s = (_g1 - 1);
HXLINE( 696)						temp[s] = ::verb::core::Vec_obj::zeros1d(dim1);
HXLINE( 698)						{
HXLINE( 698)							int _g = 0;
HXDLIN( 698)							int _g2 = (degreeU + 1);
HXDLIN( 698)							while((_g < _g2)){
HXLINE( 698)								_g = (_g + 1);
HXDLIN( 698)								int r = (_g - 1);
HXLINE( 699)								::verb::core::Vec_obj::addMulMutate(temp->__get(s).StaticCast< ::Array< Float > >(),basesU->__get(k).StaticCast< ::Array< Float > >()->__get(r),controlPoints->__get(((knotSpanU - degreeU) + r)).StaticCast< ::Array< ::Dynamic> >()->__get(((knotSpanV - degreeV) + s)).StaticCast< ::Array< Float > >());
            							}
            						}
            					}
            				}
HXLINE( 703)				int nk = (numDerivs - k);
HXLINE( 704)				if ((nk < dv)) {
HXLINE( 704)					dd = nk;
            				}
            				else {
HXLINE( 704)					dd = dv;
            				}
HXLINE( 706)				{
HXLINE( 706)					int _g3 = 0;
HXDLIN( 706)					int _g4 = (dd + 1);
HXDLIN( 706)					while((_g3 < _g4)){
HXLINE( 706)						_g3 = (_g3 + 1);
HXDLIN( 706)						int l = (_g3 - 1);
HXLINE( 707)						SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()[l] = ::verb::core::Vec_obj::zeros1d(dim1);
HXLINE( 709)						{
HXLINE( 709)							int _g = 0;
HXDLIN( 709)							int _g1 = (degreeV + 1);
HXDLIN( 709)							while((_g < _g1)){
HXLINE( 709)								_g = (_g + 1);
HXDLIN( 709)								int s = (_g - 1);
HXLINE( 710)								::verb::core::Vec_obj::addMulMutate(SKL->__get(k).StaticCast< ::Array< ::Dynamic> >()->__get(l).StaticCast< ::Array< Float > >(),basesV->__get(l).StaticCast< ::Array< Float > >()->__get(s),temp->__get(s).StaticCast< ::Array< Float > >());
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 715)		return SKL;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(Eval_obj,surfaceDerivativesGivenBasesKnotSpans,return )

::Array< ::Dynamic> Eval_obj::curveDerivatives( ::verb::core::NurbsCurveData crv,Float u,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_730_curveDerivatives)
HXLINE( 732)		int n = ((crv->knots->length - crv->degree) - 2);
HXLINE( 733)		return ::verb::eval::Eval_obj::curveDerivativesGivenN(n,crv,u,numDerivs);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,curveDerivatives,return )

::Array< ::Dynamic> Eval_obj::curveDerivativesGivenN(int n, ::verb::core::NurbsCurveData curve,Float u,int numDerivs){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_750_curveDerivativesGivenN)
HXLINE( 752)		int degree = curve->degree;
HXDLIN( 752)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN( 752)		::Array< Float > knots = curve->knots;
HXLINE( 756)		if (!(::verb::eval::Eval_obj::areValidRelations(degree,controlPoints->length,knots->length))) {
HXLINE( 757)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid relations between control points, knot vector, and n",7a,6a,aa,fe)));
            		}
HXLINE( 760)		int dim = controlPoints->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN( 760)		int du;
HXLINE( 761)		if ((numDerivs < degree)) {
HXLINE( 760)			du = numDerivs;
            		}
            		else {
HXLINE( 760)			du = degree;
            		}
HXDLIN( 760)		::Array< ::Dynamic> CK = ::verb::core::Vec_obj::zeros2d((numDerivs + 1),dim);
HXDLIN( 760)		int knotSpan_index = ::verb::eval::Eval_obj::knotSpanGivenN(n,degree,u,knots);
HXDLIN( 760)		::Array< ::Dynamic> nders = ::verb::eval::Eval_obj::derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,du,knots);
HXDLIN( 760)		int k = 0;
HXDLIN( 760)		int j = 0;
HXLINE( 768)		{
HXLINE( 768)			int _g = 0;
HXDLIN( 768)			int _g1 = (du + 1);
HXDLIN( 768)			while((_g < _g1)){
HXLINE( 768)				_g = (_g + 1);
HXDLIN( 768)				int k = (_g - 1);
HXLINE( 769)				{
HXLINE( 769)					int _g1 = 0;
HXDLIN( 769)					int _g2 = (degree + 1);
HXDLIN( 769)					while((_g1 < _g2)){
HXLINE( 769)						_g1 = (_g1 + 1);
HXDLIN( 769)						int j = (_g1 - 1);
HXLINE( 770)						::verb::core::Vec_obj::addMulMutate(CK->__get(k).StaticCast< ::Array< Float > >(),nders->__get(k).StaticCast< ::Array< Float > >()->__get(j),controlPoints->__get(((knotSpan_index - degree) + j)).StaticCast< ::Array< Float > >());
            					}
            				}
            			}
            		}
HXLINE( 773)		return CK;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,curveDerivativesGivenN,return )

::Array< Float > Eval_obj::curvePoint( ::verb::core::NurbsCurveData curve,Float u){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_787_curvePoint)
HXLINE( 788)		int n = ((curve->knots->length - curve->degree) - 2);
HXLINE( 789)		return ::verb::eval::Eval_obj::curvePointGivenN(n,curve,u);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,curvePoint,return )

bool Eval_obj::areValidRelations(int degree,int num_controlPoints,int knots_length){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_806_areValidRelations)
HXDLIN( 806)		return ((((num_controlPoints + degree) + 1) - knots_length) == 0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,areValidRelations,return )

::Array< Float > Eval_obj::curvePointGivenN(int n, ::verb::core::NurbsCurveData curve,Float u){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_822_curvePointGivenN)
HXLINE( 824)		int degree = curve->degree;
HXDLIN( 824)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN( 824)		::Array< Float > knots = curve->knots;
HXLINE( 828)		if (!(::verb::eval::Eval_obj::areValidRelations(degree,controlPoints->length,knots->length))) {
HXLINE( 829)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid relations between control points, knot Array, and n",2c,e8,c6,68)));
            		}
HXLINE( 833)		int knotSpan_index = ::verb::eval::Eval_obj::knotSpanGivenN(n,degree,u,knots);
HXLINE( 834)		::Array< Float > basis_values = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
HXLINE( 835)		::Array< Float > position = ::verb::core::Vec_obj::zeros1d(controlPoints->__get(0).StaticCast< ::Array< Float > >()->length);
HXLINE( 837)		{
HXLINE( 837)			int _g = 0;
HXDLIN( 837)			int _g1 = (degree + 1);
HXDLIN( 837)			while((_g < _g1)){
HXLINE( 837)				_g = (_g + 1);
HXDLIN( 837)				int j = (_g - 1);
HXLINE( 838)				::verb::core::Vec_obj::addMulMutate(position,basis_values->__get(j),controlPoints->__get(((knotSpan_index - degree) + j)).StaticCast< ::Array< Float > >());
            			}
            		}
HXLINE( 841)		return position;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,curvePointGivenN,return )

::Array< Float > Eval_obj::volumePoint( ::verb::core::VolumeData volume,Float u,Float v,Float w){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_857_volumePoint)
HXLINE( 858)		int n = ((volume->knotsU->length - volume->degreeU) - 2);
HXDLIN( 858)		int m = ((volume->knotsV->length - volume->degreeV) - 2);
HXDLIN( 858)		int l = ((volume->knotsW->length - volume->degreeW) - 2);
HXLINE( 862)		return ::verb::eval::Eval_obj::volumePointGivenNML(volume,n,m,l,u,v,w);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,volumePoint,return )

::Array< Float > Eval_obj::volumePointGivenNML( ::verb::core::VolumeData volume,int n,int m,int l,Float u,Float v,Float w){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_884_volumePointGivenNML)
HXLINE( 886)		bool _hx_tmp;
HXDLIN( 886)		bool _hx_tmp1;
HXDLIN( 886)		if (::verb::eval::Eval_obj::areValidRelations(volume->degreeU,volume->controlPoints->length,volume->knotsU->length)) {
HXLINE( 886)			_hx_tmp1 = !(::verb::eval::Eval_obj::areValidRelations(volume->degreeV,volume->controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length,volume->knotsV->length));
            		}
            		else {
HXLINE( 886)			_hx_tmp1 = true;
            		}
HXDLIN( 886)		if (!(_hx_tmp1)) {
HXLINE( 886)			_hx_tmp = !(::verb::eval::Eval_obj::areValidRelations(volume->degreeW,volume->controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< ::Dynamic> >()->length,volume->knotsW->length));
            		}
            		else {
HXLINE( 886)			_hx_tmp = true;
            		}
HXDLIN( 886)		if (_hx_tmp) {
HXLINE( 889)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid relations between control points and knot vector",82,ff,fa,0c)));
            		}
HXLINE( 892)		::Array< ::Dynamic> controlPoints = volume->controlPoints;
HXDLIN( 892)		int degreeU = volume->degreeU;
HXDLIN( 892)		int degreeV = volume->degreeV;
HXDLIN( 892)		int degreeW = volume->degreeW;
HXDLIN( 892)		::Array< Float > knotsU = volume->knotsU;
HXDLIN( 892)		::Array< Float > knotsV = volume->knotsV;
HXDLIN( 892)		::Array< Float > knotsW = volume->knotsW;
HXLINE( 900)		int dim = controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN( 900)		int knotSpan_index_u = ::verb::eval::Eval_obj::knotSpanGivenN(n,degreeU,u,knotsU);
HXDLIN( 900)		int knotSpan_index_v = ::verb::eval::Eval_obj::knotSpanGivenN(m,degreeV,v,knotsV);
HXDLIN( 900)		int knotSpan_index_w = ::verb::eval::Eval_obj::knotSpanGivenN(l,degreeW,w,knotsW);
HXDLIN( 900)		::Array< Float > u_basis_vals = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index_u,u,degreeU,knotsU);
HXDLIN( 900)		::Array< Float > v_basis_vals = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index_v,v,degreeV,knotsV);
HXDLIN( 900)		::Array< Float > w_basis_vals = ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index_w,w,degreeW,knotsW);
HXDLIN( 900)		int uind = (knotSpan_index_u - degreeU);
HXDLIN( 900)		::Array< Float > position = ::verb::core::Vec_obj::zeros1d(dim);
HXDLIN( 900)		::Array< Float > temp = ::verb::core::Vec_obj::zeros1d(dim);
HXDLIN( 900)		::Array< Float > temp2 = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 912)		{
HXLINE( 912)			int _g = 0;
HXDLIN( 912)			int _g1 = (degreeW + 1);
HXDLIN( 912)			while((_g < _g1)){
HXLINE( 912)				_g = (_g + 1);
HXDLIN( 912)				int i = (_g - 1);
HXLINE( 914)				temp2 = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 915)				int wind = ((knotSpan_index_w - degreeW) + i);
HXLINE( 917)				{
HXLINE( 917)					int _g1 = 0;
HXDLIN( 917)					int _g2 = (degreeV + 1);
HXDLIN( 917)					while((_g1 < _g2)){
HXLINE( 917)						_g1 = (_g1 + 1);
HXDLIN( 917)						int j = (_g1 - 1);
HXLINE( 919)						temp = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 920)						int vind = ((knotSpan_index_v - degreeV) + j);
HXLINE( 922)						{
HXLINE( 922)							int _g = 0;
HXDLIN( 922)							int _g2 = (degreeU + 1);
HXDLIN( 922)							while((_g < _g2)){
HXLINE( 922)								_g = (_g + 1);
HXDLIN( 922)								int k = (_g - 1);
HXLINE( 923)								::verb::core::Vec_obj::addMulMutate(temp,u_basis_vals->__get(k),controlPoints->__get((uind + k)).StaticCast< ::Array< ::Dynamic> >()->__get(vind).StaticCast< ::Array< ::Dynamic> >()->__get(wind).StaticCast< ::Array< Float > >());
            							}
            						}
HXLINE( 927)						::verb::core::Vec_obj::addMulMutate(temp2,v_basis_vals->__get(j),temp);
            					}
            				}
HXLINE( 931)				::verb::core::Vec_obj::addMulMutate(position,w_basis_vals->__get(i),temp2);
            			}
            		}
HXLINE( 934)		return position;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Eval_obj,volumePointGivenNML,return )

::Array< ::Dynamic> Eval_obj::derivativeBasisFunctions(Float u,int degree,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_950_derivativeBasisFunctions)
HXLINE( 951)		int knotSpan_index = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXDLIN( 951)		int m = (knots->length - 1);
HXDLIN( 951)		int n = ((m - degree) - 1);
HXLINE( 955)		return ::verb::eval::Eval_obj::derivativeBasisFunctionsGivenNI(knotSpan_index,u,degree,n,knots);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,derivativeBasisFunctions,return )

::Array< ::Dynamic> Eval_obj::derivativeBasisFunctionsGivenNI(int knotIndex,Float u,int p,int n,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_975_derivativeBasisFunctionsGivenNI)
HXLINE( 976)		::Array< ::Dynamic> ndu = ::verb::core::Vec_obj::zeros2d((p + 1),(p + 1));
HXDLIN( 976)		::Array< Float > left = ::verb::core::Vec_obj::zeros1d((p + 1));
HXDLIN( 976)		::Array< Float > right = ::verb::core::Vec_obj::zeros1d((p + 1));
HXDLIN( 976)		Float saved = ((Float)0.0);
HXDLIN( 976)		Float temp = ((Float)0.0);
HXLINE( 982)		ndu->__get(0).StaticCast< ::Array< Float > >()[0] = ((Float)1.0);
HXLINE( 984)		{
HXLINE( 984)			int _g = 1;
HXDLIN( 984)			int _g1 = (p + 1);
HXDLIN( 984)			while((_g < _g1)){
HXLINE( 984)				_g = (_g + 1);
HXDLIN( 984)				int j = (_g - 1);
HXLINE( 985)				left[j] = (u - knots->__get(((knotIndex + 1) - j)));
HXLINE( 986)				right[j] = (knots->__get((knotIndex + j)) - u);
HXLINE( 987)				saved = ((Float)0.0);
HXLINE( 989)				{
HXLINE( 989)					int _g1 = 0;
HXDLIN( 989)					int _g2 = j;
HXDLIN( 989)					while((_g1 < _g2)){
HXLINE( 989)						_g1 = (_g1 + 1);
HXDLIN( 989)						int r = (_g1 - 1);
HXLINE( 990)						ndu->__get(j).StaticCast< ::Array< Float > >()[r] = (right->__get((r + 1)) + left->__get((j - r)));
HXLINE( 991)						temp = (ndu->__get(r).StaticCast< ::Array< Float > >()->__get((j - 1)) / ndu->__get(j).StaticCast< ::Array< Float > >()->__get(r));
HXLINE( 993)						ndu->__get(r).StaticCast< ::Array< Float > >()[j] = (saved + (right->__get((r + 1)) * temp));
HXLINE( 994)						saved = (left->__get((j - r)) * temp);
            					}
            				}
HXLINE( 997)				ndu->__get(j).StaticCast< ::Array< Float > >()[j] = saved;
            			}
            		}
HXLINE(1000)		::Array< ::Dynamic> ders = ::verb::core::Vec_obj::zeros2d((n + 1),(p + 1));
HXDLIN(1000)		::Array< ::Dynamic> a = ::verb::core::Vec_obj::zeros2d(2,(p + 1));
HXDLIN(1000)		int s1 = 0;
HXDLIN(1000)		int s2 = 1;
HXDLIN(1000)		Float d = ((Float)0.0);
HXDLIN(1000)		int rk = 0;
HXDLIN(1000)		int pk = 0;
HXDLIN(1000)		int j1 = 0;
HXDLIN(1000)		int j2 = 0;
HXLINE(1010)		{
HXLINE(1010)			int _g2 = 0;
HXDLIN(1010)			int _g3 = (p + 1);
HXDLIN(1010)			while((_g2 < _g3)){
HXLINE(1010)				_g2 = (_g2 + 1);
HXDLIN(1010)				int j = (_g2 - 1);
HXLINE(1011)				ders->__get(0).StaticCast< ::Array< Float > >()[j] = ndu->__get(j).StaticCast< ::Array< Float > >()->__get(p);
            			}
            		}
HXLINE(1014)		{
HXLINE(1014)			int _g4 = 0;
HXDLIN(1014)			int _g5 = (p + 1);
HXDLIN(1014)			while((_g4 < _g5)){
HXLINE(1014)				_g4 = (_g4 + 1);
HXDLIN(1014)				int r = (_g4 - 1);
HXLINE(1015)				s1 = 0;
HXLINE(1016)				s2 = 1;
HXLINE(1017)				a->__get(0).StaticCast< ::Array< Float > >()[0] = ((Float)1.0);
HXLINE(1019)				{
HXLINE(1019)					int _g = 1;
HXDLIN(1019)					int _g1 = (n + 1);
HXDLIN(1019)					while((_g < _g1)){
HXLINE(1019)						_g = (_g + 1);
HXDLIN(1019)						int k = (_g - 1);
HXLINE(1021)						d = ((Float)0.0);
HXLINE(1022)						rk = (r - k);
HXLINE(1023)						pk = (p - k);
HXLINE(1025)						if ((r >= k)) {
HXLINE(1026)							a->__get(s2).StaticCast< ::Array< Float > >()[0] = (a->__get(s1).StaticCast< ::Array< Float > >()->__get(0) / ndu->__get((pk + 1)).StaticCast< ::Array< Float > >()->__get(rk));
HXLINE(1027)							d = (a->__get(s2).StaticCast< ::Array< Float > >()->__get(0) * ndu->__get(rk).StaticCast< ::Array< Float > >()->__get(pk));
            						}
HXLINE(1030)						if ((rk >= -1)) {
HXLINE(1031)							j1 = 1;
            						}
            						else {
HXLINE(1033)							j1 = -(rk);
            						}
HXLINE(1036)						if (((r - 1) <= pk)) {
HXLINE(1037)							j2 = (k - 1);
            						}
            						else {
HXLINE(1039)							j2 = (p - r);
            						}
HXLINE(1042)						{
HXLINE(1042)							int _g1 = j1;
HXDLIN(1042)							int _g2 = (j2 + 1);
HXDLIN(1042)							while((_g1 < _g2)){
HXLINE(1042)								_g1 = (_g1 + 1);
HXDLIN(1042)								int j = (_g1 - 1);
HXLINE(1043)								a->__get(s2).StaticCast< ::Array< Float > >()[j] = ((a->__get(s1).StaticCast< ::Array< Float > >()->__get(j) - a->__get(s1).StaticCast< ::Array< Float > >()->__get((j - 1))) / ndu->__get((pk + 1)).StaticCast< ::Array< Float > >()->__get((rk + j)));
HXLINE(1044)								d = (d + (a->__get(s2).StaticCast< ::Array< Float > >()->__get(j) * ndu->__get((rk + j)).StaticCast< ::Array< Float > >()->__get(pk)));
            							}
            						}
HXLINE(1047)						if ((r <= pk)) {
HXLINE(1048)							a->__get(s2).StaticCast< ::Array< Float > >()[k] = (-(a->__get(s1).StaticCast< ::Array< Float > >()->__get((k - 1))) / ndu->__get((pk + 1)).StaticCast< ::Array< Float > >()->__get(r));
HXLINE(1049)							d = (d + (a->__get(s2).StaticCast< ::Array< Float > >()->__get(k) * ndu->__get(r).StaticCast< ::Array< Float > >()->__get(pk)));
            						}
HXLINE(1052)						ders->__get(k).StaticCast< ::Array< Float > >()[r] = d;
HXLINE(1054)						int temp = s1;
HXLINE(1055)						s1 = s2;
HXLINE(1056)						s2 = temp;
            					}
            				}
            			}
            		}
HXLINE(1060)		int acc = p;
HXLINE(1061)		{
HXLINE(1061)			int _g6 = 1;
HXDLIN(1061)			int _g7 = (n + 1);
HXDLIN(1061)			while((_g6 < _g7)){
HXLINE(1061)				_g6 = (_g6 + 1);
HXDLIN(1061)				int k = (_g6 - 1);
HXLINE(1062)				{
HXLINE(1062)					int _g = 0;
HXDLIN(1062)					int _g1 = (p + 1);
HXDLIN(1062)					while((_g < _g1)){
HXLINE(1062)						_g = (_g + 1);
HXDLIN(1062)						int j = (_g - 1);
HXLINE(1063)						::Array< Float > ders1 = ders->__get(k).StaticCast< ::Array< Float > >();
HXDLIN(1063)						int j1 = j;
HXDLIN(1063)						ders1[j1] = (ders1->__get(j1) * ( (Float)(acc) ));
            					}
            				}
HXLINE(1065)				acc = (acc * (p - k));
            			}
            		}
HXLINE(1068)		return ders;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Eval_obj,derivativeBasisFunctionsGivenNI,return )

::Array< Float > Eval_obj::basisFunctions(Float u,int degree,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1086_basisFunctions)
HXLINE(1087)		int knotSpan_index = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXLINE(1088)		return ::verb::eval::Eval_obj::basisFunctionsGivenKnotSpanIndex(knotSpan_index,u,degree,knots);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,basisFunctions,return )

::Array< Float > Eval_obj::basisFunctionsGivenKnotSpanIndex(int knotSpan_index,Float u,int degree,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1110_basisFunctionsGivenKnotSpanIndex)
HXLINE(1111)		::Array< Float > basisFunctions = ::verb::core::Vec_obj::zeros1d((degree + 1));
HXLINE(1112)		::Array< Float > left = ::verb::core::Vec_obj::zeros1d((degree + 1));
HXLINE(1113)		::Array< Float > right = ::verb::core::Vec_obj::zeros1d((degree + 1));
HXLINE(1114)		Float saved = ( (Float)(0) );
HXLINE(1115)		Float temp = ( (Float)(0) );
HXLINE(1117)		basisFunctions[0] = ((Float)1.0);
HXLINE(1119)		{
HXLINE(1119)			int _g = 1;
HXDLIN(1119)			int _g1 = (degree + 1);
HXDLIN(1119)			while((_g < _g1)){
HXLINE(1119)				_g = (_g + 1);
HXDLIN(1119)				int j = (_g - 1);
HXLINE(1120)				left[j] = (u - knots->__get(((knotSpan_index + 1) - j)));
HXLINE(1121)				right[j] = (knots->__get((knotSpan_index + j)) - u);
HXLINE(1122)				saved = ((Float)0.0);
HXLINE(1124)				{
HXLINE(1124)					int _g1 = 0;
HXDLIN(1124)					int _g2 = j;
HXDLIN(1124)					while((_g1 < _g2)){
HXLINE(1124)						_g1 = (_g1 + 1);
HXDLIN(1124)						int r = (_g1 - 1);
HXLINE(1125)						temp = (basisFunctions->__get(r) / (right->__get((r + 1)) + left->__get((j - r))));
HXLINE(1126)						basisFunctions[r] = (saved + (right->__get((r + 1)) * temp));
HXLINE(1127)						saved = (left->__get((j - r)) * temp);
            					}
            				}
HXLINE(1130)				basisFunctions[j] = saved;
            			}
            		}
HXLINE(1133)		return basisFunctions;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,basisFunctionsGivenKnotSpanIndex,return )

int Eval_obj::knotSpan(int degree,Float u,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1151_knotSpan)
HXDLIN(1151)		return ::verb::eval::Eval_obj::knotSpanGivenN(((knots->length - degree) - 2),degree,u,knots);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Eval_obj,knotSpan,return )

int Eval_obj::knotSpanGivenN(int n,int degree,Float u,::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1170_knotSpanGivenN)
HXLINE(1171)		if ((u > (knots->__get((n + 1)) - ::verb::core::Constants_obj::EPSILON))) {
HXLINE(1173)			return n;
            		}
HXLINE(1176)		if ((u < (knots->__get(degree) + ::verb::core::Constants_obj::EPSILON))) {
HXLINE(1178)			return degree;
            		}
HXLINE(1181)		int low = degree;
HXDLIN(1181)		int high = (n + 1);
HXDLIN(1181)		int mid = ::Math_obj::floor((( (Float)((low + high)) ) / ( (Float)(2) )));
HXLINE(1185)		while(true){
HXLINE(1185)			bool _hx_tmp;
HXDLIN(1185)			if (!((u < knots->__get(mid)))) {
HXLINE(1185)				_hx_tmp = (u >= knots->__get((mid + 1)));
            			}
            			else {
HXLINE(1185)				_hx_tmp = true;
            			}
HXDLIN(1185)			if (!(_hx_tmp)) {
HXLINE(1185)				goto _hx_goto_86;
            			}
HXLINE(1187)			if ((u < knots->__get(mid))) {
HXLINE(1189)				high = mid;
            			}
            			else {
HXLINE(1193)				low = mid;
            			}
HXLINE(1195)			mid = ::Math_obj::floor((( (Float)((low + high)) ) / ( (Float)(2) )));
            		}
            		_hx_goto_86:;
HXLINE(1198)		return mid;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Eval_obj,knotSpanGivenN,return )

::Array< Float > Eval_obj::dehomogenize(::Array< Float > homoPoint){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1211_dehomogenize)
HXLINE(1213)		int dim = homoPoint->length;
HXDLIN(1213)		::Array< Float > point = ::Array_obj< Float >::__new(0);
HXDLIN(1213)		Float wt = homoPoint->__get((dim - 1));
HXDLIN(1213)		int l = (homoPoint->length - 1);
HXLINE(1218)		{
HXLINE(1218)			int _g = 0;
HXDLIN(1218)			int _g1 = l;
HXDLIN(1218)			while((_g < _g1)){
HXLINE(1218)				_g = (_g + 1);
HXDLIN(1218)				int i = (_g - 1);
HXLINE(1219)				point->push((homoPoint->__get(i) / wt));
            			}
            		}
HXLINE(1222)		return point;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,dehomogenize,return )

::Array< ::Dynamic> Eval_obj::rational1d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1236_rational1d)
HXLINE(1237)		int dim = (homoPoints->__get(0).StaticCast< ::Array< Float > >()->length - 1);
HXLINE(1238)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(homoPoints->length);
HXDLIN(1238)		{
HXLINE(1238)			int _g = 0;
HXDLIN(1238)			int _g1 = homoPoints->length;
HXDLIN(1238)			while((_g < _g1)){
HXLINE(1238)				_g = (_g + 1);
HXDLIN(1238)				int i = (_g - 1);
HXDLIN(1238)				{
HXLINE(1238)					::Array< Float > inValue = ( (::Array< Float >)(_hx_array_unsafe_get(homoPoints,i)) )->slice(0,dim);
HXDLIN(1238)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1238)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,rational1d,return )

::Array< ::Dynamic> Eval_obj::rational2d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1253_rational2d)
HXDLIN(1253)		 ::Dynamic f = ::verb::eval::Eval_obj::rational1d_dyn();
HXDLIN(1253)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(homoPoints->length);
HXDLIN(1253)		{
HXDLIN(1253)			int _g = 0;
HXDLIN(1253)			int _g1 = homoPoints->length;
HXDLIN(1253)			while((_g < _g1)){
HXDLIN(1253)				_g = (_g + 1);
HXDLIN(1253)				int i = (_g - 1);
HXDLIN(1253)				{
HXDLIN(1253)					::Array< ::Dynamic> inValue = ( (::Array< ::Dynamic>)(f(_hx_array_unsafe_get(homoPoints,i))) );
HXDLIN(1253)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1253)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,rational2d,return )

::Array< Float > Eval_obj::weight1d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1267_weight1d)
HXLINE(1268)		int dim = (homoPoints->__get(0).StaticCast< ::Array< Float > >()->length - 1);
HXLINE(1269)		::Array< Float > result = ::Array_obj< Float >::__new(homoPoints->length);
HXDLIN(1269)		{
HXLINE(1269)			int _g = 0;
HXDLIN(1269)			int _g1 = homoPoints->length;
HXDLIN(1269)			while((_g < _g1)){
HXLINE(1269)				_g = (_g + 1);
HXDLIN(1269)				int i = (_g - 1);
HXDLIN(1269)				{
HXLINE(1269)					Float inValue = ( (Float)(_hx_array_unsafe_get(homoPoints,i)->__GetItem(dim)) );
HXDLIN(1269)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1269)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,weight1d,return )

::Array< ::Dynamic> Eval_obj::weight2d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1284_weight2d)
HXDLIN(1284)		 ::Dynamic f = ::verb::eval::Eval_obj::weight1d_dyn();
HXDLIN(1284)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(homoPoints->length);
HXDLIN(1284)		{
HXDLIN(1284)			int _g = 0;
HXDLIN(1284)			int _g1 = homoPoints->length;
HXDLIN(1284)			while((_g < _g1)){
HXDLIN(1284)				_g = (_g + 1);
HXDLIN(1284)				int i = (_g - 1);
HXDLIN(1284)				{
HXDLIN(1284)					::Array< Float > inValue = ( (::Array< Float >)(f(_hx_array_unsafe_get(homoPoints,i))) );
HXDLIN(1284)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1284)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,weight2d,return )

::Array< ::Dynamic> Eval_obj::dehomogenize1d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1298_dehomogenize1d)
HXDLIN(1298)		 ::Dynamic f = ::verb::eval::Eval_obj::dehomogenize_dyn();
HXDLIN(1298)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(homoPoints->length);
HXDLIN(1298)		{
HXDLIN(1298)			int _g = 0;
HXDLIN(1298)			int _g1 = homoPoints->length;
HXDLIN(1298)			while((_g < _g1)){
HXDLIN(1298)				_g = (_g + 1);
HXDLIN(1298)				int i = (_g - 1);
HXDLIN(1298)				{
HXDLIN(1298)					::Array< Float > inValue = ( (::Array< Float >)(f(_hx_array_unsafe_get(homoPoints,i))) );
HXDLIN(1298)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1298)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,dehomogenize1d,return )

::Array< ::Dynamic> Eval_obj::dehomogenize2d(::Array< ::Dynamic> homoPoints){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1312_dehomogenize2d)
HXDLIN(1312)		 ::Dynamic f = ::verb::eval::Eval_obj::dehomogenize1d_dyn();
HXDLIN(1312)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(homoPoints->length);
HXDLIN(1312)		{
HXDLIN(1312)			int _g = 0;
HXDLIN(1312)			int _g1 = homoPoints->length;
HXDLIN(1312)			while((_g < _g1)){
HXDLIN(1312)				_g = (_g + 1);
HXDLIN(1312)				int i = (_g - 1);
HXDLIN(1312)				{
HXDLIN(1312)					::Array< ::Dynamic> inValue = ( (::Array< ::Dynamic>)(f(_hx_array_unsafe_get(homoPoints,i))) );
HXDLIN(1312)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(1312)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Eval_obj,dehomogenize2d,return )

::Array< ::Dynamic> Eval_obj::homogenize1d(::Array< ::Dynamic> controlPoints,::Array< Float > weights){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1328_homogenize1d)
HXLINE(1330)		int rows = controlPoints->length;
HXDLIN(1330)		int dim = controlPoints->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN(1330)		::Array< ::Dynamic> homo_controlPoints = ::Array_obj< ::Dynamic>::__new();
HXDLIN(1330)		Float wt = ((Float)0.0);
HXDLIN(1330)		::Array< Float > ref_pt = ::Array_obj< Float >::__new();
HXDLIN(1330)		::Array< Float > weights1;
HXLINE(1335)		if (::hx::IsNotNull( weights )) {
HXLINE(1330)			weights1 = weights;
            		}
            		else {
HXLINE(1330)			weights1 = ::verb::core::Vec_obj::fill(controlPoints->length,((Float)1.0));
            		}
HXLINE(1337)		{
HXLINE(1337)			int _g = 0;
HXDLIN(1337)			int _g1 = rows;
HXDLIN(1337)			while((_g < _g1)){
HXLINE(1337)				_g = (_g + 1);
HXDLIN(1337)				int i = (_g - 1);
HXLINE(1339)				::Array< Float > pt = ::Array_obj< Float >::__new(0);
HXLINE(1340)				ref_pt = controlPoints->__get(i).StaticCast< ::Array< Float > >();
HXLINE(1341)				wt = weights1->__get(i);
HXLINE(1343)				{
HXLINE(1343)					int _g1 = 0;
HXDLIN(1343)					int _g2 = dim;
HXDLIN(1343)					while((_g1 < _g2)){
HXLINE(1343)						_g1 = (_g1 + 1);
HXDLIN(1343)						int k = (_g1 - 1);
HXLINE(1344)						pt->push((ref_pt->__get(k) * wt));
            					}
            				}
HXLINE(1348)				pt->push(wt);
HXLINE(1350)				homo_controlPoints->push(pt);
            			}
            		}
HXLINE(1353)		return homo_controlPoints;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,homogenize1d,return )

::Array< ::Dynamic> Eval_obj::homogenize2d(::Array< ::Dynamic> controlPoints,::Array< ::Dynamic> weights){
            	HX_STACKFRAME(&_hx_pos_3844315661bdc8bc_1369_homogenize2d)
HXLINE(1370)		int rows = controlPoints->length;
HXDLIN(1370)		::Array< ::Dynamic> homo_controlPoints = ::Array_obj< ::Dynamic>::__new();
HXDLIN(1370)		::Array< ::Dynamic> weights1;
HXLINE(1372)		if (::hx::IsNotNull( weights )) {
HXLINE(1370)			weights1 = weights;
            		}
            		else {
HXLINE(1372)			::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(1372)			{
HXLINE(1372)				int _g1 = 0;
HXDLIN(1372)				int _g2 = rows;
HXDLIN(1372)				while((_g1 < _g2)){
HXLINE(1372)					_g1 = (_g1 + 1);
HXDLIN(1372)					int i = (_g1 - 1);
HXDLIN(1372)					_g->push(::verb::core::Vec_obj::fill(controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length,((Float)1.0)));
            				}
            			}
HXLINE(1370)			weights1 = _g;
            		}
HXLINE(1374)		{
HXLINE(1374)			int _g = 0;
HXDLIN(1374)			int _g1 = rows;
HXDLIN(1374)			while((_g < _g1)){
HXLINE(1374)				_g = (_g + 1);
HXDLIN(1374)				int i = (_g - 1);
HXLINE(1375)				homo_controlPoints->push(::verb::eval::Eval_obj::homogenize1d(controlPoints->__get(i).StaticCast< ::Array< ::Dynamic> >(),weights1->__get(i).StaticCast< ::Array< Float > >()));
            			}
            		}
HXLINE(1378)		return homo_controlPoints;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Eval_obj,homogenize2d,return )


Eval_obj::Eval_obj()
{
}

bool Eval_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"knotSpan") ) { outValue = knotSpan_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"weight1d") ) { outValue = weight1d_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"weight2d") ) { outValue = weight2d_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"curvePoint") ) { outValue = curvePoint_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rational1d") ) { outValue = rational1d_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rational2d") ) { outValue = rational2d_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"volumePoint") ) { outValue = volumePoint_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"surfacePoint") ) { outValue = surfacePoint_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dehomogenize") ) { outValue = dehomogenize_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"homogenize1d") ) { outValue = homogenize1d_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"homogenize2d") ) { outValue = homogenize2d_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"basisFunctions") ) { outValue = basisFunctions_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"knotSpanGivenN") ) { outValue = knotSpanGivenN_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dehomogenize1d") ) { outValue = dehomogenize1d_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dehomogenize2d") ) { outValue = dehomogenize2d_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"curveDerivatives") ) { outValue = curveDerivatives_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curvePointGivenN") ) { outValue = curvePointGivenN_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"areValidRelations") ) { outValue = areValidRelations_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"rationalCurvePoint") ) { outValue = rationalCurvePoint_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"surfaceDerivatives") ) { outValue = surfaceDerivatives_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"surfacePointGivenNM") ) { outValue = surfacePointGivenNM_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"volumePointGivenNML") ) { outValue = volumePointGivenNML_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"rationalCurveTangent") ) { outValue = rationalCurveTangent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rationalSurfacePoint") ) { outValue = rationalSurfacePoint_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"rationalSurfaceNormal") ) { outValue = rationalSurfaceNormal_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"curveDerivativesGivenN") ) { outValue = curveDerivativesGivenN_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"rationalCurveDerivatives") ) { outValue = rationalCurveDerivatives_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curveRegularSamplePoints") ) { outValue = curveRegularSamplePoints_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"derivativeBasisFunctions") ) { outValue = derivativeBasisFunctions_dyn(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"surfaceDerivativesGivenNM") ) { outValue = surfaceDerivativesGivenNM_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curveRegularSamplePoints2") ) { outValue = curveRegularSamplePoints2_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"rationalSurfaceDerivatives") ) { outValue = rationalSurfaceDerivatives_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"surfaceRegularSamplePoints") ) { outValue = surfaceRegularSamplePoints_dyn(); return true; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"regularlySpacedBasisFunctions") ) { outValue = regularlySpacedBasisFunctions_dyn(); return true; }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"surfaceRegularSampleDerivatives") ) { outValue = surfaceRegularSampleDerivatives_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"surfacePointGivenBasesKnotSpans") ) { outValue = surfacePointGivenBasesKnotSpans_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"derivativeBasisFunctionsGivenNI") ) { outValue = derivativeBasisFunctionsGivenNI_dyn(); return true; }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"basisFunctionsGivenKnotSpanIndex") ) { outValue = basisFunctionsGivenKnotSpanIndex_dyn(); return true; }
		break;
	case 34:
		if (HX_FIELD_EQ(inName,"rationalSurfaceRegularSamplePoints") ) { outValue = rationalSurfaceRegularSamplePoints_dyn(); return true; }
		break;
	case 37:
		if (HX_FIELD_EQ(inName,"surfaceDerivativesGivenBasesKnotSpans") ) { outValue = surfaceDerivativesGivenBasesKnotSpans_dyn(); return true; }
		break;
	case 39:
		if (HX_FIELD_EQ(inName,"rationalSurfaceRegularSampleDerivatives") ) { outValue = rationalSurfaceRegularSampleDerivatives_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"regularlySpacedDerivativeBasisFunctions") ) { outValue = regularlySpacedDerivativeBasisFunctions_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Eval_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Eval_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Eval_obj::__mClass;

static ::String Eval_obj_sStaticFields[] = {
	HX_("rationalCurveTangent",a4,a5,27,b1),
	HX_("rationalSurfaceNormal",a6,96,ce,35),
	HX_("rationalSurfaceDerivatives",ad,41,ff,89),
	HX_("rationalSurfacePoint",b1,e4,b4,81),
	HX_("rationalCurveDerivatives",eb,76,8d,e3),
	HX_("rationalCurvePoint",6f,77,1b,f0),
	HX_("surfaceDerivatives",5f,49,11,5b),
	HX_("surfaceDerivativesGivenNM",5d,bf,9d,ed),
	HX_("surfacePoint",e3,3a,b1,98),
	HX_("surfacePointGivenNM",59,c6,50,2d),
	HX_("curveRegularSamplePoints",fa,4e,46,32),
	HX_("curveRegularSamplePoints2",f8,cb,3e,cb),
	HX_("rationalSurfaceRegularSampleDerivatives",c5,7c,46,c6),
	HX_("surfaceRegularSampleDerivatives",d3,0d,c0,4b),
	HX_("rationalSurfaceRegularSamplePoints",8a,d2,c5,9e),
	HX_("surfaceRegularSamplePoints",3c,dc,91,17),
	HX_("regularlySpacedBasisFunctions",c4,6b,0e,d1),
	HX_("regularlySpacedDerivativeBasisFunctions",eb,c0,47,4b),
	HX_("surfacePointGivenBasesKnotSpans",59,e1,98,f9),
	HX_("surfaceDerivativesGivenBasesKnotSpans",5d,50,f9,4c),
	HX_("curveDerivatives",1d,ce,75,68),
	HX_("curveDerivativesGivenN",2e,7a,68,d0),
	HX_("curvePoint",21,7d,45,24),
	HX_("areValidRelations",0f,97,75,28),
	HX_("curvePointGivenN",32,44,fb,a3),
	HX_("volumePoint",16,04,22,59),
	HX_("volumePointGivenNML",06,7c,56,bb),
	HX_("derivativeBasisFunctions",24,de,36,1f),
	HX_("derivativeBasisFunctionsGivenNI",34,7d,e4,55),
	HX_("basisFunctions",bd,77,cb,0f),
	HX_("basisFunctionsGivenKnotSpanIndex",a0,c0,99,e5),
	HX_("knotSpan",72,18,99,29),
	HX_("knotSpanGivenN",43,b2,bf,90),
	HX_("dehomogenize",6e,c2,fd,1c),
	HX_("rational1d",41,43,ec,7f),
	HX_("rational2d",20,44,ec,7f),
	HX_("weight1d",8b,ea,3f,8d),
	HX_("weight2d",6a,eb,3f,8d),
	HX_("dehomogenize1d",01,e5,c5,a9),
	HX_("dehomogenize2d",e0,e5,c5,a9),
	HX_("homogenize1d",00,d0,1f,19),
	HX_("homogenize2d",df,d0,1f,19),
	::String(null())
};

void Eval_obj::__register()
{
	Eval_obj _hx_dummy;
	Eval_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Eval",3f,a1,ab,9b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Eval_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Eval_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Eval_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Eval_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Eval_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
