// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_Binomial
#include <verb/core/Binomial.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_Interval
#include <verb/core/Interval.h>
#endif
#ifndef INCLUDED_verb_core_Mat
#include <verb/core/Mat.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_Analyze
#include <verb/eval/Analyze.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif
#ifndef INCLUDED_verb_eval_KnotMultiplicity
#include <verb/eval/KnotMultiplicity.h>
#endif
#ifndef INCLUDED_verb_eval_Make
#include <verb/eval/Make.h>
#endif
#ifndef INCLUDED_verb_eval_Modify
#include <verb/eval/Modify.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_39_curveReverse,"verb.eval.Modify","curveReverse",0xf77ae664,"verb.eval.Modify.curveReverse","verb/eval/Modify.hx",39,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_53_surfaceReverse,"verb.eval.Modify","surfaceReverse",0x81f7c6e6,"verb.eval.Modify.surfaceReverse","verb/eval/Modify.hx",53,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_74_knotsReverse,"verb.eval.Modify","knotsReverse",0xb96168a8,"verb.eval.Modify.knotsReverse","verb/eval/Modify.hx",74,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_100_unifyCurveKnotVectors,"verb.eval.Modify","unifyCurveKnotVectors",0x7449844b,"verb.eval.Modify.unifyCurveKnotVectors","verb/eval/Modify.hx",100,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_119_unifyCurveKnotVectors,"verb.eval.Modify","unifyCurveKnotVectors",0x7449844b,"verb.eval.Modify.unifyCurveKnotVectors","verb/eval/Modify.hx",119,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_128_unifyCurveKnotVectors,"verb.eval.Modify","unifyCurveKnotVectors",0x7449844b,"verb.eval.Modify.unifyCurveKnotVectors","verb/eval/Modify.hx",128,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_97_unifyCurveKnotVectors,"verb.eval.Modify","unifyCurveKnotVectors",0x7449844b,"verb.eval.Modify.unifyCurveKnotVectors","verb/eval/Modify.hx",97,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_143_imin,"verb.eval.Modify","imin",0x13f0adfa,"verb.eval.Modify.imin","verb/eval/Modify.hx",143,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_147_imax,"verb.eval.Modify","imax",0x13f0a70c,"verb.eval.Modify.imax","verb/eval/Modify.hx",147,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_161_curveElevateDegree,"verb.eval.Modify","curveElevateDegree",0xa103ac28,"verb.eval.Modify.curveElevateDegree","verb/eval/Modify.hx",161,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_337_rationalSurfaceTransform,"verb.eval.Modify","rationalSurfaceTransform",0x782bf5fe,"verb.eval.Modify.rationalSurfaceTransform","verb/eval/Modify.hx",337,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_364_rationalCurveTransform,"verb.eval.Modify","rationalCurveTransform",0xcd90c17c,"verb.eval.Modify.rationalCurveTransform","verb/eval/Modify.hx",364,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_392_surfaceKnotRefine,"verb.eval.Modify","surfaceKnotRefine",0x7874e5d1,"verb.eval.Modify.surfaceKnotRefine","verb/eval/Modify.hx",392,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_445_decomposeCurveIntoBeziers,"verb.eval.Modify","decomposeCurveIntoBeziers",0x88824745,"verb.eval.Modify.decomposeCurveIntoBeziers","verb/eval/Modify.hx",445,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_502_curveKnotRefine,"verb.eval.Modify","curveKnotRefine",0xe7b80913,"verb.eval.Modify.curveKnotRefine","verb/eval/Modify.hx",502,0x8f2449a1)
HX_LOCAL_STACK_FRAME(_hx_pos_5ffdee8f27f0ca91_598_curveKnotInsert,"verb.eval.Modify","curveKnotInsert",0x85b1c2df,"verb.eval.Modify.curveKnotInsert","verb/eval/Modify.hx",598,0x8f2449a1)
namespace verb{
namespace eval{

void Modify_obj::__construct() { }

Dynamic Modify_obj::__CreateEmpty() { return new Modify_obj; }

void *Modify_obj::_hx_vtable = 0;

Dynamic Modify_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Modify_obj > _hx_result = new Modify_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Modify_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0f655fb9;
}

 ::verb::core::NurbsCurveData Modify_obj::curveReverse( ::verb::core::NurbsCurveData curve){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_39_curveReverse)
HXDLIN(  39)		int curve1 = curve->degree;
HXDLIN(  39)		::Array< Float > _hx_tmp = ::verb::eval::Modify_obj::knotsReverse(curve->knots);
HXDLIN(  39)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,curve1,_hx_tmp,::verb::core::ArrayExtensions_obj::reversed(curve->controlPoints));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Modify_obj,curveReverse,return )

 ::verb::core::NurbsSurfaceData Modify_obj::surfaceReverse( ::verb::core::NurbsSurfaceData surface,::hx::Null< bool >  __o_useV){
            		bool useV = __o_useV.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_53_surfaceReverse)
HXLINE(  54)		if (useV) {
HXLINE(  55)			int surface1 = surface->degreeU;
HXDLIN(  55)			int surface2 = surface->degreeV;
HXDLIN(  55)			::Array< Float > surface3 = surface->knotsU;
HXDLIN(  55)			::Array< Float > _hx_tmp = ::verb::eval::Modify_obj::knotsReverse(surface->knotsV);
HXLINE(  56)			::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  56)			{
HXLINE(  56)				int _g1 = 0;
HXDLIN(  56)				::Array< ::Dynamic> _g2 = surface->controlPoints;
HXDLIN(  56)				while((_g1 < _g2->length)){
HXLINE(  56)					::Array< ::Dynamic> row = _g2->__get(_g1).StaticCast< ::Array< ::Dynamic> >();
HXDLIN(  56)					_g1 = (_g1 + 1);
HXDLIN(  56)					_g->push(::verb::core::ArrayExtensions_obj::reversed(row));
            				}
            			}
HXLINE(  55)			return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,surface2,surface3,_hx_tmp,_g);
            		}
HXLINE(  60)		int surface1 = surface->degreeU;
HXDLIN(  60)		int surface2 = surface->degreeV;
HXDLIN(  60)		::Array< Float > _hx_tmp = ::verb::eval::Modify_obj::knotsReverse(surface->knotsU);
HXDLIN(  60)		::Array< Float > surface3 = surface->knotsV;
HXDLIN(  60)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,surface2,_hx_tmp,surface3,::verb::core::ArrayExtensions_obj::reversed(surface->controlPoints));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,surfaceReverse,return )

::Array< Float > Modify_obj::knotsReverse(::Array< Float > knots){
            	HX_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_74_knotsReverse)
HXLINE(  75)		Float min = ( (Float)(::verb::core::ArrayExtensions_obj::first(knots)) );
HXLINE(  76)		Float max = ( (Float)(::verb::core::ArrayExtensions_obj::last(knots)) );
HXLINE(  78)		::Array< Float > l = ::Array_obj< Float >::__new(1)->init(0,min);
HXLINE(  79)		int len = knots->length;
HXLINE(  80)		{
HXLINE(  80)			int _g = 1;
HXDLIN(  80)			int _g1 = len;
HXDLIN(  80)			while((_g < _g1)){
HXLINE(  80)				_g = (_g + 1);
HXDLIN(  80)				int i = (_g - 1);
HXLINE(  81)				l->push((l->__get((i - 1)) + (knots->__get((len - i)) - knots->__get(((len - i) - 1)))));
            			}
            		}
HXLINE(  84)		return l;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Modify_obj,knotsReverse,return )

::Array< ::Dynamic> Modify_obj::unifyCurveKnotVectors(::Array< ::Dynamic> curves){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		int _hx_run( ::verb::core::NurbsCurveData x,int a){
            			HX_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_100_unifyCurveKnotVectors)
HXLINE( 100)			return ::verb::eval::Modify_obj::imax(x->degree,a);
            		}
            		HX_END_LOCAL_FUNC2(return)

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(2)
            		Float _hx_run(Float x,Float a){
            			HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_119_unifyCurveKnotVectors)
HXLINE( 119)			return ::Math_obj::max(x,a);
            		}
            		HX_END_LOCAL_FUNC2(return)

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_2) HXARGC(2)
            		::Array< Float > _hx_run( ::verb::core::NurbsCurveData x,::Array< Float > a){
            			HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_128_unifyCurveKnotVectors)
HXLINE( 128)			return ::verb::core::Vec_obj::sortedSetUnion(x->knots,a);
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_97_unifyCurveKnotVectors)
HXLINE(  98)		 ::Dynamic f = ::verb::eval::Make_obj::clonedCurve_dyn();
HXDLIN(  98)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(curves->length);
HXDLIN(  98)		{
HXLINE(  98)			int _g = 0;
HXDLIN(  98)			int _g1 = curves->length;
HXDLIN(  98)			while((_g < _g1)){
HXLINE(  98)				_g = (_g + 1);
HXDLIN(  98)				int i = (_g - 1);
HXDLIN(  98)				{
HXLINE(  98)					 ::verb::core::NurbsCurveData inValue = ( ( ::verb::core::NurbsCurveData)(f(_hx_array_unsafe_get(curves,i))) );
HXDLIN(  98)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(  98)		curves = result;
HXLINE( 100)		int maxDegree = ( (int)(::Lambda_obj::fold(curves, ::Dynamic(new _hx_Closure_0()),0)) );
HXLINE( 103)		{
HXLINE( 103)			int _g2 = 0;
HXDLIN( 103)			int _g3 = curves->length;
HXDLIN( 103)			while((_g2 < _g3)){
HXLINE( 103)				_g2 = (_g2 + 1);
HXDLIN( 103)				int i = (_g2 - 1);
HXLINE( 104)				if ((curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->degree < maxDegree)) {
HXLINE( 105)					curves[i] = ::verb::eval::Modify_obj::curveElevateDegree(curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >(),maxDegree);
            				}
            			}
            		}
HXLINE( 109)		::Array< ::Dynamic> _g4 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 109)		{
HXLINE( 109)			int _g5 = 0;
HXDLIN( 109)			while((_g5 < curves->length)){
HXLINE( 109)				 ::verb::core::NurbsCurveData c = curves->__get(_g5).StaticCast<  ::verb::core::NurbsCurveData >();
HXDLIN( 109)				_g5 = (_g5 + 1);
HXDLIN( 109)				Float _hx_tmp = ( (Float)(::verb::core::ArrayExtensions_obj::first(c->knots)) );
HXDLIN( 109)				_g4->push( ::verb::core::Interval_obj::__alloc( HX_CTX ,_hx_tmp,::verb::core::ArrayExtensions_obj::last(c->knots)));
            			}
            		}
HXDLIN( 109)		::Array< ::Dynamic> knotIntervals = _g4;
HXLINE( 112)		{
HXLINE( 112)			int _g6 = 0;
HXDLIN( 112)			int _g7 = curves->length;
HXDLIN( 112)			while((_g6 < _g7)){
HXLINE( 112)				_g6 = (_g6 + 1);
HXDLIN( 112)				int i = (_g6 - 1);
HXLINE( 113)				Float min = ( (Float)(knotIntervals->__get(i).StaticCast<  ::verb::core::Interval >()->min) );
HXLINE( 114)				::Array< Float > _this = curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->knots;
HXDLIN( 114)				::Array< Float > result = ::Array_obj< Float >::__new(_this->length);
HXDLIN( 114)				{
HXLINE( 114)					int _g = 0;
HXDLIN( 114)					int _g1 = _this->length;
HXDLIN( 114)					while((_g < _g1)){
HXLINE( 114)						_g = (_g + 1);
HXDLIN( 114)						int i = (_g - 1);
HXDLIN( 114)						{
HXLINE( 114)							Float inValue = (( (Float)(_hx_array_unsafe_get(_this,i)) ) - min);
HXDLIN( 114)							result->__unsafe_set(i,inValue);
            						}
            					}
            				}
HXDLIN( 114)				curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->knots = result;
            			}
            		}
HXLINE( 118)		::Array< Float > result1 = ::Array_obj< Float >::__new(knotIntervals->length);
HXDLIN( 118)		{
HXLINE( 118)			int _g8 = 0;
HXDLIN( 118)			int _g9 = knotIntervals->length;
HXDLIN( 118)			while((_g8 < _g9)){
HXLINE( 118)				_g8 = (_g8 + 1);
HXDLIN( 118)				int i = (_g8 - 1);
HXDLIN( 118)				{
HXLINE( 118)					 ::verb::core::Interval x = ( ( ::verb::core::Interval)(_hx_array_unsafe_get(knotIntervals,i)) );
HXDLIN( 118)					result1->__unsafe_set(i,(( (Float)(x->max) ) - ( (Float)(x->min) )));
            				}
            			}
            		}
HXDLIN( 118)		::Array< Float > knotSpans = result1;
HXLINE( 119)		Float maxKnotSpan = ( (Float)(::Lambda_obj::fold(knotSpans, ::Dynamic(new _hx_Closure_1()),((Float)0.0))) );
HXLINE( 122)		{
HXLINE( 122)			int _g10 = 0;
HXDLIN( 122)			int _g11 = curves->length;
HXDLIN( 122)			while((_g10 < _g11)){
HXLINE( 122)				_g10 = (_g10 + 1);
HXDLIN( 122)				int i = (_g10 - 1);
HXLINE( 123)				Float scale = (maxKnotSpan / knotSpans->__get(i));
HXLINE( 124)				::Array< Float > _this = curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->knots;
HXDLIN( 124)				::Array< Float > result = ::Array_obj< Float >::__new(_this->length);
HXDLIN( 124)				{
HXLINE( 124)					int _g = 0;
HXDLIN( 124)					int _g1 = _this->length;
HXDLIN( 124)					while((_g < _g1)){
HXLINE( 124)						_g = (_g + 1);
HXDLIN( 124)						int i = (_g - 1);
HXDLIN( 124)						{
HXLINE( 124)							Float inValue = (( (Float)(_hx_array_unsafe_get(_this,i)) ) * scale);
HXDLIN( 124)							result->__unsafe_set(i,inValue);
            						}
            					}
            				}
HXDLIN( 124)				curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->knots = result;
            			}
            		}
HXLINE( 128)		::Array< Float > mergedKnots = ( (::Array< Float >)(::Lambda_obj::fold(curves, ::Dynamic(new _hx_Closure_2()),::Array_obj< Float >::__new(0))) );
HXLINE( 131)		{
HXLINE( 131)			int _g12 = 0;
HXDLIN( 131)			int _g13 = curves->length;
HXDLIN( 131)			while((_g12 < _g13)){
HXLINE( 131)				_g12 = (_g12 + 1);
HXDLIN( 131)				int i = (_g12 - 1);
HXLINE( 132)				::Array< Float > rem = ::verb::core::Vec_obj::sortedSetSub(mergedKnots,curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >()->knots);
HXLINE( 133)				if ((rem->length == 0)) {
HXLINE( 134)					curves[i] = curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >();
            				}
HXLINE( 136)				curves[i] = ::verb::eval::Modify_obj::curveKnotRefine(curves->__get(i).StaticCast<  ::verb::core::NurbsCurveData >(),rem);
            			}
            		}
HXLINE( 139)		return curves;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Modify_obj,unifyCurveKnotVectors,return )

int Modify_obj::imin(int a,int b){
            	HX_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_143_imin)
HXDLIN( 143)		if ((a < b)) {
HXDLIN( 143)			return a;
            		}
            		else {
HXDLIN( 143)			return b;
            		}
HXDLIN( 143)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,imin,return )

int Modify_obj::imax(int a,int b){
            	HX_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_147_imax)
HXDLIN( 147)		if ((a > b)) {
HXDLIN( 147)			return a;
            		}
            		else {
HXDLIN( 147)			return b;
            		}
HXDLIN( 147)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,imax,return )

 ::verb::core::NurbsCurveData Modify_obj::curveElevateDegree( ::verb::core::NurbsCurveData curve,int finalDegree){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_161_curveElevateDegree)
HXLINE( 163)		if ((finalDegree <= curve->degree)) {
HXLINE( 163)			return curve;
            		}
HXLINE( 166)		int n = ((curve->knots->length - curve->degree) - 2);
HXLINE( 167)		int newDegree = curve->degree;
HXLINE( 168)		::Array< Float > knots = curve->knots;
HXLINE( 169)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXLINE( 170)		int degreeInc = (finalDegree - curve->degree);
HXLINE( 172)		int dim = curve->controlPoints->__get(0).StaticCast< ::Array< Float > >()->length;
HXLINE( 175)		::Array< ::Dynamic> bezalfs = ::verb::core::Vec_obj::zeros2d(((newDegree + degreeInc) + 1),(newDegree + 1));
HXLINE( 176)		::Array< ::Dynamic> bpts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 177)		::Array< ::Dynamic> ebpts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 178)		::Array< ::Dynamic> Nextbpts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 181)		int m = ((n + newDegree) + 1);
HXLINE( 182)		int ph = finalDegree;
HXLINE( 183)		int ph2 = ::Math_obj::floor((( (Float)(ph) ) / ( (Float)(2) )));
HXLINE( 186)		::Array< ::Dynamic> Qw = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 187)		::Array< Float > Uh = ::Array_obj< Float >::__new(0);
HXLINE( 190)		bezalfs->__get(0).StaticCast< ::Array< Float > >()[0] = ((Float)1.0);
HXLINE( 191)		bezalfs->__get(ph).StaticCast< ::Array< Float > >()[newDegree] = ((Float)1.0);
HXLINE( 193)		{
HXLINE( 193)			int _g = 1;
HXDLIN( 193)			int _g1 = (ph2 + 1);
HXDLIN( 193)			while((_g < _g1)){
HXLINE( 193)				_g = (_g + 1);
HXDLIN( 193)				int i = (_g - 1);
HXLINE( 194)				Float inv = (((Float)1.0) / ::verb::core::Binomial_obj::get(ph,i));
HXLINE( 195)				int mpi = ::verb::eval::Modify_obj::imin(newDegree,i);
HXLINE( 196)				{
HXLINE( 196)					int _g1 = ::verb::eval::Modify_obj::imax(0,(i - degreeInc));
HXDLIN( 196)					int _g2 = (mpi + 1);
HXDLIN( 196)					while((_g1 < _g2)){
HXLINE( 196)						_g1 = (_g1 + 1);
HXDLIN( 196)						int j = (_g1 - 1);
HXLINE( 197)						::Array< Float > bezalfs1 = bezalfs->__get(i).StaticCast< ::Array< Float > >();
HXDLIN( 197)						Float _hx_tmp = (inv * ::verb::core::Binomial_obj::get(newDegree,j));
HXDLIN( 197)						bezalfs1[j] = (_hx_tmp * ::verb::core::Binomial_obj::get(degreeInc,(i - j)));
            					}
            				}
            			}
            		}
HXLINE( 200)		{
HXLINE( 200)			int _g2 = (ph2 + 1);
HXDLIN( 200)			int _g3 = ph;
HXDLIN( 200)			while((_g2 < _g3)){
HXLINE( 200)				_g2 = (_g2 + 1);
HXDLIN( 200)				int i = (_g2 - 1);
HXLINE( 201)				int mpi = ::verb::eval::Modify_obj::imin(newDegree,i);
HXLINE( 202)				{
HXLINE( 202)					int _g = ::verb::eval::Modify_obj::imax(0,(i - degreeInc));
HXDLIN( 202)					int _g1 = (mpi + 1);
HXDLIN( 202)					while((_g < _g1)){
HXLINE( 202)						_g = (_g + 1);
HXDLIN( 202)						int j = (_g - 1);
HXLINE( 203)						bezalfs->__get(i).StaticCast< ::Array< Float > >()[j] = bezalfs->__get((ph - i)).StaticCast< ::Array< Float > >()->__get((newDegree - j));
            					}
            				}
            			}
            		}
HXLINE( 206)		int mh = ph;
HXLINE( 207)		int kind = (ph + 1);
HXLINE( 208)		int r = -1;
HXLINE( 209)		int a = newDegree;
HXLINE( 210)		int b = (newDegree + 1);
HXLINE( 211)		int cind = 1;
HXLINE( 212)		Float ua = knots->__get(0);
HXLINE( 213)		Qw[0] = controlPoints->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 214)		{
HXLINE( 214)			int _g4 = 0;
HXDLIN( 214)			int _g5 = (ph + 1);
HXDLIN( 214)			while((_g4 < _g5)){
HXLINE( 214)				_g4 = (_g4 + 1);
HXDLIN( 214)				int i = (_g4 - 1);
HXLINE( 215)				Uh[i] = ua;
            			}
            		}
HXLINE( 217)		{
HXLINE( 217)			int _g6 = 0;
HXDLIN( 217)			int _g7 = (newDegree + 1);
HXDLIN( 217)			while((_g6 < _g7)){
HXLINE( 217)				_g6 = (_g6 + 1);
HXDLIN( 217)				int i = (_g6 - 1);
HXLINE( 218)				bpts[i] = controlPoints->__get(i).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 220)		while((b < m)){
HXLINE( 221)			int i = b;
HXLINE( 222)			while(true){
HXLINE( 222)				bool _hx_tmp;
HXDLIN( 222)				if ((b < m)) {
HXLINE( 222)					_hx_tmp = (knots->__get(b) == knots->__get((b + 1)));
            				}
            				else {
HXLINE( 222)					_hx_tmp = false;
            				}
HXDLIN( 222)				if (!(_hx_tmp)) {
HXLINE( 222)					goto _hx_goto_27;
            				}
HXLINE( 223)				b = (b + 1);
            			}
            			_hx_goto_27:;
HXLINE( 225)			int mul = ((b - i) + 1);
HXLINE( 226)			int mh1 = ((mh + mul) + degreeInc);
HXLINE( 227)			Float ub = knots->__get(b);
HXLINE( 228)			int oldr = r;
HXLINE( 229)			r = (newDegree - mul);
HXLINE( 231)			int lbz;
HXDLIN( 231)			if ((oldr > 0)) {
HXLINE( 231)				lbz = ::Math_obj::floor((( (Float)((oldr + 2)) ) / ( (Float)(2) )));
            			}
            			else {
HXLINE( 231)				lbz = 1;
            			}
HXLINE( 232)			int rbz;
HXDLIN( 232)			if ((r > 0)) {
HXLINE( 232)				rbz = ::Math_obj::floor((( (Float)(ph) ) - (( (Float)((r + 1)) ) / ( (Float)(2) ))));
            			}
            			else {
HXLINE( 232)				rbz = ph;
            			}
HXLINE( 233)			if ((r > 0)) {
HXLINE( 234)				Float numer = (ub - ua);
HXLINE( 235)				::Array< Float > alfs = ::Array_obj< Float >::__new(0);
HXLINE( 236)				int k = newDegree;
HXLINE( 237)				while((k > mul)){
HXLINE( 238)					alfs[((k - mul) - 1)] = (numer / (knots->__get((a + k)) - ua));
HXLINE( 239)					k = (k - 1);
            				}
HXLINE( 241)				{
HXLINE( 241)					int _g = 1;
HXDLIN( 241)					int _g1 = (r + 1);
HXDLIN( 241)					while((_g < _g1)){
HXLINE( 241)						_g = (_g + 1);
HXDLIN( 241)						int j = (_g - 1);
HXLINE( 242)						int save = (r - j);
HXLINE( 243)						int s = (mul + j);
HXLINE( 244)						int k = newDegree;
HXLINE( 245)						while((k >= s)){
HXLINE( 246)							::Array< Float > _hx_tmp = ::verb::core::Vec_obj::mul(alfs->__get((k - s)),bpts->__get(k).StaticCast< ::Array< Float > >());
HXDLIN( 246)							bpts[k] = ::verb::core::Vec_obj::add(_hx_tmp,::verb::core::Vec_obj::mul((((Float)1.0) - alfs->__get((k - s))),bpts->__get((k - 1)).StaticCast< ::Array< Float > >()));
HXLINE( 247)							k = (k - 1);
            						}
HXLINE( 249)						Nextbpts[save] = bpts->__get(newDegree).StaticCast< ::Array< Float > >();
            					}
            				}
            			}
HXLINE( 253)			{
HXLINE( 253)				int _g = lbz;
HXDLIN( 253)				int _g1 = (ph + 1);
HXDLIN( 253)				while((_g < _g1)){
HXLINE( 253)					_g = (_g + 1);
HXDLIN( 253)					int i = (_g - 1);
HXLINE( 254)					ebpts[i] = ::verb::core::Vec_obj::zeros1d(dim);
HXLINE( 255)					int mpi = ::verb::eval::Modify_obj::imin(newDegree,i);
HXLINE( 256)					{
HXLINE( 256)						int _g1 = ::verb::eval::Modify_obj::imax(0,(i - degreeInc));
HXDLIN( 256)						int _g2 = (mpi + 1);
HXDLIN( 256)						while((_g1 < _g2)){
HXLINE( 256)							_g1 = (_g1 + 1);
HXDLIN( 256)							int j = (_g1 - 1);
HXLINE( 257)							::Array< Float > ebpts1 = ebpts->__get(i).StaticCast< ::Array< Float > >();
HXDLIN( 257)							ebpts[i] = ::verb::core::Vec_obj::add(ebpts1,::verb::core::Vec_obj::mul(bezalfs->__get(i).StaticCast< ::Array< Float > >()->__get(j),bpts->__get(j).StaticCast< ::Array< Float > >()));
            						}
            					}
            				}
            			}
HXLINE( 261)			if ((oldr > 1)) {
HXLINE( 262)				int first = (kind - 2);
HXLINE( 263)				int last = kind;
HXLINE( 264)				Float den = (ub - ua);
HXLINE( 265)				Float bet = ((ub - Uh->__get((kind - 1))) / den);
HXLINE( 266)				{
HXLINE( 266)					int _g = 1;
HXDLIN( 266)					int _g1 = oldr;
HXDLIN( 266)					while((_g < _g1)){
HXLINE( 266)						_g = (_g + 1);
HXDLIN( 266)						int tr = (_g - 1);
HXLINE( 267)						int i = first;
HXLINE( 268)						int j = last;
HXLINE( 269)						int kj = ((j - kind) + 1);
HXLINE( 270)						while(((j - i) > tr)){
HXLINE( 271)							if ((i < cind)) {
HXLINE( 272)								Float alf = ((ub - Uh->__get(i)) / (ua - Uh->__get(i)));
HXLINE( 273)								Qw[i] = ::verb::core::Vec_obj::lerp(alf,Qw->__get(i).StaticCast< ::Array< Float > >(),Qw->__get((i - 1)).StaticCast< ::Array< Float > >());
            							}
HXLINE( 275)							if ((j >= lbz)) {
HXLINE( 276)								if (((j - tr) <= ((kind - ph) + oldr))) {
HXLINE( 277)									Float gam = ((ub - Uh->__get((j - tr))) / den);
HXLINE( 278)									ebpts[kj] = ::verb::core::Vec_obj::lerp(gam,ebpts->__get(kj).StaticCast< ::Array< Float > >(),ebpts->__get((kj + 1)).StaticCast< ::Array< Float > >());
            								}
            							}
            							else {
HXLINE( 281)								ebpts[kj] = ::verb::core::Vec_obj::lerp(bet,ebpts->__get(kj).StaticCast< ::Array< Float > >(),ebpts->__get((kj + 1)).StaticCast< ::Array< Float > >());
            							}
HXLINE( 283)							i = (i + 1);
HXLINE( 284)							j = (j - 1);
HXLINE( 285)							kj = (kj - 1);
            						}
HXLINE( 287)						first = (first - 1);
HXLINE( 288)						last = (last + 1);
            					}
            				}
            			}
HXLINE( 292)			if ((a != newDegree)) {
HXLINE( 293)				int _g = 0;
HXDLIN( 293)				int _g1 = (ph - oldr);
HXDLIN( 293)				while((_g < _g1)){
HXLINE( 293)					_g = (_g + 1);
HXDLIN( 293)					int i = (_g - 1);
HXLINE( 294)					Uh[kind] = ua;
HXLINE( 295)					kind = (kind + 1);
            				}
            			}
HXLINE( 299)			{
HXLINE( 299)				int _g2 = lbz;
HXDLIN( 299)				int _g3 = (rbz + 1);
HXDLIN( 299)				while((_g2 < _g3)){
HXLINE( 299)					_g2 = (_g2 + 1);
HXDLIN( 299)					int j = (_g2 - 1);
HXLINE( 300)					Qw[cind] = ebpts->__get(j).StaticCast< ::Array< Float > >();
HXLINE( 301)					cind = (cind + 1);
            				}
            			}
HXLINE( 304)			if ((b < m)) {
HXLINE( 305)				{
HXLINE( 305)					int _g = 0;
HXDLIN( 305)					int _g1 = r;
HXDLIN( 305)					while((_g < _g1)){
HXLINE( 305)						_g = (_g + 1);
HXDLIN( 305)						int j = (_g - 1);
HXLINE( 306)						bpts[j] = Nextbpts->__get(j).StaticCast< ::Array< Float > >();
            					}
            				}
HXLINE( 308)				{
HXLINE( 308)					int _g2 = r;
HXDLIN( 308)					int _g3 = (newDegree + 1);
HXDLIN( 308)					while((_g2 < _g3)){
HXLINE( 308)						_g2 = (_g2 + 1);
HXDLIN( 308)						int j = (_g2 - 1);
HXLINE( 309)						bpts[j] = controlPoints->__get(((b - newDegree) + j)).StaticCast< ::Array< Float > >();
            					}
            				}
HXLINE( 311)				a = b;
HXLINE( 312)				b = (b + 1);
HXLINE( 313)				ua = ub;
            			}
            			else {
HXLINE( 316)				int _g = 0;
HXDLIN( 316)				int _g1 = (ph + 1);
HXDLIN( 316)				while((_g < _g1)){
HXLINE( 316)					_g = (_g + 1);
HXDLIN( 316)					int i = (_g - 1);
HXLINE( 317)					Uh[(kind + i)] = ub;
            				}
            			}
            		}
HXLINE( 188)		int nh = ((mh - ph) - 1);
HXLINE( 323)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,finalDegree,Uh,Qw);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,curveElevateDegree,return )

 ::verb::core::NurbsSurfaceData Modify_obj::rationalSurfaceTransform( ::verb::core::NurbsSurfaceData surface,::Array< ::Dynamic> mat){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_337_rationalSurfaceTransform)
HXLINE( 339)		::Array< ::Dynamic> pts = ::verb::eval::Eval_obj::dehomogenize2d(surface->controlPoints);
HXLINE( 341)		{
HXLINE( 341)			int _g = 0;
HXDLIN( 341)			int _g1 = pts->length;
HXDLIN( 341)			while((_g < _g1)){
HXLINE( 341)				_g = (_g + 1);
HXDLIN( 341)				int i = (_g - 1);
HXLINE( 342)				{
HXLINE( 342)					int _g1 = 0;
HXDLIN( 342)					int _g2 = pts->__get(i).StaticCast< ::Array< ::Dynamic> >()->length;
HXDLIN( 342)					while((_g1 < _g2)){
HXLINE( 342)						_g1 = (_g1 + 1);
HXDLIN( 342)						int j = (_g1 - 1);
HXLINE( 343)						::Array< Float > homoPt = pts->__get(i).StaticCast< ::Array< ::Dynamic> >()->__get(j).StaticCast< ::Array< Float > >();
HXLINE( 344)						homoPt->push(((Float)1.0));
HXLINE( 346)						::Array< ::Dynamic> pts1 = pts->__get(i).StaticCast< ::Array< ::Dynamic> >();
HXDLIN( 346)						::Array< Float > _hx_tmp = ::verb::core::Mat_obj::dot(mat,homoPt);
HXDLIN( 346)						pts1[j] = _hx_tmp->slice(0,(homoPt->length - 1));
            					}
            				}
            			}
            		}
HXLINE( 350)		int surface1 = surface->degreeU;
HXDLIN( 350)		int surface2 = surface->degreeV;
HXDLIN( 350)		::Array< Float > _hx_tmp = surface->knotsU->copy();
HXDLIN( 350)		::Array< Float > _hx_tmp1 = surface->knotsV->copy();
HXDLIN( 350)		return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,surface2,_hx_tmp,_hx_tmp1,::verb::eval::Eval_obj::homogenize2d(pts,::verb::eval::Eval_obj::weight2d(surface->controlPoints)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,rationalSurfaceTransform,return )

 ::verb::core::NurbsCurveData Modify_obj::rationalCurveTransform( ::verb::core::NurbsCurveData curve,::Array< ::Dynamic> mat){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_364_rationalCurveTransform)
HXLINE( 366)		::Array< ::Dynamic> pts = ::verb::eval::Eval_obj::dehomogenize1d(curve->controlPoints);
HXLINE( 368)		{
HXLINE( 368)			int _g = 0;
HXDLIN( 368)			int _g1 = pts->length;
HXDLIN( 368)			while((_g < _g1)){
HXLINE( 368)				_g = (_g + 1);
HXDLIN( 368)				int i = (_g - 1);
HXLINE( 370)				::Array< Float > homoPt = pts->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 371)				homoPt->push(((Float)1.0));
HXLINE( 373)				::Array< Float > _hx_tmp = ::verb::core::Mat_obj::dot(mat,homoPt);
HXDLIN( 373)				pts[i] = _hx_tmp->slice(0,(homoPt->length - 1));
            			}
            		}
HXLINE( 376)		int curve1 = curve->degree;
HXDLIN( 376)		::Array< Float > _hx_tmp = curve->knots->copy();
HXDLIN( 376)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,curve1,_hx_tmp,::verb::eval::Eval_obj::homogenize1d(pts,::verb::eval::Eval_obj::weight1d(curve->controlPoints)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,rationalCurveTransform,return )

 ::verb::core::NurbsSurfaceData Modify_obj::surfaceKnotRefine( ::verb::core::NurbsSurfaceData surface,::Array< Float > knotsToInsert,bool useV){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_392_surfaceKnotRefine)
HXLINE( 397)		::Array< ::Dynamic> newPts = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 397)		::Array< Float > knots;
HXDLIN( 397)		int degree;
HXDLIN( 397)		::Array< ::Dynamic> ctrlPts;
HXLINE( 403)		if (!(useV)) {
HXLINE( 404)			ctrlPts = ::verb::core::Mat_obj::transposeN(surface->controlPoints);
HXLINE( 405)			knots = surface->knotsU;
HXLINE( 406)			degree = surface->degreeU;
            		}
            		else {
HXLINE( 409)			ctrlPts = surface->controlPoints;
HXLINE( 410)			knots = surface->knotsV;
HXLINE( 411)			degree = surface->degreeV;
            		}
HXLINE( 415)		 ::verb::core::NurbsCurveData c = null();
HXLINE( 416)		{
HXLINE( 416)			int _g = 0;
HXDLIN( 416)			while((_g < ctrlPts->length)){
HXLINE( 416)				::Array< ::Dynamic> cptrow = ctrlPts->__get(_g).StaticCast< ::Array< ::Dynamic> >();
HXDLIN( 416)				_g = (_g + 1);
HXLINE( 417)				c = ::verb::eval::Modify_obj::curveKnotRefine( ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots,cptrow),knotsToInsert);
HXLINE( 418)				newPts->push(c->controlPoints);
            			}
            		}
HXLINE( 421)		::Array< Float > newknots = c->knots;
HXLINE( 424)		if (!(useV)) {
HXLINE( 425)			newPts = ::verb::core::Mat_obj::transposeN(newPts);
HXLINE( 426)			int surface1 = surface->degreeU;
HXDLIN( 426)			int surface2 = surface->degreeV;
HXDLIN( 426)			return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,surface2,newknots,surface->knotsV->copy(),newPts);
            		}
            		else {
HXLINE( 429)			int surface1 = surface->degreeU;
HXDLIN( 429)			int surface2 = surface->degreeV;
HXDLIN( 429)			return  ::verb::core::NurbsSurfaceData_obj::__alloc( HX_CTX ,surface1,surface2,surface->knotsU->copy(),newknots,newPts);
            		}
HXLINE( 424)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Modify_obj,surfaceKnotRefine,return )

::Array< ::Dynamic> Modify_obj::decomposeCurveIntoBeziers( ::verb::core::NurbsCurveData curve){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_445_decomposeCurveIntoBeziers)
HXLINE( 447)		int degree = curve->degree;
HXDLIN( 447)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN( 447)		::Array< Float > knots = curve->knots;
HXLINE( 454)		::Array< ::Dynamic> knotmults = ::verb::eval::Analyze_obj::knotMultiplicities(knots);
HXLINE( 455)		int reqMult = (degree + 1);
HXLINE( 458)		{
HXLINE( 458)			int _g = 0;
HXDLIN( 458)			while((_g < knotmults->length)){
HXLINE( 458)				 ::verb::eval::KnotMultiplicity knotmult = knotmults->__get(_g).StaticCast<  ::verb::eval::KnotMultiplicity >();
HXDLIN( 458)				_g = (_g + 1);
HXLINE( 459)				if ((knotmult->mult < reqMult)) {
HXLINE( 461)					::Array< Float > knotsInsert = ::verb::core::Vec_obj::rep((reqMult - knotmult->mult),knotmult->knot);
HXLINE( 462)					 ::verb::core::NurbsCurveData res = ::verb::eval::Modify_obj::curveKnotRefine( ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots,controlPoints),knotsInsert);
HXLINE( 464)					knots = res->knots;
HXLINE( 465)					controlPoints = res->controlPoints;
            				}
            			}
            		}
HXLINE( 469)		Float numCrvs = ((( (Float)(knots->length) ) / ( (Float)(reqMult) )) - ( (Float)(1) ));
HXLINE( 470)		int crvKnotLength = (reqMult * 2);
HXLINE( 472)		::Array< ::Dynamic> crvs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 474)		int i = 0;
HXLINE( 475)		while((i < controlPoints->length)){
HXLINE( 476)			::Array< Float > kts = knots->slice(i,(i + crvKnotLength));
HXLINE( 477)			::Array< ::Dynamic> pts = controlPoints->slice(i,(i + reqMult));
HXLINE( 479)			crvs->push( ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,kts,pts));
HXLINE( 481)			i = (i + reqMult);
            		}
HXLINE( 484)		return crvs;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Modify_obj,decomposeCurveIntoBeziers,return )

 ::verb::core::NurbsCurveData Modify_obj::curveKnotRefine( ::verb::core::NurbsCurveData curve,::Array< Float > knotsToInsert){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_502_curveKnotRefine)
HXLINE( 504)		if ((knotsToInsert->length == 0)) {
HXLINE( 504)			return ::verb::eval::Make_obj::clonedCurve(curve);
            		}
HXLINE( 506)		int degree = curve->degree;
HXDLIN( 506)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN( 506)		::Array< Float > knots = curve->knots;
HXLINE( 510)		int n = (controlPoints->length - 1);
HXDLIN( 510)		int m = ((n + degree) + 1);
HXDLIN( 510)		int r = (knotsToInsert->length - 1);
HXDLIN( 510)		int a = ::verb::eval::Eval_obj::knotSpan(degree,knotsToInsert->__get(0),knots);
HXDLIN( 510)		int b = ::verb::eval::Eval_obj::knotSpan(degree,knotsToInsert->__get(r),knots);
HXDLIN( 510)		::Array< ::Dynamic> controlPoints_post = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 510)		::Array< Float > knots_post = ::Array_obj< Float >::__new();
HXLINE( 519)		{
HXLINE( 519)			int _g = 0;
HXDLIN( 519)			int _g1 = ((a - degree) + 1);
HXDLIN( 519)			while((_g < _g1)){
HXLINE( 519)				_g = (_g + 1);
HXDLIN( 519)				int i = (_g - 1);
HXLINE( 520)				controlPoints_post[i] = controlPoints->__get(i).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 523)		{
HXLINE( 523)			int _g2 = (b - 1);
HXDLIN( 523)			int _g3 = (n + 1);
HXDLIN( 523)			while((_g2 < _g3)){
HXLINE( 523)				_g2 = (_g2 + 1);
HXDLIN( 523)				int i = (_g2 - 1);
HXLINE( 524)				controlPoints_post[((i + r) + 1)] = controlPoints->__get(i).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 528)		{
HXLINE( 528)			int _g4 = 0;
HXDLIN( 528)			int _g5 = (a + 1);
HXDLIN( 528)			while((_g4 < _g5)){
HXLINE( 528)				_g4 = (_g4 + 1);
HXDLIN( 528)				int i = (_g4 - 1);
HXLINE( 529)				knots_post[i] = knots->__get(i);
            			}
            		}
HXLINE( 532)		{
HXLINE( 532)			int _g6 = (b + degree);
HXDLIN( 532)			int _g7 = (m + 1);
HXDLIN( 532)			while((_g6 < _g7)){
HXLINE( 532)				_g6 = (_g6 + 1);
HXDLIN( 532)				int i = (_g6 - 1);
HXLINE( 533)				knots_post[((i + r) + 1)] = knots->__get(i);
            			}
            		}
HXLINE( 536)		int i = ((b + degree) - 1);
HXLINE( 537)		int k = ((b + degree) + r);
HXLINE( 538)		int j = r;
HXLINE( 540)		while((j >= 0)){
HXLINE( 542)			while(true){
HXLINE( 542)				bool _hx_tmp;
HXDLIN( 542)				if ((knotsToInsert->__get(j) <= knots->__get(i))) {
HXLINE( 542)					_hx_tmp = (i > a);
            				}
            				else {
HXLINE( 542)					_hx_tmp = false;
            				}
HXDLIN( 542)				if (!(_hx_tmp)) {
HXLINE( 542)					goto _hx_goto_56;
            				}
HXLINE( 543)				controlPoints_post[((k - degree) - 1)] = controlPoints->__get(((i - degree) - 1)).StaticCast< ::Array< Float > >();
HXLINE( 544)				knots_post[k] = knots->__get(i);
HXLINE( 545)				k = (k - 1);
HXLINE( 546)				i = (i - 1);
            			}
            			_hx_goto_56:;
HXLINE( 549)			controlPoints_post[((k - degree) - 1)] = controlPoints_post->__get((k - degree)).StaticCast< ::Array< Float > >();
HXLINE( 551)			{
HXLINE( 551)				int _g = 1;
HXDLIN( 551)				int _g1 = (degree + 1);
HXDLIN( 551)				while((_g < _g1)){
HXLINE( 551)					_g = (_g + 1);
HXDLIN( 551)					int l = (_g - 1);
HXLINE( 553)					int ind = ((k - degree) + l);
HXLINE( 554)					Float alfa = (knots_post->__get((k + l)) - knotsToInsert->__get(j));
HXLINE( 556)					if ((::Math_obj::abs(alfa) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 557)						controlPoints_post[(ind - 1)] = controlPoints_post->__get(ind).StaticCast< ::Array< Float > >();
            					}
            					else {
HXLINE( 559)						alfa = (alfa / (knots_post->__get((k + l)) - knots->__get(((i - degree) + l))));
HXLINE( 562)						::Array< Float > _hx_tmp = ::verb::core::Vec_obj::mul(alfa,controlPoints_post->__get((ind - 1)).StaticCast< ::Array< Float > >());
HXLINE( 561)						controlPoints_post[(ind - 1)] = ::verb::core::Vec_obj::add(_hx_tmp,::verb::core::Vec_obj::mul((((Float)1.0) - alfa),controlPoints_post->__get(ind).StaticCast< ::Array< Float > >()));
            					}
            				}
            			}
HXLINE( 568)			knots_post[k] = knotsToInsert->__get(j);
HXLINE( 569)			k = (k - 1);
HXLINE( 571)			j = (j - 1);
            		}
HXLINE( 575)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots_post,controlPoints_post);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Modify_obj,curveKnotRefine,return )

 ::verb::core::NurbsCurveData Modify_obj::curveKnotInsert( ::verb::core::NurbsCurveData curve,Float u,int r){
            	HX_GC_STACKFRAME(&_hx_pos_5ffdee8f27f0ca91_598_curveKnotInsert)
HXLINE( 600)		int degree = curve->degree;
HXDLIN( 600)		::Array< ::Dynamic> controlPoints = curve->controlPoints;
HXDLIN( 600)		::Array< Float > knots = curve->knots;
HXLINE( 610)		int s = 0;
HXLINE( 612)		int num_pts = controlPoints->length;
HXDLIN( 612)		int k = ::verb::eval::Eval_obj::knotSpan(degree,u,knots);
HXDLIN( 612)		int num_pts_post = (num_pts + r);
HXDLIN( 612)		::Array< ::Dynamic> controlPoints_temp = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 612)		::Array< Float > knots_post = ::Array_obj< Float >::__new();
HXDLIN( 612)		::Array< ::Dynamic> controlPoints_post = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 612)		int i = 0;
HXLINE( 623)		{
HXLINE( 623)			int _g = 1;
HXDLIN( 623)			int _g1 = (k + 1);
HXDLIN( 623)			while((_g < _g1)){
HXLINE( 623)				_g = (_g + 1);
HXDLIN( 623)				int i = (_g - 1);
HXLINE( 624)				knots_post[i] = knots->__get(i);
            			}
            		}
HXLINE( 628)		{
HXLINE( 628)			int _g2 = 1;
HXDLIN( 628)			int _g3 = (r + 1);
HXDLIN( 628)			while((_g2 < _g3)){
HXLINE( 628)				_g2 = (_g2 + 1);
HXDLIN( 628)				int i = (_g2 - 1);
HXLINE( 629)				knots_post[(k + i)] = u;
            			}
            		}
HXLINE( 633)		{
HXLINE( 633)			int _g4 = (k + 1);
HXDLIN( 633)			int _g5 = knots->length;
HXDLIN( 633)			while((_g4 < _g5)){
HXLINE( 633)				_g4 = (_g4 + 1);
HXDLIN( 633)				int i = (_g4 - 1);
HXLINE( 634)				knots_post[(i + r)] = knots->__get(i);
            			}
            		}
HXLINE( 640)		{
HXLINE( 640)			int _g6 = 0;
HXDLIN( 640)			int _g7 = ((k - degree) + 1);
HXDLIN( 640)			while((_g6 < _g7)){
HXLINE( 640)				_g6 = (_g6 + 1);
HXDLIN( 640)				int i = (_g6 - 1);
HXLINE( 641)				controlPoints_post[i] = controlPoints->__get(i).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 645)		{
HXLINE( 645)			int _g8 = (k - s);
HXDLIN( 645)			int _g9 = num_pts;
HXDLIN( 645)			while((_g8 < _g9)){
HXLINE( 645)				_g8 = (_g8 + 1);
HXDLIN( 645)				int i = (_g8 - 1);
HXLINE( 646)				controlPoints_post[(i + r)] = controlPoints->__get(i).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 650)		{
HXLINE( 650)			int _g10 = 0;
HXDLIN( 650)			int _g11 = ((degree - s) + 1);
HXDLIN( 650)			while((_g10 < _g11)){
HXLINE( 650)				_g10 = (_g10 + 1);
HXDLIN( 650)				int i = (_g10 - 1);
HXLINE( 651)				controlPoints_temp[i] = controlPoints->__get(((k - degree) + i)).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 654)		int L = 0;
HXDLIN( 654)		Float alpha = ( (Float)(0) );
HXLINE( 658)		{
HXLINE( 658)			int _g12 = 1;
HXDLIN( 658)			int _g13 = (r + 1);
HXDLIN( 658)			while((_g12 < _g13)){
HXLINE( 658)				_g12 = (_g12 + 1);
HXDLIN( 658)				int j = (_g12 - 1);
HXLINE( 660)				L = ((k - degree) + j);
HXLINE( 662)				{
HXLINE( 662)					int _g = 0;
HXDLIN( 662)					int _g1 = (((degree - j) - s) + 1);
HXDLIN( 662)					while((_g < _g1)){
HXLINE( 662)						_g = (_g + 1);
HXDLIN( 662)						int i = (_g - 1);
HXLINE( 664)						alpha = ((u - knots->__get((L + i))) / (knots->__get(((i + k) + 1)) - knots->__get((L + i))));
HXLINE( 667)						::Array< Float > _hx_tmp = ::verb::core::Vec_obj::mul(alpha,controlPoints_temp->__get((i + 1)).StaticCast< ::Array< Float > >());
HXLINE( 666)						controlPoints_temp[i] = ::verb::core::Vec_obj::add(_hx_tmp,::verb::core::Vec_obj::mul((((Float)1.0) - alpha),controlPoints_temp->__get(i).StaticCast< ::Array< Float > >()));
            					}
            				}
HXLINE( 672)				controlPoints_post[L] = controlPoints_temp->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 673)				controlPoints_post[(((k + r) - j) - s)] = controlPoints_temp->__get(((degree - j) - s)).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 678)		{
HXLINE( 678)			int _g14 = (L + 1);
HXDLIN( 678)			int _g15 = (k - s);
HXDLIN( 678)			while((_g14 < _g15)){
HXLINE( 678)				_g14 = (_g14 + 1);
HXDLIN( 678)				int i = (_g14 - 1);
HXLINE( 679)				controlPoints_post[i] = controlPoints_temp->__get((i - L)).StaticCast< ::Array< Float > >();
            			}
            		}
HXLINE( 682)		return  ::verb::core::NurbsCurveData_obj::__alloc( HX_CTX ,degree,knots_post,controlPoints_post);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Modify_obj,curveKnotInsert,return )


Modify_obj::Modify_obj()
{
}

bool Modify_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"imin") ) { outValue = imin_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imax") ) { outValue = imax_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"curveReverse") ) { outValue = curveReverse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"knotsReverse") ) { outValue = knotsReverse_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"surfaceReverse") ) { outValue = surfaceReverse_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curveKnotRefine") ) { outValue = curveKnotRefine_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curveKnotInsert") ) { outValue = curveKnotInsert_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"surfaceKnotRefine") ) { outValue = surfaceKnotRefine_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"curveElevateDegree") ) { outValue = curveElevateDegree_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"unifyCurveKnotVectors") ) { outValue = unifyCurveKnotVectors_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"rationalCurveTransform") ) { outValue = rationalCurveTransform_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"rationalSurfaceTransform") ) { outValue = rationalSurfaceTransform_dyn(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"decomposeCurveIntoBeziers") ) { outValue = decomposeCurveIntoBeziers_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Modify_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Modify_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Modify_obj::__mClass;

static ::String Modify_obj_sStaticFields[] = {
	HX_("curveReverse",33,98,52,a8),
	HX_("surfaceReverse",75,ca,7a,dd),
	HX_("knotsReverse",77,1a,39,6a),
	HX_("unifyCurveKnotVectors",9c,a0,aa,69),
	HX_("imin",c9,78,ba,45),
	HX_("imax",db,71,ba,45),
	HX_("curveElevateDegree",37,23,11,04),
	HX_("rationalSurfaceTransform",4d,a2,ee,0c),
	HX_("rationalCurveTransform",0b,6c,28,8d),
	HX_("surfaceKnotRefine",a2,45,fb,4a),
	HX_("decomposeCurveIntoBeziers",16,60,16,1e),
	HX_("curveKnotRefine",a4,22,d8,9e),
	HX_("curveKnotInsert",70,dc,d1,3c),
	::String(null())
};

void Modify_obj::__register()
{
	Modify_obj _hx_dummy;
	Modify_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Modify",dd,38,cc,c3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Modify_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Modify_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Modify_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Modify_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Modify_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
