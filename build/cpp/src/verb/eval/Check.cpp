// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_eval_Check
#include <verb/eval/Check.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_c7d32fdec6fa54b2_36_isValidKnotVector,"verb.eval.Check","isValidKnotVector",0xbaee6ad4,"verb.eval.Check.isValidKnotVector","verb/eval/Check.hx",36,0xa58b5679)
HX_LOCAL_STACK_FRAME(_hx_pos_c7d32fdec6fa54b2_67_isNonDecreasing,"verb.eval.Check","isNonDecreasing",0x15ceb995,"verb.eval.Check.isNonDecreasing","verb/eval/Check.hx",67,0xa58b5679)
HX_LOCAL_STACK_FRAME(_hx_pos_c7d32fdec6fa54b2_86_isValidNurbsCurveData,"verb.eval.Check","isValidNurbsCurveData",0x2e8bc4e6,"verb.eval.Check.isValidNurbsCurveData","verb/eval/Check.hx",86,0xa58b5679)
HX_LOCAL_STACK_FRAME(_hx_pos_c7d32fdec6fa54b2_115_isValidNurbsSurfaceData,"verb.eval.Check","isValidNurbsSurfaceData",0x240daaa4,"verb.eval.Check.isValidNurbsSurfaceData","verb/eval/Check.hx",115,0xa58b5679)
namespace verb{
namespace eval{

void Check_obj::__construct() { }

Dynamic Check_obj::__CreateEmpty() { return new Check_obj; }

void *Check_obj::_hx_vtable = 0;

Dynamic Check_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Check_obj > _hx_result = new Check_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Check_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7ffcbb51;
}

bool Check_obj::isValidKnotVector(::Array< Float > vec,int degree){
            	HX_STACKFRAME(&_hx_pos_c7d32fdec6fa54b2_36_isValidKnotVector)
HXLINE(  38)		if ((vec->length == 0)) {
HXLINE(  38)			return false;
            		}
HXLINE(  39)		if ((vec->length < ((degree + 1) * 2))) {
HXLINE(  39)			return false;
            		}
HXLINE(  41)		Float rep = ( (Float)(::verb::core::ArrayExtensions_obj::first(vec)) );
HXLINE(  43)		{
HXLINE(  43)			int _g = 0;
HXDLIN(  43)			int _g1 = (degree + 1);
HXDLIN(  43)			while((_g < _g1)){
HXLINE(  43)				_g = (_g + 1);
HXDLIN(  43)				int i = (_g - 1);
HXLINE(  44)				if ((::Math_obj::abs((vec->__get(i) - rep)) > ::verb::core::Constants_obj::EPSILON)) {
HXLINE(  44)					return false;
            				}
            			}
            		}
HXLINE(  47)		rep = ( (Float)(::verb::core::ArrayExtensions_obj::last(vec)) );
HXLINE(  49)		{
HXLINE(  49)			int _g2 = ((vec->length - degree) - 1);
HXDLIN(  49)			int _g3 = vec->length;
HXDLIN(  49)			while((_g2 < _g3)){
HXLINE(  49)				_g2 = (_g2 + 1);
HXDLIN(  49)				int i = (_g2 - 1);
HXLINE(  50)				if ((::Math_obj::abs((vec->__get(i) - rep)) > ::verb::core::Constants_obj::EPSILON)) {
HXLINE(  50)					return false;
            				}
            			}
            		}
HXLINE(  53)		return ::verb::eval::Check_obj::isNonDecreasing(vec);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Check_obj,isValidKnotVector,return )

bool Check_obj::isNonDecreasing(::Array< Float > vec){
            	HX_STACKFRAME(&_hx_pos_c7d32fdec6fa54b2_67_isNonDecreasing)
HXLINE(  68)		Float rep = ( (Float)(::verb::core::ArrayExtensions_obj::first(vec)) );
HXLINE(  69)		{
HXLINE(  69)			int _g = 0;
HXDLIN(  69)			int _g1 = vec->length;
HXDLIN(  69)			while((_g < _g1)){
HXLINE(  69)				_g = (_g + 1);
HXDLIN(  69)				int i = (_g - 1);
HXLINE(  70)				if ((vec->__get(i) < (rep - ::verb::core::Constants_obj::EPSILON))) {
HXLINE(  70)					return false;
            				}
HXLINE(  71)				rep = vec->__get(i);
            			}
            		}
HXLINE(  73)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Check_obj,isNonDecreasing,return )

 ::verb::core::NurbsCurveData Check_obj::isValidNurbsCurveData( ::verb::core::NurbsCurveData data){
            	HX_STACKFRAME(&_hx_pos_c7d32fdec6fa54b2_86_isValidNurbsCurveData)
HXLINE(  87)		if (::hx::IsNull( data->controlPoints )) {
HXLINE(  87)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Control points array cannot be null!",d9,fa,31,68)));
            		}
HXLINE(  91)		if ((data->degree < 1)) {
HXLINE(  91)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Degree must be greater than 1!",af,d3,51,bf)));
            		}
HXLINE(  92)		if (::hx::IsNull( data->knots )) {
HXLINE(  92)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Knots cannot be null!",05,ca,b3,82)));
            		}
HXLINE(  94)		if ((data->knots->length != ((data->controlPoints->length + data->degree) + 1))) {
HXLINE(  95)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("controlPoints.length + degree + 1 must equal knots.length!",8c,e1,17,1c)));
            		}
HXLINE(  98)		if (!(::verb::eval::Check_obj::isValidKnotVector(data->knots,data->degree))) {
HXLINE(  99)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!",63,51,79,93)));
            		}
HXLINE( 102)		return data;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Check_obj,isValidNurbsCurveData,return )

 ::verb::core::NurbsSurfaceData Check_obj::isValidNurbsSurfaceData( ::verb::core::NurbsSurfaceData data){
            	HX_STACKFRAME(&_hx_pos_c7d32fdec6fa54b2_115_isValidNurbsSurfaceData)
HXLINE( 116)		if (::hx::IsNull( data->controlPoints )) {
HXLINE( 116)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Control points array cannot be null!",d9,fa,31,68)));
            		}
HXLINE( 121)		if ((data->degreeU < 1)) {
HXLINE( 121)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("DegreeU must be greater than 1!",ac,3a,47,ee)));
            		}
HXLINE( 122)		if ((data->degreeV < 1)) {
HXLINE( 122)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("DegreeV must be greater than 1!",ad,75,4e,f7)));
            		}
HXLINE( 123)		if (::hx::IsNull( data->knotsU )) {
HXLINE( 123)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("KnotsU cannot be null!",64,16,c2,64)));
            		}
HXLINE( 124)		if (::hx::IsNull( data->knotsV )) {
HXLINE( 124)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("KnotsV cannot be null!",65,e8,b5,e7)));
            		}
HXLINE( 126)		if ((data->knotsU->length != ((data->controlPoints->length + data->degreeU) + 1))) {
HXLINE( 127)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("controlPointsU.length + degreeU + 1 must equal knotsU.length!",e9,7f,f0,79)));
            		}
HXLINE( 130)		if ((data->knotsV->length != ((data->controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length + data->degreeV) + 1))) {
HXLINE( 131)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("controlPointsV.length + degreeV + 1 must equal knotsV.length!",ca,df,d9,dc)));
            		}
HXLINE( 134)		bool _hx_tmp;
HXDLIN( 134)		if (::verb::eval::Check_obj::isValidKnotVector(data->knotsU,data->degreeU)) {
HXLINE( 134)			_hx_tmp = !(::verb::eval::Check_obj::isValidKnotVector(data->knotsV,data->degreeV));
            		}
            		else {
HXLINE( 134)			_hx_tmp = true;
            		}
HXDLIN( 134)		if (_hx_tmp) {
HXLINE( 135)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Invalid knot vector format!  Should begin with degree + 1 repeats and end with degree + 1 repeats!",63,51,79,93)));
            		}
HXLINE( 138)		return data;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Check_obj,isValidNurbsSurfaceData,return )


Check_obj::Check_obj()
{
}

bool Check_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"isNonDecreasing") ) { outValue = isNonDecreasing_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"isValidKnotVector") ) { outValue = isValidKnotVector_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"isValidNurbsCurveData") ) { outValue = isValidNurbsCurveData_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"isValidNurbsSurfaceData") ) { outValue = isValidNurbsSurfaceData_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Check_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Check_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Check_obj::__mClass;

static ::String Check_obj_sStaticFields[] = {
	HX_("isValidKnotVector",bd,57,8a,26),
	HX_("isNonDecreasing",3e,6a,9e,29),
	HX_("isValidNurbsCurveData",4f,da,ea,bc),
	HX_("isValidNurbsSurfaceData",4d,ac,6b,58),
	::String(null())
};

void Check_obj::__register()
{
	Check_obj _hx_dummy;
	Check_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Check",c5,51,76,6a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Check_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Check_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Check_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Check_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Check_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
