// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_MeshData
#include <verb/core/MeshData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_SurfacePoint
#include <verb/core/SurfacePoint.h>
#endif
#ifndef INCLUDED_verb_core_Trig
#include <verb/core/Trig.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_AdaptiveRefinementNode
#include <verb/eval/AdaptiveRefinementNode.h>
#endif
#ifndef INCLUDED_verb_eval_AdaptiveRefinementOptions
#include <verb/eval/AdaptiveRefinementOptions.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif
#ifndef INCLUDED_verb_eval_Tess
#include <verb/eval/Tess.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_36_rationalCurveRegularSample,"verb.eval.Tess","rationalCurveRegularSample",0x246945ff,"verb.eval.Tess.rationalCurveRegularSample","verb/eval/Tess.hx",36,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_54_rationalCurveRegularSampleRange,"verb.eval.Tess","rationalCurveRegularSampleRange",0x4b2ab33e,"verb.eval.Tess.rationalCurveRegularSampleRange","verb/eval/Tess.hx",54,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_93_rationalCurveAdaptiveSample,"verb.eval.Tess","rationalCurveAdaptiveSample",0x5d00d9c7,"verb.eval.Tess.rationalCurveAdaptiveSample","verb/eval/Tess.hx",93,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_122_rationalCurveAdaptiveSampleRange,"verb.eval.Tess","rationalCurveAdaptiveSampleRange",0xfc9e6a76,"verb.eval.Tess.rationalCurveAdaptiveSampleRange","verb/eval/Tess.hx",122,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_169_rationalSurfaceNaive,"verb.eval.Tess","rationalSurfaceNaive",0x7609f6a0,"verb.eval.Tess.rationalSurfaceNaive","verb/eval/Tess.hx",169,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_239_divideRationalSurfaceAdaptive,"verb.eval.Tess","divideRationalSurfaceAdaptive",0x57e45f42,"verb.eval.Tess.divideRationalSurfaceAdaptive","verb/eval/Tess.hx",239,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_316_north,"verb.eval.Tess","north",0xd88deacb,"verb.eval.Tess.north","verb/eval/Tess.hx",316,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_321_south,"verb.eval.Tess","south",0xb9911813,"verb.eval.Tess.south","verb/eval/Tess.hx",321,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_326_east,"verb.eval.Tess","east",0xe65128b7,"verb.eval.Tess.east","verb/eval/Tess.hx",326,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_331_west,"verb.eval.Tess","west",0xf23a08e9,"verb.eval.Tess.west","verb/eval/Tess.hx",331,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_336_triangulateAdaptiveRefinementNodeTree,"verb.eval.Tess","triangulateAdaptiveRefinementNodeTree",0x2c0c3693,"verb.eval.Tess.triangulateAdaptiveRefinementNodeTree","verb/eval/Tess.hx",336,0xdad164ea)
HX_LOCAL_STACK_FRAME(_hx_pos_66172106d7dfb866_345_rationalSurfaceAdaptive,"verb.eval.Tess","rationalSurfaceAdaptive",0x31fe6f3b,"verb.eval.Tess.rationalSurfaceAdaptive","verb/eval/Tess.hx",345,0xdad164ea)
namespace verb{
namespace eval{

void Tess_obj::__construct() { }

Dynamic Tess_obj::__CreateEmpty() { return new Tess_obj; }

void *Tess_obj::_hx_vtable = 0;

Dynamic Tess_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Tess_obj > _hx_result = new Tess_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Tess_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x07938c6c;
}

::Array< ::Dynamic> Tess_obj::rationalCurveRegularSample( ::verb::core::NurbsCurveData curve,int numSamples,bool includeU){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_36_rationalCurveRegularSample)
HXDLIN(  36)		Float curve1 = curve->knots->__get(0);
HXDLIN(  36)		return ::verb::eval::Tess_obj::rationalCurveRegularSampleRange(curve,curve1,( (Float)(::verb::core::ArrayExtensions_obj::last(curve->knots)) ),numSamples,includeU);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Tess_obj,rationalCurveRegularSample,return )

::Array< ::Dynamic> Tess_obj::rationalCurveRegularSampleRange( ::verb::core::NurbsCurveData curve,Float start,Float end,int numSamples,bool includeU){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_54_rationalCurveRegularSampleRange)
HXLINE(  56)		if ((numSamples < 1)) {
HXLINE(  57)			numSamples = 2;
            		}
HXLINE(  60)		::Array< ::Dynamic> p = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  61)		Float span = ((end - start) / ( (Float)((numSamples - 1)) ));
HXLINE(  62)		Float u = ( (Float)(0) );
HXLINE(  64)		{
HXLINE(  64)			int _g = 0;
HXDLIN(  64)			int _g1 = numSamples;
HXDLIN(  64)			while((_g < _g1)){
HXLINE(  64)				_g = (_g + 1);
HXDLIN(  64)				int i = (_g - 1);
HXLINE(  66)				u = (start + (span * ( (Float)(i) )));
HXLINE(  68)				if (includeU) {
HXLINE(  69)					::Array< Float > uVec = ::Array_obj< Float >::__new(1)->init(0,u);
HXLINE(  70)					p->push(uVec->concat(::verb::eval::Eval_obj::rationalCurvePoint(curve,u)));
            				}
            				else {
HXLINE(  72)					p->push(::verb::eval::Eval_obj::rationalCurvePoint(curve,u));
            				}
            			}
            		}
HXLINE(  77)		return p;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Tess_obj,rationalCurveRegularSampleRange,return )

::Array< ::Dynamic> Tess_obj::rationalCurveAdaptiveSample( ::verb::core::NurbsCurveData curve,::hx::Null< Float >  __o_tol,::hx::Null< bool >  __o_includeU){
            		Float tol = __o_tol.Default(((Float)1e-6));
            		bool includeU = __o_includeU.Default(false);
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_93_rationalCurveAdaptiveSample)
HXLINE(  96)		if ((curve->degree == 1)) {
HXLINE(  97)			if (!(includeU)) {
HXLINE(  98)				::Array< ::Dynamic> _this = curve->controlPoints;
HXDLIN(  98)				 ::Dynamic f = ::verb::eval::Eval_obj::dehomogenize_dyn();
HXDLIN(  98)				::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(_this->length);
HXDLIN(  98)				{
HXLINE(  98)					int _g = 0;
HXDLIN(  98)					int _g1 = _this->length;
HXDLIN(  98)					while((_g < _g1)){
HXLINE(  98)						_g = (_g + 1);
HXDLIN(  98)						int i = (_g - 1);
HXDLIN(  98)						{
HXLINE(  98)							::Array< Float > inValue = ( (::Array< Float >)(f(_hx_array_unsafe_get(_this,i))) );
HXDLIN(  98)							result->__unsafe_set(i,inValue);
            						}
            					}
            				}
HXDLIN(  98)				return result;
            			}
            			else {
HXLINE( 101)				::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 101)				{
HXLINE( 101)					int _g1 = 0;
HXDLIN( 101)					int _g2 = curve->controlPoints->length;
HXDLIN( 101)					while((_g1 < _g2)){
HXLINE( 101)						_g1 = (_g1 + 1);
HXDLIN( 101)						int i = (_g1 - 1);
HXLINE( 102)						::Array< Float > _hx_tmp = ::Array_obj< Float >::__new(1)->init(0,curve->knots->__get((i + 1)));
HXDLIN( 102)						_g->push(_hx_tmp->concat(::verb::eval::Eval_obj::dehomogenize(curve->controlPoints->__get(i).StaticCast< ::Array< Float > >())));
            					}
            				}
HXLINE( 101)				return _g;
            			}
            		}
HXLINE( 106)		Float curve1 = curve->knots->__get(0);
HXDLIN( 106)		return ::verb::eval::Tess_obj::rationalCurveAdaptiveSampleRange(curve,curve1,( (Float)(::verb::core::ArrayExtensions_obj::last(curve->knots)) ),tol,includeU);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Tess_obj,rationalCurveAdaptiveSample,return )

::Array< ::Dynamic> Tess_obj::rationalCurveAdaptiveSampleRange( ::verb::core::NurbsCurveData curve,Float start,Float end,Float tol,bool includeU){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_122_rationalCurveAdaptiveSampleRange)
HXLINE( 125)		::Array< Float > p1 = ::verb::eval::Eval_obj::rationalCurvePoint(curve,start);
HXDLIN( 125)		::Array< Float > p3 = ::verb::eval::Eval_obj::rationalCurvePoint(curve,end);
HXDLIN( 125)		Float t = (((Float)0.5) + (((Float)0.2) * ::Math_obj::random()));
HXDLIN( 125)		Float mid = (start + ((end - start) * t));
HXDLIN( 125)		::Array< Float > p2 = ::verb::eval::Eval_obj::rationalCurvePoint(curve,mid);
HXLINE( 132)		::Array< Float > diff = ::verb::core::Vec_obj::sub(p1,p3);
HXLINE( 133)		::Array< Float > diff2 = ::verb::core::Vec_obj::sub(p1,p2);
HXLINE( 136)		bool _hx_tmp;
HXDLIN( 136)		bool _hx_tmp1;
HXDLIN( 136)		if ((::verb::core::Vec_obj::dot(diff,diff) < tol)) {
HXLINE( 136)			_hx_tmp1 = (::verb::core::Vec_obj::dot(diff2,diff2) > tol);
            		}
            		else {
HXLINE( 136)			_hx_tmp1 = false;
            		}
HXDLIN( 136)		if (!(_hx_tmp1)) {
HXLINE( 136)			_hx_tmp = !(::verb::core::Trig_obj::threePointsAreFlat(p1,p2,p3,tol));
            		}
            		else {
HXLINE( 136)			_hx_tmp = true;
            		}
HXDLIN( 136)		if (_hx_tmp) {
HXLINE( 139)			Float exact_mid = (start + ((end - start) * ((Float)0.5)));
HXLINE( 142)			::Array< ::Dynamic> left_pts = ::verb::eval::Tess_obj::rationalCurveAdaptiveSampleRange(curve,start,exact_mid,tol,includeU);
HXDLIN( 142)			::Array< ::Dynamic> right_pts = ::verb::eval::Tess_obj::rationalCurveAdaptiveSampleRange(curve,exact_mid,end,tol,includeU);
HXLINE( 146)			return left_pts->slice(0,-1)->concat(right_pts);
            		}
            		else {
HXLINE( 149)			if (includeU) {
HXLINE( 150)				::Array< Float > _hx_tmp = ::Array_obj< Float >::__new(1)->init(0,start)->concat(p1);
HXDLIN( 150)				return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1,::Array_obj< Float >::__new(1)->init(0,end)->concat(p3));
            			}
            			else {
HXLINE( 152)				return ::Array_obj< ::Dynamic>::__new(2)->init(0,p1)->init(1,p3);
            			}
            		}
HXLINE( 136)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Tess_obj,rationalCurveAdaptiveSampleRange,return )

 ::verb::core::MeshData Tess_obj::rationalSurfaceNaive( ::verb::core::NurbsSurfaceData surface,int divs_u,int divs_v){
            	HX_GC_STACKFRAME(&_hx_pos_66172106d7dfb866_169_rationalSurfaceNaive)
HXLINE( 171)		if ((divs_u < 1)) {
HXLINE( 171)			divs_u = 1;
            		}
HXLINE( 172)		if ((divs_v < 1)) {
HXLINE( 172)			divs_v = 1;
            		}
HXLINE( 174)		int degreeU = surface->degreeU;
HXDLIN( 174)		int degreeV = surface->degreeV;
HXDLIN( 174)		::Array< ::Dynamic> controlPoints = surface->controlPoints;
HXDLIN( 174)		::Array< Float > knotsU = surface->knotsU;
HXDLIN( 174)		::Array< Float > knotsV = surface->knotsV;
HXLINE( 180)		Float u_span = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsU)) );
HXDLIN( 180)		Float u_span1 = (u_span - knotsU->__get(0));
HXLINE( 181)		Float v_span = ( (Float)(::verb::core::ArrayExtensions_obj::last(knotsV)) );
HXDLIN( 181)		Float v_span1 = (v_span - knotsV->__get(0));
HXLINE( 183)		Float span_u = (u_span1 / ( (Float)(divs_u) ));
HXDLIN( 183)		Float span_v = (v_span1 / ( (Float)(divs_v) ));
HXLINE( 186)		::Array< ::Dynamic> points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 187)		::Array< ::Dynamic> uvs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 188)		::Array< ::Dynamic> normals = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 190)		{
HXLINE( 190)			int _g = 0;
HXDLIN( 190)			int _g1 = (divs_u + 1);
HXDLIN( 190)			while((_g < _g1)){
HXLINE( 190)				_g = (_g + 1);
HXDLIN( 190)				int i = (_g - 1);
HXLINE( 191)				{
HXLINE( 191)					int _g1 = 0;
HXDLIN( 191)					int _g2 = (divs_v + 1);
HXDLIN( 191)					while((_g1 < _g2)){
HXLINE( 191)						_g1 = (_g1 + 1);
HXDLIN( 191)						int j = (_g1 - 1);
HXLINE( 193)						Float pt_u = (( (Float)(i) ) * span_u);
HXDLIN( 193)						Float pt_v = (( (Float)(j) ) * span_v);
HXLINE( 196)						uvs->push(::Array_obj< Float >::__new(2)->init(0,pt_u)->init(1,pt_v));
HXLINE( 198)						::Array< ::Dynamic> derivs = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface,pt_u,pt_v,1);
HXLINE( 199)						::Array< Float > pt = derivs->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 201)						points->push(pt);
HXLINE( 203)						::Array< Float > normal = ::verb::core::Vec_obj::normalized(::verb::core::Vec_obj::cross(derivs->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >(),derivs->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >()));
HXLINE( 204)						normals->push(normal);
            					}
            				}
            			}
            		}
HXLINE( 208)		::Array< ::Dynamic> faces = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 210)		{
HXLINE( 210)			int _g2 = 0;
HXDLIN( 210)			int _g3 = divs_u;
HXDLIN( 210)			while((_g2 < _g3)){
HXLINE( 210)				_g2 = (_g2 + 1);
HXDLIN( 210)				int i = (_g2 - 1);
HXLINE( 211)				{
HXLINE( 211)					int _g = 0;
HXDLIN( 211)					int _g1 = divs_v;
HXDLIN( 211)					while((_g < _g1)){
HXLINE( 211)						_g = (_g + 1);
HXDLIN( 211)						int j = (_g - 1);
HXLINE( 212)						int a_i = ((i * (divs_v + 1)) + j);
HXDLIN( 212)						int b_i = (((i + 1) * (divs_v + 1)) + j);
HXDLIN( 212)						int c_i = (b_i + 1);
HXDLIN( 212)						int d_i = (a_i + 1);
HXDLIN( 212)						::Array< int > abc = ::Array_obj< int >::__new(3)->init(0,a_i)->init(1,b_i)->init(2,c_i);
HXDLIN( 212)						::Array< int > acd = ::Array_obj< int >::__new(3)->init(0,a_i)->init(1,c_i)->init(2,d_i);
HXLINE( 219)						faces->push(abc);
HXLINE( 220)						faces->push(acd);
            					}
            				}
            			}
            		}
HXLINE( 224)		return  ::verb::core::MeshData_obj::__alloc( HX_CTX ,faces,points,normals,uvs);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Tess_obj,rationalSurfaceNaive,return )

::Array< ::Dynamic> Tess_obj::divideRationalSurfaceAdaptive( ::verb::core::NurbsSurfaceData surface, ::verb::eval::AdaptiveRefinementOptions options){
            	HX_GC_STACKFRAME(&_hx_pos_66172106d7dfb866_239_divideRationalSurfaceAdaptive)
HXLINE( 241)		if (::hx::IsNull( options )) {
HXLINE( 241)			options =  ::verb::eval::AdaptiveRefinementOptions_obj::__alloc( HX_CTX );
            		}
HXLINE( 249)		int minU = ((surface->controlPoints->length - 1) * 2);
HXLINE( 250)		int minV = ((surface->controlPoints->__get(0).StaticCast< ::Array< ::Dynamic> >()->length - 1) * 2);
HXLINE( 252)		int divsU;
HXDLIN( 252)		if ((options->minDivsU > minU)) {
HXLINE( 252)			divsU = options->minDivsU;
            		}
            		else {
HXLINE( 252)			divsU = minU;
            		}
HXDLIN( 252)		int divsU1 = (options->minDivsU = divsU);
HXLINE( 253)		int divsV;
HXDLIN( 253)		if ((options->minDivsV > minV)) {
HXLINE( 253)			divsV = options->minDivsV;
            		}
            		else {
HXLINE( 253)			divsV = minV;
            		}
HXDLIN( 253)		int divsV1 = (options->minDivsV = divsV);
HXLINE( 256)		Float umax = ( (Float)(::verb::core::ArrayExtensions_obj::last(surface->knotsU)) );
HXLINE( 257)		Float umin = surface->knotsU->__get(0);
HXLINE( 258)		Float vmax = ( (Float)(::verb::core::ArrayExtensions_obj::last(surface->knotsV)) );
HXLINE( 259)		Float vmin = surface->knotsV->__get(0);
HXLINE( 261)		Float du = ((umax - umin) / ( (Float)(divsU1) ));
HXDLIN( 261)		Float dv = ((vmax - vmin) / ( (Float)(divsV1) ));
HXLINE( 264)		::Array< ::Dynamic> divs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 265)		::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 268)		{
HXLINE( 268)			int _g = 0;
HXDLIN( 268)			int _g1 = (divsV1 + 1);
HXDLIN( 268)			while((_g < _g1)){
HXLINE( 268)				_g = (_g + 1);
HXDLIN( 268)				int i = (_g - 1);
HXLINE( 269)				::Array< ::Dynamic> ptrow = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 270)				{
HXLINE( 270)					int _g1 = 0;
HXDLIN( 270)					int _g2 = (divsU1 + 1);
HXDLIN( 270)					while((_g1 < _g2)){
HXLINE( 270)						_g1 = (_g1 + 1);
HXDLIN( 270)						int j = (_g1 - 1);
HXLINE( 272)						Float u = (umin + (du * ( (Float)(j) )));
HXDLIN( 272)						Float v = (vmin + (dv * ( (Float)(i) )));
HXLINE( 276)						::Array< ::Dynamic> ds = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface,u,v,1);
HXLINE( 278)						::Array< Float > norm = ::verb::core::Vec_obj::normalized(::verb::core::Vec_obj::cross(ds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >(),ds->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >()));
HXLINE( 279)						::Array< Float > ds1 = ds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXDLIN( 279)						ptrow->push( ::verb::core::SurfacePoint_obj::__alloc( HX_CTX ,ds1,norm,::Array_obj< Float >::__new(2)->init(0,u)->init(1,v),-1,::verb::core::Vec_obj::isZero(norm)));
            					}
            				}
HXLINE( 281)				pts->push(ptrow);
            			}
            		}
HXLINE( 285)		{
HXLINE( 285)			int _g2 = 0;
HXDLIN( 285)			int _g3 = divsV1;
HXDLIN( 285)			while((_g2 < _g3)){
HXLINE( 285)				_g2 = (_g2 + 1);
HXDLIN( 285)				int i = (_g2 - 1);
HXLINE( 286)				{
HXLINE( 286)					int _g = 0;
HXDLIN( 286)					int _g1 = divsU1;
HXDLIN( 286)					while((_g < _g1)){
HXLINE( 286)						_g = (_g + 1);
HXDLIN( 286)						int j = (_g - 1);
HXLINE( 287)						::Array< ::Dynamic> corners = ::Array_obj< ::Dynamic>::__new(4)->init(0,pts->__get(((divsV1 - i) - 1)).StaticCast< ::Array< ::Dynamic> >()->__get(j).StaticCast<  ::verb::core::SurfacePoint >())->init(1,pts->__get(((divsV1 - i) - 1)).StaticCast< ::Array< ::Dynamic> >()->__get((j + 1)).StaticCast<  ::verb::core::SurfacePoint >())->init(2,pts->__get((divsV1 - i)).StaticCast< ::Array< ::Dynamic> >()->__get((j + 1)).StaticCast<  ::verb::core::SurfacePoint >())->init(3,pts->__get((divsV1 - i)).StaticCast< ::Array< ::Dynamic> >()->__get(j).StaticCast<  ::verb::core::SurfacePoint >());
HXLINE( 292)						divs->push( ::verb::eval::AdaptiveRefinementNode_obj::__alloc( HX_CTX ,surface,corners,null()));
            					}
            				}
            			}
            		}
HXLINE( 296)		if (!(options->refine)) {
HXLINE( 296)			return divs;
            		}
HXLINE( 299)		{
HXLINE( 299)			int _g4 = 0;
HXDLIN( 299)			int _g5 = divsV1;
HXDLIN( 299)			while((_g4 < _g5)){
HXLINE( 299)				_g4 = (_g4 + 1);
HXDLIN( 299)				int i = (_g4 - 1);
HXLINE( 300)				{
HXLINE( 300)					int _g = 0;
HXDLIN( 300)					int _g1 = divsU1;
HXDLIN( 300)					while((_g < _g1)){
HXLINE( 300)						_g = (_g + 1);
HXDLIN( 300)						int j = (_g - 1);
HXLINE( 302)						int ci = ((i * divsU1) + j);
HXDLIN( 302)						 ::verb::eval::AdaptiveRefinementNode n = ::verb::eval::Tess_obj::north(ci,i,j,divsU1,divsV1,divs);
HXDLIN( 302)						 ::verb::eval::AdaptiveRefinementNode e = ::verb::eval::Tess_obj::east(ci,i,j,divsU1,divsV1,divs);
HXDLIN( 302)						 ::verb::eval::AdaptiveRefinementNode s = ::verb::eval::Tess_obj::south(ci,i,j,divsU1,divsV1,divs);
HXDLIN( 302)						 ::verb::eval::AdaptiveRefinementNode w = ::verb::eval::Tess_obj::west(ci,i,j,divsU1,divsV1,divs);
HXLINE( 308)						divs->__get(ci).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->neighbors = ::Array_obj< ::Dynamic>::__new(4)->init(0,s)->init(1,e)->init(2,n)->init(3,w);
HXLINE( 309)						divs->__get(ci).StaticCast<  ::verb::eval::AdaptiveRefinementNode >()->divide(options);
            					}
            				}
            			}
            		}
HXLINE( 313)		return divs;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Tess_obj,divideRationalSurfaceAdaptive,return )

 ::verb::eval::AdaptiveRefinementNode Tess_obj::north(int index,int i,int j,int divsU,int divsV,::Array< ::Dynamic> divs){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_316_north)
HXLINE( 317)		if ((i == 0)) {
HXLINE( 317)			return null();
            		}
HXLINE( 318)		return divs->__get((index - divsU)).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Tess_obj,north,return )

 ::verb::eval::AdaptiveRefinementNode Tess_obj::south(int index,int i,int j,int divsU,int divsV,::Array< ::Dynamic> divs){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_321_south)
HXLINE( 322)		if ((i == (divsV - 1))) {
HXLINE( 322)			return null();
            		}
HXLINE( 323)		return divs->__get((index + divsU)).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Tess_obj,south,return )

 ::verb::eval::AdaptiveRefinementNode Tess_obj::east(int index,int i,int j,int divsU,int divsV,::Array< ::Dynamic> divs){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_326_east)
HXLINE( 327)		if ((j == (divsU - 1))) {
HXLINE( 327)			return null();
            		}
HXLINE( 328)		return divs->__get((index + 1)).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Tess_obj,east,return )

 ::verb::eval::AdaptiveRefinementNode Tess_obj::west(int index,int i,int j,int divsU,int divsV,::Array< ::Dynamic> divs){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_331_west)
HXLINE( 332)		if ((j == 0)) {
HXLINE( 332)			return null();
            		}
HXLINE( 333)		return divs->__get((index - 1)).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Tess_obj,west,return )

 ::verb::core::MeshData Tess_obj::triangulateAdaptiveRefinementNodeTree(::Array< ::Dynamic> arrTree){
            	HX_STACKFRAME(&_hx_pos_66172106d7dfb866_336_triangulateAdaptiveRefinementNodeTree)
HXLINE( 339)		 ::verb::core::MeshData mesh = ::verb::core::MeshData_obj::empty();
HXLINE( 340)		{
HXLINE( 340)			int _g = 0;
HXDLIN( 340)			while((_g < arrTree->length)){
HXLINE( 340)				 ::verb::eval::AdaptiveRefinementNode x = arrTree->__get(_g).StaticCast<  ::verb::eval::AdaptiveRefinementNode >();
HXDLIN( 340)				_g = (_g + 1);
HXDLIN( 340)				x->triangulate(mesh);
            			}
            		}
HXLINE( 341)		return mesh;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tess_obj,triangulateAdaptiveRefinementNodeTree,return )

 ::verb::core::MeshData Tess_obj::rationalSurfaceAdaptive( ::verb::core::NurbsSurfaceData surface, ::verb::eval::AdaptiveRefinementOptions options){
            	HX_GC_STACKFRAME(&_hx_pos_66172106d7dfb866_345_rationalSurfaceAdaptive)
HXLINE( 347)		if (::hx::IsNull( options )) {
HXLINE( 347)			options =  ::verb::eval::AdaptiveRefinementOptions_obj::__alloc( HX_CTX );
            		}
HXLINE( 350)		::Array< ::Dynamic> arrTrees = ::verb::eval::Tess_obj::divideRationalSurfaceAdaptive(surface,options);
HXLINE( 353)		return ::verb::eval::Tess_obj::triangulateAdaptiveRefinementNodeTree(arrTrees);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Tess_obj,rationalSurfaceAdaptive,return )


Tess_obj::Tess_obj()
{
}

bool Tess_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"east") ) { outValue = east_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"west") ) { outValue = west_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"north") ) { outValue = north_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"south") ) { outValue = south_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"rationalSurfaceNaive") ) { outValue = rationalSurfaceNaive_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"rationalSurfaceAdaptive") ) { outValue = rationalSurfaceAdaptive_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"rationalCurveRegularSample") ) { outValue = rationalCurveRegularSample_dyn(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"rationalCurveAdaptiveSample") ) { outValue = rationalCurveAdaptiveSample_dyn(); return true; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"divideRationalSurfaceAdaptive") ) { outValue = divideRationalSurfaceAdaptive_dyn(); return true; }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"rationalCurveRegularSampleRange") ) { outValue = rationalCurveRegularSampleRange_dyn(); return true; }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"rationalCurveAdaptiveSampleRange") ) { outValue = rationalCurveAdaptiveSampleRange_dyn(); return true; }
		break;
	case 37:
		if (HX_FIELD_EQ(inName,"triangulateAdaptiveRefinementNodeTree") ) { outValue = triangulateAdaptiveRefinementNodeTree_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Tess_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Tess_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Tess_obj::__mClass;

static ::String Tess_obj_sStaticFields[] = {
	HX_("rationalCurveRegularSample",c5,cd,e9,d6),
	HX_("rationalCurveRegularSampleRange",b8,3d,0a,e1),
	HX_("rationalCurveAdaptiveSample",41,1f,f7,da),
	HX_("rationalCurveAdaptiveSampleRange",bc,0a,58,8a),
	HX_("rationalSurfaceNaive",e6,c5,a6,51),
	HX_("divideRationalSurfaceAdaptive",3c,77,12,f4),
	HX_("north",c5,64,c9,9f),
	HX_("south",0d,92,cc,80),
	HX_("east",fd,8b,0c,43),
	HX_("west",2f,6c,f5,4e),
	HX_("triangulateAdaptiveRefinementNodeTree",8d,d8,69,56),
	HX_("rationalSurfaceAdaptive",b5,ef,51,81),
	::String(null())
};

void Tess_obj::__register()
{
	Tess_obj _hx_dummy;
	Tess_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Tess",f4,fd,88,a5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Tess_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Tess_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Tess_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Tess_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Tess_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
