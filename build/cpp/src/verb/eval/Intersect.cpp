// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_verb_core_ArrayExtensions
#include <verb/core/ArrayExtensions.h>
#endif
#ifndef INCLUDED_verb_core_BoundingBox
#include <verb/core/BoundingBox.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif
#ifndef INCLUDED_verb_core_CurveCurveIntersection
#include <verb/core/CurveCurveIntersection.h>
#endif
#ifndef INCLUDED_verb_core_CurveSurfaceIntersection
#include <verb/core/CurveSurfaceIntersection.h>
#endif
#ifndef INCLUDED_verb_core_CurveTriPoint
#include <verb/core/CurveTriPoint.h>
#endif
#ifndef INCLUDED_verb_core_HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint
#include <verb/core/HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint.h>
#endif
#ifndef INCLUDED_verb_core_Interval
#include <verb/core/Interval.h>
#endif
#ifndef INCLUDED_verb_core_KdPoint_verb_core_MeshIntersectionPoint
#include <verb/core/KdPoint_verb_core_MeshIntersectionPoint.h>
#endif
#ifndef INCLUDED_verb_core_KdTree_verb_core_MeshIntersectionPoint
#include <verb/core/KdTree_verb_core_MeshIntersectionPoint.h>
#endif
#ifndef INCLUDED_verb_core_LazyCurveBoundingBoxTree
#include <verb/core/LazyCurveBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_core_LazyMeshBoundingBoxTree
#include <verb/core/LazyMeshBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_core_LazyPolylineBoundingBoxTree
#include <verb/core/LazyPolylineBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_core_LazySurfaceBoundingBoxTree
#include <verb/core/LazySurfaceBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_core_Mesh
#include <verb/core/Mesh.h>
#endif
#ifndef INCLUDED_verb_core_MeshBoundingBoxTree
#include <verb/core/MeshBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_core_MeshData
#include <verb/core/MeshData.h>
#endif
#ifndef INCLUDED_verb_core_MeshIntersectionPoint
#include <verb/core/MeshIntersectionPoint.h>
#endif
#ifndef INCLUDED_verb_core_MinimizationResult
#include <verb/core/MinimizationResult.h>
#endif
#ifndef INCLUDED_verb_core_Minimizer
#include <verb/core/Minimizer.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_Pair
#include <verb/core/Pair.h>
#endif
#ifndef INCLUDED_verb_core_PolylineData
#include <verb/core/PolylineData.h>
#endif
#ifndef INCLUDED_verb_core_PolylineMeshIntersection
#include <verb/core/PolylineMeshIntersection.h>
#endif
#ifndef INCLUDED_verb_core_Ray
#include <verb/core/Ray.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_core_SurfaceSurfaceIntersectionPoint
#include <verb/core/SurfaceSurfaceIntersectionPoint.h>
#endif
#ifndef INCLUDED_verb_core_TriSegmentIntersection
#include <verb/core/TriSegmentIntersection.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_eval_AdaptiveRefinementOptions
#include <verb/eval/AdaptiveRefinementOptions.h>
#endif
#ifndef INCLUDED_verb_eval_Eval
#include <verb/eval/Eval.h>
#endif
#ifndef INCLUDED_verb_eval_IBoundingBoxTree
#include <verb/eval/IBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_eval_Intersect
#include <verb/eval/Intersect.h>
#endif
#ifndef INCLUDED_verb_eval_Make
#include <verb/eval/Make.h>
#endif
#ifndef INCLUDED_verb_eval_Tess
#include <verb/eval/Tess.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_49_surfaces,"verb.eval.Intersect","surfaces",0x7b32f7f8,"verb.eval.Intersect.surfaces","verb/eval/Intersect.hx",49,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_89_surfacesAtPointWithEstimate,"verb.eval.Intersect","surfacesAtPointWithEstimate",0x5b9d49b3,"verb.eval.Intersect.surfacesAtPointWithEstimate","verb/eval/Intersect.hx",89,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_187_meshes,"verb.eval.Intersect","meshes",0x3144156d,"verb.eval.Intersect.meshes","verb/eval/Intersect.hx",187,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_172_meshes,"verb.eval.Intersect","meshes",0x3144156d,"verb.eval.Intersect.meshes","verb/eval/Intersect.hx",172,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_227_meshSlices,"verb.eval.Intersect","meshSlices",0x5b982080,"verb.eval.Intersect.meshSlices","verb/eval/Intersect.hx",227,0x2a5b5442)
static const Float _hx_array_data_99d17c5c_14[] = {
	0.0,0.0,
};
static const Float _hx_array_data_99d17c5c_15[] = {
	1.0,0.0,
};
static const Float _hx_array_data_99d17c5c_16[] = {
	1.0,1.0,
};
static const Float _hx_array_data_99d17c5c_17[] = {
	0.0,1.0,
};
static const int _hx_array_data_99d17c5c_18[] = {
	(int)0,(int)1,(int)2,
};
static const int _hx_array_data_99d17c5c_19[] = {
	(int)0,(int)2,(int)3,
};
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_262_makeMeshIntersectionPolylines,"verb.eval.Intersect","makeMeshIntersectionPolylines",0x8030721d,"verb.eval.Intersect.makeMeshIntersectionPolylines","verb/eval/Intersect.hx",262,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_367_kdTreeFromSegments,"verb.eval.Intersect","kdTreeFromSegments",0x7591cff3,"verb.eval.Intersect.kdTreeFromSegments","verb/eval/Intersect.hx",367,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_391_lookupAdjacentSegment,"verb.eval.Intersect","lookupAdjacentSegment",0xc9f46825,"verb.eval.Intersect.lookupAdjacentSegment","verb/eval/Intersect.hx",391,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_452_curveAndSurface,"verb.eval.Intersect","curveAndSurface",0xc4fda593,"verb.eval.Intersect.curveAndSurface","verb/eval/Intersect.hx",452,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_421_curveAndSurface,"verb.eval.Intersect","curveAndSurface",0xc4fda593,"verb.eval.Intersect.curveAndSurface","verb/eval/Intersect.hx",421,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_474_curveAndSurfaceWithEstimate,"verb.eval.Intersect","curveAndSurfaceWithEstimate",0x298e8f01,"verb.eval.Intersect.curveAndSurfaceWithEstimate","verb/eval/Intersect.hx",474,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_501_curveAndSurfaceWithEstimate,"verb.eval.Intersect","curveAndSurfaceWithEstimate",0x298e8f01,"verb.eval.Intersect.curveAndSurfaceWithEstimate","verb/eval/Intersect.hx",501,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_472_curveAndSurfaceWithEstimate,"verb.eval.Intersect","curveAndSurfaceWithEstimate",0x298e8f01,"verb.eval.Intersect.curveAndSurfaceWithEstimate","verb/eval/Intersect.hx",472,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_537_polylineAndMesh,"verb.eval.Intersect","polylineAndMesh",0xda3903f2,"verb.eval.Intersect.polylineAndMesh","verb/eval/Intersect.hx",537,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_578_boundingBoxTrees,"verb.eval.Intersect","boundingBoxTrees",0x16087320,"verb.eval.Intersect.boundingBoxTrees","verb/eval/Intersect.hx",578,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_666_curves,"verb.eval.Intersect","curves",0x677d2ab6,"verb.eval.Intersect.curves","verb/eval/Intersect.hx",666,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_655_curves,"verb.eval.Intersect","curves",0x677d2ab6,"verb.eval.Intersect.curves","verb/eval/Intersect.hx",655,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_691_curvesWithEstimate,"verb.eval.Intersect","curvesWithEstimate",0x9912bca4,"verb.eval.Intersect.curvesWithEstimate","verb/eval/Intersect.hx",691,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_712_curvesWithEstimate,"verb.eval.Intersect","curvesWithEstimate",0x9912bca4,"verb.eval.Intersect.curvesWithEstimate","verb/eval/Intersect.hx",712,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_690_curvesWithEstimate,"verb.eval.Intersect","curvesWithEstimate",0x9912bca4,"verb.eval.Intersect.curvesWithEstimate","verb/eval/Intersect.hx",690,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_749_triangles,"verb.eval.Intersect","triangles",0x8195c219,"verb.eval.Intersect.triangles","verb/eval/Intersect.hx",749,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_782_clipRayInCoplanarTriangle,"verb.eval.Intersect","clipRayInCoplanarTriangle",0x531deabb,"verb.eval.Intersect.clipRayInCoplanarTriangle","verb/eval/Intersect.hx",782,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_834_mergeTriangleClipIntervals,"verb.eval.Intersect","mergeTriangleClipIntervals",0x856263b0,"verb.eval.Intersect.mergeTriangleClipIntervals","verb/eval/Intersect.hx",834,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_882_planes,"verb.eval.Intersect","planes",0x6042f069,"verb.eval.Intersect.planes","verb/eval/Intersect.hx",882,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_960_threePlanes,"verb.eval.Intersect","threePlanes",0x855c3e83,"verb.eval.Intersect.threePlanes","verb/eval/Intersect.hx",960,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_987_polylines,"verb.eval.Intersect","polylines",0x7a109da1,"verb.eval.Intersect.polylines","verb/eval/Intersect.hx",987,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_1028_segments,"verb.eval.Intersect","segments",0x8669e3b2,"verb.eval.Intersect.segments","verb/eval/Intersect.hx",1028,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_1067_rays,"verb.eval.Intersect","rays",0x02353c9b,"verb.eval.Intersect.rays","verb/eval/Intersect.hx",1067,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_1106_segmentWithTriangle,"verb.eval.Intersect","segmentWithTriangle",0x8b17aa2f,"verb.eval.Intersect.segmentWithTriangle","verb/eval/Intersect.hx",1106,0x2a5b5442)
HX_LOCAL_STACK_FRAME(_hx_pos_bdf4538359f99c9e_1174_segmentAndPlane,"verb.eval.Intersect","segmentAndPlane",0x8ec616c6,"verb.eval.Intersect.segmentAndPlane","verb/eval/Intersect.hx",1174,0x2a5b5442)
namespace verb{
namespace eval{

void Intersect_obj::__construct() { }

Dynamic Intersect_obj::__CreateEmpty() { return new Intersect_obj; }

void *Intersect_obj::_hx_vtable = 0;

Dynamic Intersect_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Intersect_obj > _hx_result = new Intersect_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Intersect_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3b977ae4;
}

::Array< ::Dynamic> Intersect_obj::surfaces( ::verb::core::NurbsSurfaceData surface0, ::verb::core::NurbsSurfaceData surface1,Float tol){
            	HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_49_surfaces)
HXLINE(  52)		 ::verb::core::MeshData tess1 = ::verb::eval::Tess_obj::rationalSurfaceAdaptive(surface0,null());
HXLINE(  53)		 ::verb::core::MeshData tess2 = ::verb::eval::Tess_obj::rationalSurfaceAdaptive(surface1,null());
HXLINE(  56)		::Array< ::Dynamic> resApprox = ::verb::eval::Intersect_obj::meshes(tess1,tess2,null(),null());
HXLINE(  59)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(resApprox->length);
HXDLIN(  59)		{
HXLINE(  59)			int _g = 0;
HXDLIN(  59)			int _g1 = resApprox->length;
HXDLIN(  59)			while((_g < _g1)){
HXLINE(  59)				_g = (_g + 1);
HXDLIN(  59)				int i = (_g - 1);
HXDLIN(  59)				{
HXLINE(  60)					::Array< ::Dynamic> pl = ( (::Array< ::Dynamic>)(_hx_array_unsafe_get(resApprox,i)) );
HXDLIN(  60)					::Array< ::Dynamic> result1 = ::Array_obj< ::Dynamic>::__new(pl->length);
HXDLIN(  60)					{
HXLINE(  60)						int _g1 = 0;
HXDLIN(  60)						int _g2 = pl->length;
HXDLIN(  60)						while((_g1 < _g2)){
HXLINE(  60)							_g1 = (_g1 + 1);
HXDLIN(  60)							int i = (_g1 - 1);
HXDLIN(  60)							{
HXLINE(  61)								 ::verb::core::MeshIntersectionPoint inter = ( ( ::verb::core::MeshIntersectionPoint)(_hx_array_unsafe_get(pl,i)) );
HXLINE(  60)								 ::verb::core::SurfaceSurfaceIntersectionPoint inValue = ::verb::eval::Intersect_obj::surfacesAtPointWithEstimate(surface0,surface1,inter->uv0,inter->uv1,tol);
HXDLIN(  60)								result1->__unsafe_set(i,inValue);
            							}
            						}
            					}
HXLINE(  59)					result->__unsafe_set(i,result1);
            				}
            			}
            		}
HXDLIN(  59)		::Array< ::Dynamic> exactPls = result;
HXLINE(  66)		::Array< ::Dynamic> result1 = ::Array_obj< ::Dynamic>::__new(exactPls->length);
HXDLIN(  66)		{
HXLINE(  66)			int _g2 = 0;
HXDLIN(  66)			int _g3 = exactPls->length;
HXDLIN(  66)			while((_g2 < _g3)){
HXLINE(  66)				_g2 = (_g2 + 1);
HXDLIN(  66)				int i = (_g2 - 1);
HXDLIN(  66)				{
HXLINE(  67)					::Array< ::Dynamic> x = ( (::Array< ::Dynamic>)(_hx_array_unsafe_get(exactPls,i)) );
HXDLIN(  67)					::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(x->length);
HXDLIN(  67)					{
HXLINE(  67)						int _g = 0;
HXDLIN(  67)						int _g1 = x->length;
HXDLIN(  67)						while((_g < _g1)){
HXLINE(  67)							_g = (_g + 1);
HXDLIN(  67)							int i = (_g - 1);
HXDLIN(  67)							{
HXLINE(  67)								::Array< Float > inValue = ( ( ::verb::core::SurfaceSurfaceIntersectionPoint)(_hx_array_unsafe_get(x,i)) )->point;
HXDLIN(  67)								result->__unsafe_set(i,inValue);
            							}
            						}
            					}
HXLINE(  66)					 ::verb::core::NurbsCurveData inValue = ::verb::eval::Make_obj::rationalInterpCurve(result,3,null(),null(),null());
HXDLIN(  66)					result1->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(  66)		return result1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,surfaces,return )

 ::verb::core::SurfaceSurfaceIntersectionPoint Intersect_obj::surfacesAtPointWithEstimate( ::verb::core::NurbsSurfaceData surface0, ::verb::core::NurbsSurfaceData surface1,::Array< Float > uv1,::Array< Float > uv2,Float tol){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_89_surfacesAtPointWithEstimate)
HXLINE(  91)		::Array< ::Dynamic> pds;
HXDLIN(  91)		::Array< Float > p;
HXDLIN(  91)		::Array< Float > pn;
HXDLIN(  91)		::Array< Float > pu;
HXDLIN(  91)		::Array< Float > pv;
HXDLIN(  91)		Float pd;
HXDLIN(  91)		::Array< ::Dynamic> qds;
HXDLIN(  91)		::Array< Float > q;
HXDLIN(  91)		::Array< Float > qn;
HXDLIN(  91)		::Array< Float > qu;
HXDLIN(  91)		::Array< Float > qv;
HXDLIN(  91)		Float qd;
HXDLIN(  91)		Float dist;
HXLINE(  92)		int maxits = 5;
HXLINE(  93)		int its = 0;
HXLINE(  95)		while(true){
HXLINE(  97)			pds = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface0,uv1->__get(0),uv1->__get(1),1);
HXLINE(  98)			p = pds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE(  99)			pu = pds->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 100)			pv = pds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >();
HXLINE( 101)			pn = ::verb::core::Vec_obj::normalized(::verb::core::Vec_obj::cross(pu,pv));
HXLINE( 102)			pd = ::verb::core::Vec_obj::dot(pn,p);
HXLINE( 104)			qds = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface1,uv2->__get(0),uv2->__get(1),1);
HXLINE( 105)			q = qds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 106)			qu = qds->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 107)			qv = qds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >();
HXLINE( 108)			qn = ::verb::core::Vec_obj::normalized(::verb::core::Vec_obj::cross(qu,qv));
HXLINE( 109)			qd = ::verb::core::Vec_obj::dot(qn,q);
HXLINE( 112)			dist = ::verb::core::Vec_obj::distSquared(p,q);
HXLINE( 114)			if ((dist < (tol * tol))) {
HXLINE( 115)				goto _hx_goto_5;
            			}
HXLINE( 119)			::Array< Float > fn = ::verb::core::Vec_obj::normalized(::verb::core::Vec_obj::cross(pn,qn));
HXLINE( 120)			Float fd = ::verb::core::Vec_obj::dot(fn,p);
HXLINE( 123)			::Array< Float > x = ::verb::eval::Intersect_obj::threePlanes(pn,pd,qn,qd,fn,fd);
HXLINE( 125)			if (::hx::IsNull( x )) {
HXLINE( 125)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("panic!",ca,29,dc,ea)));
            			}
HXLINE( 130)			::Array< Float > pdif = ::verb::core::Vec_obj::sub(x,p);
HXLINE( 131)			::Array< Float > qdif = ::verb::core::Vec_obj::sub(x,q);
HXLINE( 133)			::Array< Float > rw = ::verb::core::Vec_obj::cross(pu,pn);
HXLINE( 134)			::Array< Float > rt = ::verb::core::Vec_obj::cross(pv,pn);
HXLINE( 136)			::Array< Float > su = ::verb::core::Vec_obj::cross(qu,qn);
HXLINE( 137)			::Array< Float > sv = ::verb::core::Vec_obj::cross(qv,qn);
HXLINE( 139)			Float dw = ::verb::core::Vec_obj::dot(rt,pdif);
HXDLIN( 139)			Float dw1 = (dw / ::verb::core::Vec_obj::dot(rt,pu));
HXLINE( 140)			Float dt = ::verb::core::Vec_obj::dot(rw,pdif);
HXDLIN( 140)			Float dt1 = (dt / ::verb::core::Vec_obj::dot(rw,pv));
HXLINE( 142)			Float du = ::verb::core::Vec_obj::dot(sv,qdif);
HXDLIN( 142)			Float du1 = (du / ::verb::core::Vec_obj::dot(sv,qu));
HXLINE( 143)			Float dv = ::verb::core::Vec_obj::dot(su,qdif);
HXDLIN( 143)			Float dv1 = (dv / ::verb::core::Vec_obj::dot(su,qv));
HXLINE( 145)			uv1 = ::verb::core::Vec_obj::add(::Array_obj< Float >::__new(2)->init(0,dw1)->init(1,dt1),uv1);
HXLINE( 146)			uv2 = ::verb::core::Vec_obj::add(::Array_obj< Float >::__new(2)->init(0,du1)->init(1,dv1),uv2);
HXLINE( 149)			its = (its + 1);
HXLINE(  95)			if (!((its < maxits))) {
HXLINE(  95)				goto _hx_goto_5;
            			}
            		}
            		_hx_goto_5:;
HXLINE( 153)		return  ::verb::core::SurfaceSurfaceIntersectionPoint_obj::__alloc( HX_CTX ,uv1,uv2,p,dist);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Intersect_obj,surfacesAtPointWithEstimate,return )

::Array< ::Dynamic> Intersect_obj::meshes( ::verb::core::MeshData mesh0, ::verb::core::MeshData mesh1,::Dynamic bbtree0,::Dynamic bbtree1){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		bool _hx_run( ::verb::core::Interval a, ::verb::core::Interval b){
            			HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_187_meshes)
HXLINE( 193)			::Array< Float > s1 = ::verb::core::Vec_obj::sub(( ( ::verb::core::MeshIntersectionPoint)(a->min) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(b->min) )->uv0);
HXLINE( 194)			Float d1 = ::verb::core::Vec_obj::dot(s1,s1);
HXLINE( 196)			::Array< Float > s2 = ::verb::core::Vec_obj::sub(( ( ::verb::core::MeshIntersectionPoint)(a->max) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(b->max) )->uv0);
HXLINE( 197)			Float d2 = ::verb::core::Vec_obj::dot(s2,s2);
HXLINE( 199)			::Array< Float > s3 = ::verb::core::Vec_obj::sub(( ( ::verb::core::MeshIntersectionPoint)(a->min) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(b->max) )->uv0);
HXLINE( 200)			Float d3 = ::verb::core::Vec_obj::dot(s3,s3);
HXLINE( 202)			::Array< Float > s4 = ::verb::core::Vec_obj::sub(( ( ::verb::core::MeshIntersectionPoint)(a->max) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(b->min) )->uv0);
HXLINE( 203)			Float d4 = ::verb::core::Vec_obj::dot(s4,s4);
HXLINE( 205)			bool segments;
HXDLIN( 205)			if ((d1 < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 205)				segments = (d2 < ::verb::core::Constants_obj::EPSILON);
            			}
            			else {
HXLINE( 205)				segments = false;
            			}
HXDLIN( 205)			if (!(segments)) {
HXLINE( 206)				if ((d3 < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 206)					return (d4 < ::verb::core::Constants_obj::EPSILON);
            				}
            				else {
HXLINE( 206)					return false;
            				}
            			}
            			else {
HXLINE( 205)				return true;
            			}
HXDLIN( 205)			return false;
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_172_meshes)
HXLINE( 174)		if (::hx::IsNull( bbtree0 )) {
HXLINE( 174)			bbtree0 =  ::verb::core::LazyMeshBoundingBoxTree_obj::__alloc( HX_CTX ,mesh0,null());
            		}
HXLINE( 175)		if (::hx::IsNull( bbtree1 )) {
HXLINE( 175)			bbtree1 =  ::verb::core::LazyMeshBoundingBoxTree_obj::__alloc( HX_CTX ,mesh1,null());
            		}
HXLINE( 178)		::Array< ::Dynamic> bbints = ::verb::eval::Intersect_obj::boundingBoxTrees(bbtree0,bbtree1,0);
HXLINE( 181)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(bbints->length);
HXDLIN( 181)		{
HXLINE( 181)			int _g = 0;
HXDLIN( 181)			int _g1 = bbints->length;
HXDLIN( 181)			while((_g < _g1)){
HXLINE( 181)				_g = (_g + 1);
HXDLIN( 181)				int i = (_g - 1);
HXDLIN( 181)				{
HXLINE( 182)					 ::verb::core::Pair ids = ( ( ::verb::core::Pair)(_hx_array_unsafe_get(bbints,i)) );
HXLINE( 181)					 ::verb::core::Interval inValue = ::verb::eval::Intersect_obj::triangles(mesh0,( (int)(ids->item0) ),mesh1,( (int)(ids->item1) ));
HXDLIN( 181)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN( 181)		::Array< ::Dynamic> _g2 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 181)		{
HXLINE( 181)			int _g3 = 0;
HXDLIN( 181)			::Array< ::Dynamic> _g4 = result;
HXDLIN( 181)			while((_g3 < _g4->length)){
HXLINE( 181)				 ::verb::core::Interval v = _g4->__get(_g3).StaticCast<  ::verb::core::Interval >();
HXDLIN( 181)				_g3 = (_g3 + 1);
HXDLIN( 181)				if (::hx::IsNotNull( v )) {
HXLINE( 181)					_g2->push(v);
            				}
            			}
            		}
HXDLIN( 181)		::Array< ::Dynamic> _g5 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 181)		{
HXLINE( 181)			int _g6 = 0;
HXDLIN( 181)			::Array< ::Dynamic> _g7 = _g2;
HXDLIN( 181)			while((_g6 < _g7->length)){
HXLINE( 181)				 ::verb::core::Interval v = _g7->__get(_g6).StaticCast<  ::verb::core::Interval >();
HXDLIN( 181)				_g6 = (_g6 + 1);
HXLINE( 186)				Float segments = ::verb::core::Vec_obj::distSquared(( ( ::verb::core::MeshIntersectionPoint)(v->min) )->point,( ( ::verb::core::MeshIntersectionPoint)(v->max) )->point);
HXLINE( 181)				if ((segments > ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 181)					_g5->push(v);
            				}
            			}
            		}
HXDLIN( 181)		::Array< ::Dynamic> segments = ::verb::core::ArrayExtensions_obj::unique(_g5, ::Dynamic(new _hx_Closure_0()));
HXLINE( 209)		return ::verb::eval::Intersect_obj::makeMeshIntersectionPolylines(segments);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,meshes,return )

::Array< ::Dynamic> Intersect_obj::meshSlices( ::verb::core::MeshData mesh,Float min,Float max,Float step){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_227_meshSlices)
HXLINE( 228)		 ::verb::core::MeshBoundingBoxTree bbtree =  ::verb::core::MeshBoundingBoxTree_obj::__alloc( HX_CTX ,mesh,null());
HXLINE( 229)		 ::verb::core::BoundingBox bb = bbtree->boundingBox();
HXLINE( 231)		Float x0 = bb->min->__get(0);
HXLINE( 232)		Float y0 = bb->min->__get(1);
HXLINE( 234)		Float x1 = bb->max->__get(0);
HXLINE( 235)		Float y1 = bb->max->__get(1);
HXLINE( 237)		::Array< Float > span = ::verb::core::Vec_obj::span(min,max,step);
HXLINE( 238)		::Array< ::Dynamic> slices = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 240)		{
HXLINE( 240)			int _g = 0;
HXDLIN( 240)			while((_g < span->length)){
HXLINE( 240)				Float z = span->__get(_g);
HXDLIN( 240)				_g = (_g + 1);
HXLINE( 241)				::Array< ::Dynamic> pts = ::Array_obj< ::Dynamic>::__new(4)->init(0,::Array_obj< Float >::__new(3)->init(0,x0)->init(1,y0)->init(2,z))->init(1,::Array_obj< Float >::__new(3)->init(0,x1)->init(1,y0)->init(2,z))->init(2,::Array_obj< Float >::__new(3)->init(0,x1)->init(1,y1)->init(2,z))->init(3,::Array_obj< Float >::__new(3)->init(0,x0)->init(1,y1)->init(2,z));
HXLINE( 242)				::Array< ::Dynamic> uvs = ::Array_obj< ::Dynamic>::__new(4)->init(0,::Array_obj< Float >::fromData( _hx_array_data_99d17c5c_14,2))->init(1,::Array_obj< Float >::fromData( _hx_array_data_99d17c5c_15,2))->init(2,::Array_obj< Float >::fromData( _hx_array_data_99d17c5c_16,2))->init(3,::Array_obj< Float >::fromData( _hx_array_data_99d17c5c_17,2));
HXLINE( 243)				::Array< ::Dynamic> faces = ::Array_obj< ::Dynamic>::__new(2)->init(0,::Array_obj< int >::fromData( _hx_array_data_99d17c5c_18,3))->init(1,::Array_obj< int >::fromData( _hx_array_data_99d17c5c_19,3));
HXLINE( 244)				 ::verb::core::MeshData plane =  ::verb::core::MeshData_obj::__alloc( HX_CTX ,faces,pts,null(),uvs);
HXLINE( 246)				slices->push(::verb::eval::Intersect_obj::meshes(mesh,plane,bbtree,null()));
            			}
            		}
HXLINE( 249)		return slices;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,meshSlices,return )

::Array< ::Dynamic> Intersect_obj::makeMeshIntersectionPolylines(::Array< ::Dynamic> segments){
            	HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_262_makeMeshIntersectionPolylines)
HXLINE( 264)		if ((segments->length == 0)) {
HXLINE( 264)			return ::Array_obj< ::Dynamic>::__new(0);
            		}
HXLINE( 267)		{
HXLINE( 267)			int _g = 0;
HXDLIN( 267)			while((_g < segments->length)){
HXLINE( 267)				 ::verb::core::Interval s = segments->__get(_g).StaticCast<  ::verb::core::Interval >();
HXDLIN( 267)				_g = (_g + 1);
HXLINE( 268)				( ( ::verb::core::MeshIntersectionPoint)(s->max) )->opp = ( ( ::verb::core::MeshIntersectionPoint)(s->min) );
HXLINE( 269)				( ( ::verb::core::MeshIntersectionPoint)(s->min) )->opp = ( ( ::verb::core::MeshIntersectionPoint)(s->max) );
            			}
            		}
HXLINE( 273)		 ::verb::core::KdTree_verb_core_MeshIntersectionPoint tree = ::verb::eval::Intersect_obj::kdTreeFromSegments(segments);
HXLINE( 276)		::Array< ::Dynamic> ends = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 278)		{
HXLINE( 278)			int _g1 = 0;
HXDLIN( 278)			while((_g1 < segments->length)){
HXLINE( 278)				 ::verb::core::Interval seg = segments->__get(_g1).StaticCast<  ::verb::core::Interval >();
HXDLIN( 278)				_g1 = (_g1 + 1);
HXLINE( 279)				ends->push(seg->min);
HXLINE( 280)				ends->push(seg->max);
            			}
            		}
HXLINE( 284)		{
HXLINE( 284)			int _g2 = 0;
HXDLIN( 284)			while((_g2 < ends->length)){
HXLINE( 284)				 ::verb::core::MeshIntersectionPoint segEnd = ends->__get(_g2).StaticCast<  ::verb::core::MeshIntersectionPoint >();
HXDLIN( 284)				_g2 = (_g2 + 1);
HXLINE( 285)				if (::hx::IsNotNull( segEnd->adj )) {
HXLINE( 285)					continue;
            				}
HXLINE( 287)				 ::verb::core::MeshIntersectionPoint adjEnd = ::verb::eval::Intersect_obj::lookupAdjacentSegment(segEnd,tree,segments->length);
HXLINE( 289)				bool _hx_tmp;
HXDLIN( 289)				if (::hx::IsNotNull( adjEnd )) {
HXLINE( 289)					_hx_tmp = ::hx::IsNull( adjEnd->adj );
            				}
            				else {
HXLINE( 289)					_hx_tmp = false;
            				}
HXDLIN( 289)				if (_hx_tmp) {
HXLINE( 290)					segEnd->adj = adjEnd;
HXLINE( 291)					adjEnd->adj = segEnd;
            				}
            			}
            		}
HXLINE( 296)		::Array< ::Dynamic> _g3 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 296)		{
HXLINE( 296)			int _g4 = 0;
HXDLIN( 296)			::Array< ::Dynamic> _g5 = ends;
HXDLIN( 296)			while((_g4 < _g5->length)){
HXLINE( 296)				 ::verb::core::MeshIntersectionPoint v = _g5->__get(_g4).StaticCast<  ::verb::core::MeshIntersectionPoint >();
HXDLIN( 296)				_g4 = (_g4 + 1);
HXDLIN( 296)				if (::hx::IsNull( v->adj )) {
HXLINE( 296)					_g3->push(v);
            				}
            			}
            		}
HXDLIN( 296)		::Array< ::Dynamic> freeEnds = _g3;
HXLINE( 301)		if ((freeEnds->length == 0)) {
HXLINE( 302)			freeEnds = ends;
            		}
HXLINE( 305)		::Array< ::Dynamic> pls = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 306)		int numVisitedEnds = 0;
HXLINE( 307)		bool loopDetected = false;
HXLINE( 309)		while((freeEnds->length != 0)){
HXLINE( 311)			 ::verb::core::MeshIntersectionPoint end = freeEnds->pop().StaticCast<  ::verb::core::MeshIntersectionPoint >();
HXLINE( 313)			if (!(end->visited)) {
HXLINE( 316)				::Array< ::Dynamic> pl = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 317)				 ::verb::core::MeshIntersectionPoint curEnd = end;
HXLINE( 319)				while(::hx::IsNotNull( curEnd )){
HXLINE( 322)					if (curEnd->visited) {
HXLINE( 323)						goto _hx_goto_25;
            					}
HXLINE( 327)					curEnd->visited = true;
HXLINE( 328)					curEnd->opp->visited = true;
HXLINE( 330)					pl->push(curEnd);
HXLINE( 331)					numVisitedEnds = (numVisitedEnds + 2);
HXLINE( 333)					curEnd = curEnd->opp->adj;
HXLINE( 336)					if (::hx::IsEq( curEnd,end )) {
HXLINE( 337)						goto _hx_goto_25;
            					}
            				}
            				_hx_goto_25:;
HXLINE( 341)				if ((pl->length > 0)) {
HXLINE( 342)					pl->push(pl->__get((pl->length - 1)).StaticCast<  ::verb::core::MeshIntersectionPoint >()->opp);
HXLINE( 343)					pls->push(pl);
            				}
            			}
HXLINE( 347)			bool _hx_tmp;
HXDLIN( 347)			bool _hx_tmp1;
HXDLIN( 347)			if ((freeEnds->length == 0)) {
HXLINE( 347)				_hx_tmp1 = (ends->length > 0);
            			}
            			else {
HXLINE( 347)				_hx_tmp1 = false;
            			}
HXDLIN( 347)			if (_hx_tmp1) {
HXLINE( 347)				if (!(loopDetected)) {
HXLINE( 347)					_hx_tmp = (numVisitedEnds < ends->length);
            				}
            				else {
HXLINE( 347)					_hx_tmp = true;
            				}
            			}
            			else {
HXLINE( 347)				_hx_tmp = false;
            			}
HXDLIN( 347)			if (_hx_tmp) {
HXLINE( 348)				loopDetected = true;
HXLINE( 349)				 ::verb::core::MeshIntersectionPoint e = ends->pop().StaticCast<  ::verb::core::MeshIntersectionPoint >();
HXLINE( 350)				freeEnds->push(e);
            			}
            		}
HXLINE( 354)		return pls;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Intersect_obj,makeMeshIntersectionPolylines,return )

 ::verb::core::KdTree_verb_core_MeshIntersectionPoint Intersect_obj::kdTreeFromSegments(::Array< ::Dynamic> segments){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_367_kdTreeFromSegments)
HXLINE( 369)		::Array< ::Dynamic> treePoints = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 372)		{
HXLINE( 372)			int _g = 0;
HXDLIN( 372)			while((_g < segments->length)){
HXLINE( 372)				 ::verb::core::Interval seg = segments->__get(_g).StaticCast<  ::verb::core::Interval >();
HXDLIN( 372)				_g = (_g + 1);
HXLINE( 373)				treePoints->push( ::verb::core::KdPoint_verb_core_MeshIntersectionPoint_obj::__alloc( HX_CTX ,( ( ::verb::core::MeshIntersectionPoint)(seg->min) )->point,( ( ::verb::core::MeshIntersectionPoint)(seg->min) )));
HXLINE( 374)				treePoints->push( ::verb::core::KdPoint_verb_core_MeshIntersectionPoint_obj::__alloc( HX_CTX ,( ( ::verb::core::MeshIntersectionPoint)(seg->max) )->point,( ( ::verb::core::MeshIntersectionPoint)(seg->max) )));
            			}
            		}
HXLINE( 378)		return  ::verb::core::KdTree_verb_core_MeshIntersectionPoint_obj::__alloc( HX_CTX ,treePoints,::verb::core::Vec_obj::distSquared_dyn());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Intersect_obj,kdTreeFromSegments,return )

 ::verb::core::MeshIntersectionPoint Intersect_obj::lookupAdjacentSegment( ::verb::core::MeshIntersectionPoint segEnd, ::verb::core::KdTree_verb_core_MeshIntersectionPoint tree,int numResults){
            	HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_391_lookupAdjacentSegment)
HXLINE( 395)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 395)		{
HXLINE( 395)			int _g1 = 0;
HXDLIN( 395)			::Array< ::Dynamic> _g2 = tree->nearest(segEnd->point,numResults,::verb::core::Constants_obj::EPSILON);
HXDLIN( 395)			while((_g1 < _g2->length)){
HXLINE( 395)				 ::verb::core::HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint v = _g2->__get(_g1).StaticCast<  ::verb::core::HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint >();
HXDLIN( 395)				_g1 = (_g1 + 1);
HXDLIN( 395)				if (::hx::IsNotEq( segEnd,v->obj->obj )) {
HXLINE( 395)					_g->push(v);
            				}
            			}
            		}
HXDLIN( 395)		::Array< ::Dynamic> _this = _g;
HXDLIN( 395)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(_this->length);
HXDLIN( 395)		{
HXLINE( 395)			int _g3 = 0;
HXDLIN( 395)			int _g4 = _this->length;
HXDLIN( 395)			while((_g3 < _g4)){
HXLINE( 395)				_g3 = (_g3 + 1);
HXDLIN( 395)				int i = (_g3 - 1);
HXDLIN( 395)				{
HXLINE( 395)					 ::verb::core::MeshIntersectionPoint inValue = ( ( ::verb::core::HeapElement_verb_core_KdPoint_verb_core_MeshIntersectionPoint)(_hx_array_unsafe_get(_this,i)) )->obj->obj;
HXDLIN( 395)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN( 395)		::Array< ::Dynamic> adj = result;
HXLINE( 402)		if ((adj->length == 1)) {
HXLINE( 402)			return adj->__get(0).StaticCast<  ::verb::core::MeshIntersectionPoint >();
            		}
            		else {
HXLINE( 402)			return null();
            		}
HXDLIN( 402)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,lookupAdjacentSegment,return )

::Array< ::Dynamic> Intersect_obj::curveAndSurface( ::verb::core::NurbsCurveData curve, ::verb::core::NurbsSurfaceData surface,::hx::Null< Float >  __o_tol,::Dynamic crvBbTree,::Dynamic srfBbTree){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0,Float,tol) HXARGC(2)
            		bool _hx_run( ::verb::core::CurveSurfaceIntersection a, ::verb::core::CurveSurfaceIntersection b){
            			HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_452_curveAndSurface)
HXLINE( 452)			return (::Math_obj::abs((a->u - b->u)) < (((Float)0.5) * tol));
            		}
            		HX_END_LOCAL_FUNC2(return)

            		Float tol = __o_tol.Default(((Float)1e-3));
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_421_curveAndSurface)
HXLINE( 423)		if (::hx::IsNull( crvBbTree )) {
HXLINE( 423)			crvBbTree =  ::verb::core::LazyCurveBoundingBoxTree_obj::__alloc( HX_CTX ,curve,null());
            		}
HXLINE( 424)		if (::hx::IsNull( srfBbTree )) {
HXLINE( 424)			srfBbTree =  ::verb::core::LazySurfaceBoundingBoxTree_obj::__alloc( HX_CTX ,surface,null(),null(),null());
            		}
HXLINE( 426)		::Array< ::Dynamic> ints = ::verb::eval::Intersect_obj::boundingBoxTrees(crvBbTree,srfBbTree,tol);
HXLINE( 428)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(ints->length);
HXDLIN( 428)		{
HXLINE( 428)			int _g = 0;
HXDLIN( 428)			int _g1 = ints->length;
HXDLIN( 428)			while((_g < _g1)){
HXLINE( 428)				_g = (_g + 1);
HXDLIN( 428)				int i = (_g - 1);
HXDLIN( 428)				{
HXLINE( 428)					 ::verb::core::Pair inter = ( ( ::verb::core::Pair)(_hx_array_unsafe_get(ints,i)) );
HXLINE( 430)					 ::verb::core::NurbsCurveData crvSeg = ( ( ::verb::core::NurbsCurveData)(inter->item0) );
HXLINE( 431)					 ::verb::core::NurbsSurfaceData srfPart = ( ( ::verb::core::NurbsSurfaceData)(inter->item1) );
HXLINE( 434)					Float min = ( (Float)(::verb::core::ArrayExtensions_obj::first(crvSeg->knots)) );
HXLINE( 435)					Float max = ( (Float)(::verb::core::ArrayExtensions_obj::last(crvSeg->knots)) );
HXLINE( 437)					Float u = ((min + max) / ((Float)2.0));
HXLINE( 440)					Float minu = ( (Float)(::verb::core::ArrayExtensions_obj::first(srfPart->knotsU)) );
HXLINE( 441)					Float maxu = ( (Float)(::verb::core::ArrayExtensions_obj::last(srfPart->knotsU)) );
HXLINE( 443)					Float minv = ( (Float)(::verb::core::ArrayExtensions_obj::first(srfPart->knotsV)) );
HXLINE( 444)					Float maxv = ( (Float)(::verb::core::ArrayExtensions_obj::last(srfPart->knotsV)) );
HXLINE( 446)					::Array< Float > uv = ::Array_obj< Float >::__new(2)->init(0,((minu + maxu) / ((Float)2.0)))->init(1,((minv + maxv) / ((Float)2.0)));
HXLINE( 448)					::Array< Float > inValue = ::Array_obj< Float >::__new(1)->init(0,u)->concat(uv);
HXLINE( 428)					 ::verb::core::CurveSurfaceIntersection inValue1 = ::verb::eval::Intersect_obj::curveAndSurfaceWithEstimate(crvSeg,srfPart,inValue,tol);
HXDLIN( 428)					result->__unsafe_set(i,inValue1);
            				}
            			}
            		}
HXDLIN( 428)		::Array< ::Dynamic> _g2 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 428)		{
HXLINE( 428)			int _g3 = 0;
HXDLIN( 428)			::Array< ::Dynamic> _g4 = result;
HXDLIN( 428)			while((_g3 < _g4->length)){
HXLINE( 428)				 ::verb::core::CurveSurfaceIntersection v = _g4->__get(_g3).StaticCast<  ::verb::core::CurveSurfaceIntersection >();
HXDLIN( 428)				_g3 = (_g3 + 1);
HXLINE( 450)				Float _hx_tmp = ::verb::core::Vec_obj::distSquared(v->curvePoint,v->surfacePoint);
HXLINE( 428)				if ((_hx_tmp < (tol * tol))) {
HXLINE( 428)					_g2->push(v);
            				}
            			}
            		}
HXDLIN( 428)		return ::verb::core::ArrayExtensions_obj::unique(_g2, ::Dynamic(new _hx_Closure_0(tol)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Intersect_obj,curveAndSurface,return )

 ::verb::core::CurveSurfaceIntersection Intersect_obj::curveAndSurfaceWithEstimate( ::verb::core::NurbsCurveData curve, ::verb::core::NurbsSurfaceData surface,::Array< Float > start_params,::hx::Null< Float >  __o_tol){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::verb::core::NurbsSurfaceData,surface, ::verb::core::NurbsCurveData,curve) HXARGC(1)
            		Float _hx_run(::Array< Float > x){
            			HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_474_curveAndSurfaceWithEstimate)
HXLINE( 475)			::Array< Float > p1 = ::verb::eval::Eval_obj::rationalCurvePoint(curve,x->__get(0));
HXDLIN( 475)			::Array< Float > p2 = ::verb::eval::Eval_obj::rationalSurfacePoint(surface,x->__get(1),x->__get(2));
HXDLIN( 475)			::Array< Float > p1_p2 = ::verb::core::Vec_obj::sub(p1,p2);
HXLINE( 479)			return ::verb::core::Vec_obj::dot(p1_p2,p1_p2);
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::verb::core::NurbsSurfaceData,surface, ::verb::core::NurbsCurveData,curve) HXARGC(1)
            		::Array< Float > _hx_run(::Array< Float > x){
            			HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_501_curveAndSurfaceWithEstimate)
HXLINE( 503)			::Array< ::Dynamic> dc = ::verb::eval::Eval_obj::rationalCurveDerivatives(curve,x->__get(0),1);
HXDLIN( 503)			::Array< ::Dynamic> ds = ::verb::eval::Eval_obj::rationalSurfaceDerivatives(surface,x->__get(1),x->__get(2),1);
HXLINE( 506)			::Array< Float > r = ::verb::core::Vec_obj::sub(ds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >(),dc->__get(0).StaticCast< ::Array< Float > >());
HXLINE( 508)			::Array< Float > drdt = ::verb::core::Vec_obj::mul(((Float)-1.0),dc->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 509)			::Array< Float > drdu = ds->__get(1).StaticCast< ::Array< ::Dynamic> >()->__get(0).StaticCast< ::Array< Float > >();
HXLINE( 510)			::Array< Float > drdv = ds->__get(0).StaticCast< ::Array< ::Dynamic> >()->__get(1).StaticCast< ::Array< Float > >();
HXLINE( 512)			Float grad = (((Float)2.0) * ::verb::core::Vec_obj::dot(drdt,r));
HXLINE( 513)			Float grad1 = (((Float)2.0) * ::verb::core::Vec_obj::dot(drdu,r));
HXLINE( 512)			return ::Array_obj< Float >::__new(3)->init(0,grad)->init(1,grad1)->init(2,(((Float)2.0) * ::verb::core::Vec_obj::dot(drdv,r)));
            		}
            		HX_END_LOCAL_FUNC1(return)

            		Float tol = __o_tol.Default(((Float)1e-3));
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_472_curveAndSurfaceWithEstimate)
HXLINE( 474)		 ::Dynamic objective =  ::Dynamic(new _hx_Closure_0(surface,curve));
HXLINE( 501)		 ::Dynamic grad =  ::Dynamic(new _hx_Closure_1(surface,curve));
HXLINE( 517)		 ::verb::core::MinimizationResult sol_obj = ::verb::core::Minimizer_obj::uncmin(objective,start_params,(tol * tol),grad,null());
HXLINE( 518)		::Array< Float > finalSolution = sol_obj->solution;
HXLINE( 520)		Float finalSolution1 = finalSolution->__get(0);
HXDLIN( 520)		Float finalSolution2 = finalSolution->__get(1);
HXDLIN( 520)		Float finalSolution3 = finalSolution->__get(2);
HXLINE( 521)		::Array< Float > _hx_tmp = ::verb::eval::Eval_obj::rationalCurvePoint(curve,finalSolution->__get(0));
HXLINE( 520)		return  ::verb::core::CurveSurfaceIntersection_obj::__alloc( HX_CTX ,finalSolution1,::Array_obj< Float >::__new(2)->init(0,finalSolution2)->init(1,finalSolution3),_hx_tmp,::verb::eval::Eval_obj::rationalSurfacePoint(surface,finalSolution->__get(1),finalSolution->__get(2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,curveAndSurfaceWithEstimate,return )

::Array< ::Dynamic> Intersect_obj::polylineAndMesh( ::verb::core::PolylineData polyline, ::verb::core::MeshData mesh,Float tol){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_537_polylineAndMesh)
HXLINE( 540)		 ::verb::core::LazyPolylineBoundingBoxTree res =  ::verb::core::LazyPolylineBoundingBoxTree_obj::__alloc( HX_CTX ,polyline,null());
HXLINE( 539)		::Array< ::Dynamic> res1 = ::verb::eval::Intersect_obj::boundingBoxTrees(res, ::verb::core::LazyMeshBoundingBoxTree_obj::__alloc( HX_CTX ,mesh,null()),tol);
HXLINE( 543)		::Array< ::Dynamic> finalResults = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 545)		{
HXLINE( 545)			int _g = 0;
HXDLIN( 545)			while((_g < res1->length)){
HXLINE( 545)				 ::verb::core::Pair event = res1->__get(_g).StaticCast<  ::verb::core::Pair >();
HXDLIN( 545)				_g = (_g + 1);
HXLINE( 547)				int polid = ( (int)(event->item0) );
HXLINE( 548)				int faceid = ( (int)(event->item1) );
HXLINE( 550)				 ::verb::core::TriSegmentIntersection inter = ::verb::eval::Intersect_obj::segmentWithTriangle(polyline->points->__get(polid).StaticCast< ::Array< Float > >(),polyline->points->__get((polid + 1)).StaticCast< ::Array< Float > >(),mesh->points,mesh->faces->__get(faceid).StaticCast< ::Array< int > >());
HXLINE( 551)				if (::hx::IsNull( inter )) {
HXLINE( 551)					continue;
            				}
HXLINE( 553)				::Array< Float > pt = inter->point;
HXLINE( 554)				Float u = ::verb::core::Vec_obj::lerp(inter->p,::Array_obj< Float >::__new(1)->init(0,polyline->params->__get(polid)),::Array_obj< Float >::__new(1)->init(0,polyline->params->__get((polid + 1))))->__get(0);
HXLINE( 555)				::Array< Float > uv = ::verb::core::Mesh_obj::triangleUVFromPoint(mesh,faceid,pt);
HXLINE( 557)				finalResults->push( ::verb::core::PolylineMeshIntersection_obj::__alloc( HX_CTX ,pt,u,uv,polid,faceid));
            			}
            		}
HXLINE( 561)		return finalResults;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,polylineAndMesh,return )

::Array< ::Dynamic> Intersect_obj::boundingBoxTrees(::Dynamic ai,::Dynamic bi,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(((Float)1e-9));
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_578_boundingBoxTrees)
HXLINE( 580)		::Array< ::Dynamic> atrees = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 581)		::Array< ::Dynamic> btrees = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 583)		atrees->push(ai);
HXLINE( 584)		btrees->push(bi);
HXLINE( 586)		::Array< ::Dynamic> results = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 588)		while((atrees->length > 0)){
HXLINE( 590)			::Dynamic a = atrees->pop();
HXLINE( 591)			::Dynamic b = btrees->pop();
HXLINE( 593)			bool _hx_tmp;
HXDLIN( 593)			if (!(::verb::eval::IBoundingBoxTree_obj::empty(a))) {
HXLINE( 593)				_hx_tmp = ::verb::eval::IBoundingBoxTree_obj::empty(b);
            			}
            			else {
HXLINE( 593)				_hx_tmp = true;
            			}
HXDLIN( 593)			if (_hx_tmp) {
HXLINE( 593)				continue;
            			}
HXLINE( 594)			 ::verb::core::BoundingBox _hx_tmp1 = ::verb::eval::IBoundingBoxTree_obj::boundingBox(a);
HXDLIN( 594)			if (!(_hx_tmp1->intersects(::verb::eval::IBoundingBoxTree_obj::boundingBox(b),tol))) {
HXLINE( 594)				continue;
            			}
HXLINE( 596)			bool ai = ::verb::eval::IBoundingBoxTree_obj::indivisible(a,tol);
HXLINE( 597)			bool bi = ::verb::eval::IBoundingBoxTree_obj::indivisible(b,tol);
HXLINE( 599)			bool _hx_tmp2;
HXDLIN( 599)			if (ai) {
HXLINE( 599)				_hx_tmp2 = bi;
            			}
            			else {
HXLINE( 599)				_hx_tmp2 = false;
            			}
HXDLIN( 599)			if (_hx_tmp2) {
HXLINE( 600)				 ::Dynamic _hx_tmp = ::verb::eval::IBoundingBoxTree_obj::yield(a);
HXDLIN( 600)				results->push( ::verb::core::Pair_obj::__alloc( HX_CTX ,_hx_tmp,::verb::eval::IBoundingBoxTree_obj::yield(b)));
HXLINE( 601)				continue;
            			}
            			else {
HXLINE( 602)				bool _hx_tmp;
HXDLIN( 602)				if (ai) {
HXLINE( 602)					_hx_tmp = !(bi);
            				}
            				else {
HXLINE( 602)					_hx_tmp = false;
            				}
HXDLIN( 602)				if (_hx_tmp) {
HXLINE( 603)					 ::verb::core::Pair bs = ::verb::eval::IBoundingBoxTree_obj::split(b);
HXLINE( 605)					atrees->push(a);
HXLINE( 606)					btrees->push(bs->item1);
HXLINE( 608)					atrees->push(a);
HXLINE( 609)					btrees->push(bs->item0);
HXLINE( 611)					continue;
            				}
            				else {
HXLINE( 612)					bool _hx_tmp;
HXDLIN( 612)					if (!(ai)) {
HXLINE( 612)						_hx_tmp = bi;
            					}
            					else {
HXLINE( 612)						_hx_tmp = false;
            					}
HXDLIN( 612)					if (_hx_tmp) {
HXLINE( 613)						 ::verb::core::Pair as = ::verb::eval::IBoundingBoxTree_obj::split(a);
HXLINE( 615)						atrees->push(as->item1);
HXLINE( 616)						btrees->push(b);
HXLINE( 618)						atrees->push(as->item0);
HXLINE( 619)						btrees->push(b);
HXLINE( 621)						continue;
            					}
            				}
            			}
HXLINE( 624)			 ::verb::core::Pair as = ::verb::eval::IBoundingBoxTree_obj::split(a);
HXDLIN( 624)			 ::verb::core::Pair bs = ::verb::eval::IBoundingBoxTree_obj::split(b);
HXLINE( 626)			atrees->push(as->item1);
HXLINE( 627)			btrees->push(bs->item1);
HXLINE( 629)			atrees->push(as->item1);
HXLINE( 630)			btrees->push(bs->item0);
HXLINE( 632)			atrees->push(as->item0);
HXLINE( 633)			btrees->push(bs->item1);
HXLINE( 635)			atrees->push(as->item0);
HXLINE( 636)			btrees->push(bs->item0);
            		}
HXLINE( 640)		return results;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,boundingBoxTrees,return )

::Array< ::Dynamic> Intersect_obj::curves( ::verb::core::NurbsCurveData curve1, ::verb::core::NurbsCurveData curve2,Float tolerance){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0,Float,tolerance) HXARGC(2)
            		bool _hx_run( ::verb::core::CurveCurveIntersection a, ::verb::core::CurveCurveIntersection b){
            			HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_666_curves)
HXLINE( 666)			return (::Math_obj::abs((a->u0 - b->u0)) < (tolerance * ( (Float)(5) )));
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_655_curves)
HXLINE( 658)		 ::verb::core::LazyCurveBoundingBoxTree ints =  ::verb::core::LazyCurveBoundingBoxTree_obj::__alloc( HX_CTX ,curve1,null());
HXLINE( 657)		::Array< ::Dynamic> ints1 = ::verb::eval::Intersect_obj::boundingBoxTrees(ints, ::verb::core::LazyCurveBoundingBoxTree_obj::__alloc( HX_CTX ,curve2,null()),0);
HXLINE( 661)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(ints1->length);
HXDLIN( 661)		{
HXLINE( 661)			int _g = 0;
HXDLIN( 661)			int _g1 = ints1->length;
HXDLIN( 661)			while((_g < _g1)){
HXLINE( 661)				_g = (_g + 1);
HXDLIN( 661)				int i = (_g - 1);
HXDLIN( 661)				{
HXLINE( 662)					 ::verb::core::Pair x = ( ( ::verb::core::Pair)(_hx_array_unsafe_get(ints1,i)) );
HXDLIN( 662)					Float inValue = ( (Float)(::verb::core::ArrayExtensions_obj::first(( ( ::verb::core::NurbsCurveData)(x->item0) )->knots)) );
HXDLIN( 662)					Float inValue1 = ( (Float)(::verb::core::ArrayExtensions_obj::first(( ( ::verb::core::NurbsCurveData)(x->item1) )->knots)) );
HXLINE( 661)					 ::verb::core::CurveCurveIntersection inValue2 = ::verb::eval::Intersect_obj::curvesWithEstimate(curve1,curve2,inValue,inValue1,tolerance);
HXDLIN( 661)					result->__unsafe_set(i,inValue2);
            				}
            			}
            		}
HXDLIN( 661)		::Array< ::Dynamic> _g2 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 661)		{
HXLINE( 661)			int _g3 = 0;
HXDLIN( 661)			::Array< ::Dynamic> _g4 = result;
HXDLIN( 661)			while((_g3 < _g4->length)){
HXLINE( 661)				 ::verb::core::CurveCurveIntersection v = _g4->__get(_g3).StaticCast<  ::verb::core::CurveCurveIntersection >();
HXDLIN( 661)				_g3 = (_g3 + 1);
HXLINE( 664)				Float _hx_tmp = ::verb::core::Vec_obj::distSquared(v->point0,v->point1);
HXLINE( 661)				if ((_hx_tmp < tolerance)) {
HXLINE( 661)					_g2->push(v);
            				}
            			}
            		}
HXDLIN( 661)		return ::verb::core::ArrayExtensions_obj::unique(_g2, ::Dynamic(new _hx_Closure_0(tolerance)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,curves,return )

 ::verb::core::CurveCurveIntersection Intersect_obj::curvesWithEstimate( ::verb::core::NurbsCurveData curve0, ::verb::core::NurbsCurveData curve1,Float u0,Float u1,Float tolerance){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::verb::core::NurbsCurveData,curve0, ::verb::core::NurbsCurveData,curve1) HXARGC(1)
            		Float _hx_run(::Array< Float > x){
            			HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_691_curvesWithEstimate)
HXLINE( 692)			::Array< Float > p1 = ::verb::eval::Eval_obj::rationalCurvePoint(curve0,x->__get(0));
HXDLIN( 692)			::Array< Float > p2 = ::verb::eval::Eval_obj::rationalCurvePoint(curve1,x->__get(1));
HXDLIN( 692)			::Array< Float > p1_p2 = ::verb::core::Vec_obj::sub(p1,p2);
HXLINE( 696)			return ::verb::core::Vec_obj::dot(p1_p2,p1_p2);
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::verb::core::NurbsCurveData,curve0, ::verb::core::NurbsCurveData,curve1) HXARGC(1)
            		::Array< Float > _hx_run(::Array< Float > x){
            			HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_712_curvesWithEstimate)
HXLINE( 713)			::Array< ::Dynamic> dc0 = ::verb::eval::Eval_obj::rationalCurveDerivatives(curve0,x->__get(0),1);
HXDLIN( 713)			::Array< ::Dynamic> dc1 = ::verb::eval::Eval_obj::rationalCurveDerivatives(curve1,x->__get(1),1);
HXLINE( 716)			::Array< Float > r = ::verb::core::Vec_obj::sub(dc0->__get(0).StaticCast< ::Array< Float > >(),dc1->__get(0).StaticCast< ::Array< Float > >());
HXLINE( 718)			::Array< Float > drdu = dc0->__get(1).StaticCast< ::Array< Float > >();
HXLINE( 719)			::Array< Float > drdt = ::verb::core::Vec_obj::mul(((Float)-1.0),dc1->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 721)			Float grad = (((Float)2.0) * ::verb::core::Vec_obj::dot(drdu,r));
HXDLIN( 721)			return ::Array_obj< Float >::__new(2)->init(0,grad)->init(1,(((Float)2.0) * ::verb::core::Vec_obj::dot(drdt,r)));
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_690_curvesWithEstimate)
HXLINE( 691)		 ::Dynamic objective =  ::Dynamic(new _hx_Closure_0(curve0,curve1));
HXLINE( 712)		 ::Dynamic grad =  ::Dynamic(new _hx_Closure_1(curve0,curve1));
HXLINE( 725)		 ::verb::core::MinimizationResult sol_obj = ::verb::core::Minimizer_obj::uncmin(objective,::Array_obj< Float >::__new(2)->init(0,u0)->init(1,u1),(tolerance * tolerance),grad,null());
HXLINE( 727)		Float u11 = sol_obj->solution->__get(0);
HXDLIN( 727)		Float u2 = sol_obj->solution->__get(1);
HXLINE( 730)		::Array< Float > p1 = ::verb::eval::Eval_obj::rationalCurvePoint(curve0,u11);
HXDLIN( 730)		::Array< Float > p2 = ::verb::eval::Eval_obj::rationalCurvePoint(curve1,u2);
HXLINE( 733)		return  ::verb::core::CurveCurveIntersection_obj::__alloc( HX_CTX ,p1,p2,u11,u2);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Intersect_obj,curvesWithEstimate,return )

 ::verb::core::Interval Intersect_obj::triangles( ::verb::core::MeshData mesh0,int faceIndex0, ::verb::core::MeshData mesh1,int faceIndex1){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_749_triangles)
HXLINE( 751)		::Array< int > tri0 = mesh0->faces->__get(faceIndex0).StaticCast< ::Array< int > >();
HXLINE( 752)		::Array< int > tri1 = mesh1->faces->__get(faceIndex1).StaticCast< ::Array< int > >();
HXLINE( 755)		::Array< Float > n0 = ::verb::core::Mesh_obj::getTriangleNorm(mesh0->points,tri0);
HXLINE( 756)		::Array< Float > n1 = ::verb::core::Mesh_obj::getTriangleNorm(mesh1->points,tri1);
HXLINE( 757)		::Array< Float > o0 = mesh0->points->__get(tri0->__get(0)).StaticCast< ::Array< Float > >();
HXLINE( 758)		::Array< Float > o1 = mesh1->points->__get(tri1->__get(0)).StaticCast< ::Array< Float > >();
HXLINE( 761)		 ::verb::core::Ray ray = ::verb::eval::Intersect_obj::planes(o0,n0,o1,n1);
HXLINE( 762)		if (::hx::IsNull( ray )) {
HXLINE( 762)			return null();
            		}
HXLINE( 765)		 ::verb::core::Interval clip1 = ::verb::eval::Intersect_obj::clipRayInCoplanarTriangle(ray,mesh0,faceIndex0);
HXLINE( 766)		if (::hx::IsNull( clip1 )) {
HXLINE( 766)			return null();
            		}
HXLINE( 769)		 ::verb::core::Interval clip2 = ::verb::eval::Intersect_obj::clipRayInCoplanarTriangle(ray,mesh1,faceIndex1);
HXLINE( 770)		if (::hx::IsNull( clip2 )) {
HXLINE( 770)			return null();
            		}
HXLINE( 773)		 ::verb::core::Interval merged = ::verb::eval::Intersect_obj::mergeTriangleClipIntervals(clip1,clip2,mesh0,faceIndex0,mesh1,faceIndex1);
HXLINE( 774)		if (::hx::IsNull( merged )) {
HXLINE( 774)			return null();
            		}
HXLINE( 777)		 ::verb::core::MeshIntersectionPoint _hx_tmp =  ::verb::core::MeshIntersectionPoint_obj::__alloc( HX_CTX ,( ( ::verb::core::MeshIntersectionPoint)(merged->min) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(merged->min) )->uv1,( ( ::verb::core::MeshIntersectionPoint)(merged->min) )->point,faceIndex0,faceIndex1);
HXLINE( 776)		return  ::verb::core::Interval_obj::__alloc( HX_CTX ,_hx_tmp, ::verb::core::MeshIntersectionPoint_obj::__alloc( HX_CTX ,( ( ::verb::core::MeshIntersectionPoint)(merged->max) )->uv0,( ( ::verb::core::MeshIntersectionPoint)(merged->max) )->uv1,( ( ::verb::core::MeshIntersectionPoint)(merged->max) )->point,faceIndex0,faceIndex1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,triangles,return )

 ::verb::core::Interval Intersect_obj::clipRayInCoplanarTriangle( ::verb::core::Ray ray, ::verb::core::MeshData mesh,int faceIndex){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_782_clipRayInCoplanarTriangle)
HXLINE( 785)		::Array< int > tri = mesh->faces->__get(faceIndex).StaticCast< ::Array< int > >();
HXDLIN( 785)		::Array< ::Dynamic> o = ::Array_obj< ::Dynamic>::__new(3)->init(0,mesh->points->__get(tri->__get(0)).StaticCast< ::Array< Float > >())->init(1,mesh->points->__get(tri->__get(1)).StaticCast< ::Array< Float > >())->init(2,mesh->points->__get(tri->__get(2)).StaticCast< ::Array< Float > >());
HXDLIN( 785)		::Array< ::Dynamic> uvs = ::Array_obj< ::Dynamic>::__new(3)->init(0,mesh->uvs->__get(tri->__get(0)).StaticCast< ::Array< Float > >())->init(1,mesh->uvs->__get(tri->__get(1)).StaticCast< ::Array< Float > >())->init(2,mesh->uvs->__get(tri->__get(2)).StaticCast< ::Array< Float > >());
HXLINE( 788)		::Array< Float > uvd = ::verb::core::Vec_obj::sub(uvs->__get(1).StaticCast< ::Array< Float > >(),uvs->__get(0).StaticCast< ::Array< Float > >());
HXDLIN( 788)		::Array< Float > uvd1 = ::verb::core::Vec_obj::sub(uvs->__get(2).StaticCast< ::Array< Float > >(),uvs->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 785)		::Array< ::Dynamic> uvd2 = ::Array_obj< ::Dynamic>::__new(3)->init(0,uvd)->init(1,uvd1)->init(2,::verb::core::Vec_obj::sub(uvs->__get(0).StaticCast< ::Array< Float > >(),uvs->__get(2).StaticCast< ::Array< Float > >()));
HXLINE( 789)		::Array< Float > s = ::verb::core::Vec_obj::sub(o->__get(1).StaticCast< ::Array< Float > >(),o->__get(0).StaticCast< ::Array< Float > >());
HXDLIN( 789)		::Array< Float > s1 = ::verb::core::Vec_obj::sub(o->__get(2).StaticCast< ::Array< Float > >(),o->__get(1).StaticCast< ::Array< Float > >());
HXLINE( 785)		::Array< ::Dynamic> s2 = ::Array_obj< ::Dynamic>::__new(3)->init(0,s)->init(1,s1)->init(2,::verb::core::Vec_obj::sub(o->__get(0).StaticCast< ::Array< Float > >(),o->__get(2).StaticCast< ::Array< Float > >()));
HXLINE( 790)		 ::Dynamic f = ::verb::core::Vec_obj::normalized_dyn();
HXDLIN( 790)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(s2->length);
HXDLIN( 790)		{
HXLINE( 790)			int _g = 0;
HXDLIN( 790)			int _g1 = s2->length;
HXDLIN( 790)			while((_g < _g1)){
HXLINE( 790)				_g = (_g + 1);
HXDLIN( 790)				int i = (_g - 1);
HXDLIN( 790)				{
HXLINE( 790)					::Array< Float > inValue = ( (::Array< Float >)(f(_hx_array_unsafe_get(s2,i))) );
HXDLIN( 790)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXLINE( 785)		::Array< ::Dynamic> d = result;
HXLINE( 791)		 ::Dynamic f1 = ::verb::core::Vec_obj::norm_dyn();
HXDLIN( 791)		::Array< Float > result1 = ::Array_obj< Float >::__new(s2->length);
HXDLIN( 791)		{
HXLINE( 791)			int _g2 = 0;
HXDLIN( 791)			int _g3 = s2->length;
HXDLIN( 791)			while((_g2 < _g3)){
HXLINE( 791)				_g2 = (_g2 + 1);
HXDLIN( 791)				int i = (_g2 - 1);
HXDLIN( 791)				{
HXLINE( 791)					Float inValue = ( (Float)(f1(_hx_array_unsafe_get(s2,i))) );
HXDLIN( 791)					result1->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXLINE( 785)		::Array< Float > l = result1;
HXLINE( 794)		 ::verb::core::CurveTriPoint minU = null();
HXLINE( 795)		 ::verb::core::CurveTriPoint maxU = null();
HXLINE( 798)		{
HXLINE( 798)			int _g4 = 0;
HXDLIN( 798)			while((_g4 < 3)){
HXLINE( 798)				_g4 = (_g4 + 1);
HXDLIN( 798)				int i = (_g4 - 1);
HXLINE( 799)				::Array< Float > o0 = o->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 800)				::Array< Float > d0 = d->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 802)				 ::verb::core::CurveCurveIntersection res = ::verb::eval::Intersect_obj::rays(o0,d0,ray->origin,ray->dir);
HXLINE( 804)				if (::hx::IsNull( res )) {
HXLINE( 805)					continue;
            				}
HXLINE( 808)				Float useg = res->u0;
HXLINE( 809)				Float uray = res->u1;
HXLINE( 812)				bool _hx_tmp;
HXDLIN( 812)				if (!((useg < -(::verb::core::Constants_obj::EPSILON)))) {
HXLINE( 812)					_hx_tmp = (useg > (l->__get(i) + ::verb::core::Constants_obj::EPSILON));
            				}
            				else {
HXLINE( 812)					_hx_tmp = true;
            				}
HXDLIN( 812)				if (_hx_tmp) {
HXLINE( 812)					continue;
            				}
HXLINE( 815)				bool _hx_tmp1;
HXDLIN( 815)				if (::hx::IsNotNull( minU )) {
HXLINE( 815)					_hx_tmp1 = (uray < minU->u);
            				}
            				else {
HXLINE( 815)					_hx_tmp1 = true;
            				}
HXDLIN( 815)				if (_hx_tmp1) {
HXLINE( 816)					::Array< Float > minU1 = ::verb::core::Vec_obj::onRay(ray->origin,ray->dir,uray);
HXDLIN( 816)					minU =  ::verb::core::CurveTriPoint_obj::__alloc( HX_CTX ,uray,minU1,::verb::core::Vec_obj::onRay(uvs->__get(i).StaticCast< ::Array< Float > >(),uvd2->__get(i).StaticCast< ::Array< Float > >(),(useg / l->__get(i))));
            				}
HXLINE( 819)				bool _hx_tmp2;
HXDLIN( 819)				if (::hx::IsNotNull( maxU )) {
HXLINE( 819)					_hx_tmp2 = (uray > maxU->u);
            				}
            				else {
HXLINE( 819)					_hx_tmp2 = true;
            				}
HXDLIN( 819)				if (_hx_tmp2) {
HXLINE( 820)					::Array< Float > maxU1 = ::verb::core::Vec_obj::onRay(ray->origin,ray->dir,uray);
HXDLIN( 820)					maxU =  ::verb::core::CurveTriPoint_obj::__alloc( HX_CTX ,uray,maxU1,::verb::core::Vec_obj::onRay(uvs->__get(i).StaticCast< ::Array< Float > >(),uvd2->__get(i).StaticCast< ::Array< Float > >(),(useg / l->__get(i))));
            				}
            			}
            		}
HXLINE( 824)		bool _hx_tmp;
HXDLIN( 824)		if (::hx::IsNotNull( maxU )) {
HXLINE( 824)			_hx_tmp = ::hx::IsNull( minU );
            		}
            		else {
HXLINE( 824)			_hx_tmp = true;
            		}
HXDLIN( 824)		if (_hx_tmp) {
HXLINE( 825)			return null();
            		}
HXLINE( 829)		return  ::verb::core::Interval_obj::__alloc( HX_CTX ,minU,maxU);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,clipRayInCoplanarTriangle,return )

 ::verb::core::Interval Intersect_obj::mergeTriangleClipIntervals( ::verb::core::Interval clip1, ::verb::core::Interval clip2, ::verb::core::MeshData mesh1,int faceIndex1, ::verb::core::MeshData mesh2,int faceIndex2){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_834_mergeTriangleClipIntervals)
HXLINE( 837)		bool _hx_tmp;
HXDLIN( 837)		if (!((( ( ::verb::core::CurveTriPoint)(clip2->min) )->u > (( ( ::verb::core::CurveTriPoint)(clip1->max) )->u + ::verb::core::Constants_obj::EPSILON)))) {
HXLINE( 837)			_hx_tmp = (( ( ::verb::core::CurveTriPoint)(clip1->min) )->u > (( ( ::verb::core::CurveTriPoint)(clip2->max) )->u + ::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE( 837)			_hx_tmp = true;
            		}
HXDLIN( 837)		if (_hx_tmp) {
HXLINE( 839)			return null();
            		}
HXLINE( 843)		 ::verb::core::Pair min;
HXDLIN( 843)		if ((( ( ::verb::core::CurveTriPoint)(clip1->min) )->u > ( ( ::verb::core::CurveTriPoint)(clip2->min) )->u)) {
HXLINE( 843)			min =  ::verb::core::Pair_obj::__alloc( HX_CTX ,clip1->min,0);
            		}
            		else {
HXLINE( 843)			min =  ::verb::core::Pair_obj::__alloc( HX_CTX ,clip2->min,1);
            		}
HXLINE( 844)		 ::verb::core::Pair max;
HXDLIN( 844)		if ((( ( ::verb::core::CurveTriPoint)(clip1->max) )->u < ( ( ::verb::core::CurveTriPoint)(clip2->max) )->u)) {
HXLINE( 844)			max =  ::verb::core::Pair_obj::__alloc( HX_CTX ,clip1->max,0);
            		}
            		else {
HXLINE( 844)			max =  ::verb::core::Pair_obj::__alloc( HX_CTX ,clip2->max,1);
            		}
HXLINE( 847)		 ::verb::core::MeshIntersectionPoint res =  ::verb::core::MeshIntersectionPoint_obj::__alloc( HX_CTX ,null(),null(),( ( ::verb::core::CurveTriPoint)(min->item0) )->point,faceIndex1,faceIndex2);
HXLINE( 846)		 ::verb::core::Interval res1 =  ::verb::core::Interval_obj::__alloc( HX_CTX ,res, ::verb::core::MeshIntersectionPoint_obj::__alloc( HX_CTX ,null(),null(),( ( ::verb::core::CurveTriPoint)(max->item0) )->point,faceIndex1,faceIndex2));
HXLINE( 850)		if (::hx::IsEq( min->item1,0 )) {
HXLINE( 851)			( ( ::verb::core::MeshIntersectionPoint)(res1->min) )->uv0 = ( ( ::verb::core::CurveTriPoint)(min->item0) )->uv;
HXLINE( 852)			( ( ::verb::core::MeshIntersectionPoint)(res1->min) )->uv1 = ::verb::core::Mesh_obj::triangleUVFromPoint(mesh2,faceIndex2,( ( ::verb::core::CurveTriPoint)(min->item0) )->point);
            		}
            		else {
HXLINE( 854)			( ( ::verb::core::MeshIntersectionPoint)(res1->min) )->uv0 = ::verb::core::Mesh_obj::triangleUVFromPoint(mesh1,faceIndex1,( ( ::verb::core::CurveTriPoint)(min->item0) )->point);
HXLINE( 855)			( ( ::verb::core::MeshIntersectionPoint)(res1->min) )->uv1 = ( ( ::verb::core::CurveTriPoint)(min->item0) )->uv;
            		}
HXLINE( 858)		if (::hx::IsEq( max->item1,0 )) {
HXLINE( 859)			( ( ::verb::core::MeshIntersectionPoint)(res1->max) )->uv0 = ( ( ::verb::core::CurveTriPoint)(max->item0) )->uv;
HXLINE( 860)			( ( ::verb::core::MeshIntersectionPoint)(res1->max) )->uv1 = ::verb::core::Mesh_obj::triangleUVFromPoint(mesh2,faceIndex2,( ( ::verb::core::CurveTriPoint)(max->item0) )->point);
            		}
            		else {
HXLINE( 862)			( ( ::verb::core::MeshIntersectionPoint)(res1->max) )->uv0 = ::verb::core::Mesh_obj::triangleUVFromPoint(mesh1,faceIndex1,( ( ::verb::core::CurveTriPoint)(max->item0) )->point);
HXLINE( 863)			( ( ::verb::core::MeshIntersectionPoint)(res1->max) )->uv1 = ( ( ::verb::core::CurveTriPoint)(max->item0) )->uv;
            		}
HXLINE( 866)		return res1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Intersect_obj,mergeTriangleClipIntervals,return )

 ::verb::core::Ray Intersect_obj::planes(::Array< Float > origin0,::Array< Float > normal0,::Array< Float > origin1,::Array< Float > normal1){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_882_planes)
HXLINE( 884)		::Array< Float > d = ::verb::core::Vec_obj::cross(normal0,normal1);
HXLINE( 886)		Float _hx_tmp = ::verb::core::Vec_obj::dot(d,d);
HXDLIN( 886)		if ((_hx_tmp < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 886)			return null();
            		}
HXLINE( 889)		int li = 0;
HXLINE( 890)		Float mi = ::Math_obj::abs(d->__get(0));
HXLINE( 891)		Float m1 = ::Math_obj::abs(d->__get(1));
HXLINE( 892)		Float m2 = ::Math_obj::abs(d->__get(2));
HXLINE( 894)		if ((m1 > mi)) {
HXLINE( 895)			li = 1;
HXLINE( 896)			mi = m1;
            		}
HXLINE( 899)		if ((m2 > mi)) {
HXLINE( 900)			li = 2;
HXLINE( 901)			mi = m2;
            		}
HXLINE( 904)		Float a1;
HXDLIN( 904)		Float b1;
HXDLIN( 904)		Float a2;
HXDLIN( 904)		Float b2;
HXLINE( 906)		if ((li == 0)) {
HXLINE( 907)			a1 = normal0->__get(1);
HXLINE( 908)			b1 = normal0->__get(2);
HXLINE( 909)			a2 = normal1->__get(1);
HXLINE( 910)			b2 = normal1->__get(2);
            		}
            		else {
HXLINE( 911)			if ((li == 1)) {
HXLINE( 912)				a1 = normal0->__get(0);
HXLINE( 913)				b1 = normal0->__get(2);
HXLINE( 914)				a2 = normal1->__get(0);
HXLINE( 915)				b2 = normal1->__get(2);
            			}
            			else {
HXLINE( 917)				a1 = normal0->__get(0);
HXLINE( 918)				b1 = normal0->__get(1);
HXLINE( 919)				a2 = normal1->__get(0);
HXLINE( 920)				b2 = normal1->__get(1);
            			}
            		}
HXLINE( 924)		Float d1 = -(::verb::core::Vec_obj::dot(origin0,normal0));
HXLINE( 925)		Float d2 = -(::verb::core::Vec_obj::dot(origin1,normal1));
HXLINE( 927)		Float den = ((a1 * b2) - (b1 * a2));
HXLINE( 929)		Float x = (((b1 * d2) - (d1 * b2)) / den);
HXLINE( 930)		Float y = (((d1 * a2) - (a1 * d2)) / den);
HXLINE( 931)		::Array< Float > p;
HXLINE( 933)		if ((li == 0)) {
HXLINE( 934)			p = ::Array_obj< Float >::__new(3)->init(0,0)->init(1,x)->init(2,y);
            		}
            		else {
HXLINE( 935)			if ((li == 1)) {
HXLINE( 936)				p = ::Array_obj< Float >::__new(3)->init(0,x)->init(1,0)->init(2,y);
            			}
            			else {
HXLINE( 938)				p = ::Array_obj< Float >::__new(3)->init(0,x)->init(1,y)->init(2,0);
            			}
            		}
HXLINE( 941)		return  ::verb::core::Ray_obj::__alloc( HX_CTX ,p,::verb::core::Vec_obj::normalized(d));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,planes,return )

::Array< Float > Intersect_obj::threePlanes(::Array< Float > n0,Float d0,::Array< Float > n1,Float d1,::Array< Float > n2,Float d2){
            	HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_960_threePlanes)
HXLINE( 962)		::Array< Float > u = ::verb::core::Vec_obj::cross(n1,n2);
HXLINE( 963)		Float den = ::verb::core::Vec_obj::dot(n0,u);
HXLINE( 965)		if ((::Math_obj::abs(den) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE( 965)			return null();
            		}
HXLINE( 967)		::Array< Float > diff = ::verb::core::Vec_obj::mul(d2,n1);
HXDLIN( 967)		::Array< Float > diff1 = ::verb::core::Vec_obj::sub(diff,::verb::core::Vec_obj::mul(d1,n2));
HXLINE( 968)		::Array< Float > num = ::verb::core::Vec_obj::mul(d0,u);
HXDLIN( 968)		::Array< Float > num1 = ::verb::core::Vec_obj::add(num,::verb::core::Vec_obj::cross(n0,diff1));
HXLINE( 970)		return ::verb::core::Vec_obj::mul((( (Float)(1) ) / den),num1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Intersect_obj,threePlanes,return )

::Array< ::Dynamic> Intersect_obj::polylines( ::verb::core::PolylineData polyline0, ::verb::core::PolylineData polyline1,Float tol){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_987_polylines)
HXLINE( 990)		 ::verb::core::LazyPolylineBoundingBoxTree res =  ::verb::core::LazyPolylineBoundingBoxTree_obj::__alloc( HX_CTX ,polyline0,null());
HXLINE( 989)		::Array< ::Dynamic> res1 = ::verb::eval::Intersect_obj::boundingBoxTrees(res, ::verb::core::LazyPolylineBoundingBoxTree_obj::__alloc( HX_CTX ,polyline1,null()),tol);
HXLINE( 993)		::Array< ::Dynamic> finalResults = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 995)		{
HXLINE( 995)			int _g = 0;
HXDLIN( 995)			while((_g < res1->length)){
HXLINE( 995)				 ::verb::core::Pair event = res1->__get(_g).StaticCast<  ::verb::core::Pair >();
HXDLIN( 995)				_g = (_g + 1);
HXLINE( 996)				int polid0 = ( (int)(event->item0) );
HXLINE( 997)				int polid1 = ( (int)(event->item1) );
HXLINE( 999)				 ::verb::core::CurveCurveIntersection inter = ::verb::eval::Intersect_obj::segments(polyline0->points->__get(polid0).StaticCast< ::Array< Float > >(),polyline0->points->__get((polid0 + 1)).StaticCast< ::Array< Float > >(),polyline1->points->__get(polid1).StaticCast< ::Array< Float > >(),polyline1->points->__get((polid1 + 1)).StaticCast< ::Array< Float > >(),tol);
HXLINE(1002)				if (::hx::IsNull( inter )) {
HXLINE(1002)					continue;
            				}
HXLINE(1005)				inter->u0 = ::verb::core::Vec_obj::lerp(inter->u0,::Array_obj< Float >::__new(1)->init(0,polyline0->params->__get(polid0)),::Array_obj< Float >::__new(1)->init(0,polyline0->params->__get((polid0 + 1))))->__get(0);
HXLINE(1006)				inter->u1 = ::verb::core::Vec_obj::lerp(inter->u1,::Array_obj< Float >::__new(1)->init(0,polyline1->params->__get(polid1)),::Array_obj< Float >::__new(1)->init(0,polyline1->params->__get((polid1 + 1))))->__get(0);
HXLINE(1008)				finalResults->push(inter);
            			}
            		}
HXLINE(1011)		return finalResults;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,polylines,return )

 ::verb::core::CurveCurveIntersection Intersect_obj::segments(::Array< Float > a0,::Array< Float > a1,::Array< Float > b0,::Array< Float > b1,Float tol){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_1028_segments)
HXLINE(1030)		::Array< Float > a1ma0 = ::verb::core::Vec_obj::sub(a1,a0);
HXDLIN(1030)		Float aN = ::Math_obj::sqrt(::verb::core::Vec_obj::dot(a1ma0,a1ma0));
HXDLIN(1030)		::Array< Float > a = ::verb::core::Vec_obj::mul((( (Float)(1) ) / aN),a1ma0);
HXDLIN(1030)		::Array< Float > b1mb0 = ::verb::core::Vec_obj::sub(b1,b0);
HXDLIN(1030)		Float bN = ::Math_obj::sqrt(::verb::core::Vec_obj::dot(b1mb0,b1mb0));
HXDLIN(1030)		::Array< Float > b = ::verb::core::Vec_obj::mul((( (Float)(1) ) / bN),b1mb0);
HXDLIN(1030)		 ::verb::core::CurveCurveIntersection int_params = ::verb::eval::Intersect_obj::rays(a0,a,b0,b);
HXLINE(1038)		if (::hx::IsNotNull( int_params )) {
HXLINE(1040)			Float u0 = ::Math_obj::min(::Math_obj::max(( (Float)(0) ),(int_params->u0 / aN)),((Float)1.0));
HXDLIN(1040)			Float u1 = ::Math_obj::min(::Math_obj::max(( (Float)(0) ),(int_params->u1 / bN)),((Float)1.0));
HXDLIN(1040)			::Array< Float > point0 = ::verb::core::Vec_obj::onRay(a0,a1ma0,u0);
HXDLIN(1040)			::Array< Float > point1 = ::verb::core::Vec_obj::onRay(b0,b1mb0,u1);
HXDLIN(1040)			Float dist = ::verb::core::Vec_obj::distSquared(point0,point1);
HXLINE(1046)			if ((dist < (tol * tol))) {
HXLINE(1047)				return  ::verb::core::CurveCurveIntersection_obj::__alloc( HX_CTX ,point0,point1,u0,u1);
            			}
            		}
HXLINE(1051)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Intersect_obj,segments,return )

 ::verb::core::CurveCurveIntersection Intersect_obj::rays(::Array< Float > a0,::Array< Float > a,::Array< Float > b0,::Array< Float > b){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_1067_rays)
HXLINE(1069)		Float dab = ::verb::core::Vec_obj::dot(a,b);
HXDLIN(1069)		Float dab0 = ::verb::core::Vec_obj::dot(a,b0);
HXDLIN(1069)		Float daa0 = ::verb::core::Vec_obj::dot(a,a0);
HXDLIN(1069)		Float dbb0 = ::verb::core::Vec_obj::dot(b,b0);
HXDLIN(1069)		Float dba0 = ::verb::core::Vec_obj::dot(b,a0);
HXDLIN(1069)		Float daa = ::verb::core::Vec_obj::dot(a,a);
HXDLIN(1069)		Float dbb = ::verb::core::Vec_obj::dot(b,b);
HXDLIN(1069)		Float div = ((daa * dbb) - (dab * dab));
HXLINE(1079)		if ((::Math_obj::abs(div) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE(1080)			return null();
            		}
HXLINE(1083)		Float num = ((dab * (dab0 - daa0)) - (daa * (dbb0 - dba0)));
HXDLIN(1083)		Float w = (num / div);
HXDLIN(1083)		Float t = (((dab0 - daa0) + (w * dab)) / daa);
HXLINE(1087)		::Array< Float > p0 = ::verb::core::Vec_obj::onRay(a0,a,t);
HXLINE(1088)		::Array< Float > p1 = ::verb::core::Vec_obj::onRay(b0,b,w);
HXLINE(1090)		return  ::verb::core::CurveCurveIntersection_obj::__alloc( HX_CTX ,p0,p1,t,w);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,rays,return )

 ::verb::core::TriSegmentIntersection Intersect_obj::segmentWithTriangle(::Array< Float > p0,::Array< Float > p1,::Array< ::Dynamic> points,::Array< int > tri){
            	HX_GC_STACKFRAME(&_hx_pos_bdf4538359f99c9e_1106_segmentWithTriangle)
HXLINE(1108)		::Array< Float > v0 = points->__get(tri->__get(0)).StaticCast< ::Array< Float > >();
HXDLIN(1108)		::Array< Float > v1 = points->__get(tri->__get(1)).StaticCast< ::Array< Float > >();
HXDLIN(1108)		::Array< Float > v2 = points->__get(tri->__get(2)).StaticCast< ::Array< Float > >();
HXDLIN(1108)		::Array< Float > u = ::verb::core::Vec_obj::sub(v1,v0);
HXDLIN(1108)		::Array< Float > v = ::verb::core::Vec_obj::sub(v2,v0);
HXDLIN(1108)		::Array< Float > n = ::verb::core::Vec_obj::cross(u,v);
HXLINE(1115)		::Array< Float > dir = ::verb::core::Vec_obj::sub(p1,p0);
HXDLIN(1115)		::Array< Float > w0 = ::verb::core::Vec_obj::sub(p0,v0);
HXDLIN(1115)		Float a = -(::verb::core::Vec_obj::dot(n,w0));
HXDLIN(1115)		Float b = ::verb::core::Vec_obj::dot(n,dir);
HXLINE(1121)		if ((::Math_obj::abs(b) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE(1122)			return null();
            		}
HXLINE(1125)		Float r = (a / b);
HXLINE(1128)		bool _hx_tmp;
HXDLIN(1128)		if (!((r < 0))) {
HXLINE(1128)			_hx_tmp = (r > 1);
            		}
            		else {
HXLINE(1128)			_hx_tmp = true;
            		}
HXDLIN(1128)		if (_hx_tmp) {
HXLINE(1129)			return null();
            		}
HXLINE(1133)		::Array< Float > pt = ::verb::core::Vec_obj::add(p0,::verb::core::Vec_obj::mul(r,dir));
HXLINE(1136)		Float uv = ::verb::core::Vec_obj::dot(u,v);
HXDLIN(1136)		Float uu = ::verb::core::Vec_obj::dot(u,u);
HXDLIN(1136)		Float vv = ::verb::core::Vec_obj::dot(v,v);
HXDLIN(1136)		::Array< Float > w = ::verb::core::Vec_obj::sub(pt,v0);
HXDLIN(1136)		Float wu = ::verb::core::Vec_obj::dot(w,u);
HXDLIN(1136)		Float wv = ::verb::core::Vec_obj::dot(w,v);
HXDLIN(1136)		Float denom = ((uv * uv) - (uu * vv));
HXLINE(1144)		if ((::Math_obj::abs(denom) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE(1145)			return null();
            		}
HXLINE(1148)		Float s = (((uv * wv) - (vv * wu)) / denom);
HXDLIN(1148)		Float t = (((uv * wu) - (uu * wv)) / denom);
HXLINE(1151)		bool _hx_tmp1;
HXDLIN(1151)		bool _hx_tmp2;
HXDLIN(1151)		bool _hx_tmp3;
HXDLIN(1151)		bool _hx_tmp4;
HXDLIN(1151)		if (!((s > (((Float)1.0) + ::verb::core::Constants_obj::EPSILON)))) {
HXLINE(1151)			_hx_tmp4 = (t > (((Float)1.0) + ::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE(1151)			_hx_tmp4 = true;
            		}
HXDLIN(1151)		if (!(_hx_tmp4)) {
HXLINE(1151)			_hx_tmp3 = (t < -(::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE(1151)			_hx_tmp3 = true;
            		}
HXDLIN(1151)		if (!(_hx_tmp3)) {
HXLINE(1151)			_hx_tmp2 = (s < -(::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE(1151)			_hx_tmp2 = true;
            		}
HXDLIN(1151)		if (!(_hx_tmp2)) {
HXLINE(1151)			_hx_tmp1 = ((s + t) > (((Float)1.0) + ::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE(1151)			_hx_tmp1 = true;
            		}
HXDLIN(1151)		if (_hx_tmp1) {
HXLINE(1152)			return null();
            		}
HXLINE(1155)		return  ::verb::core::TriSegmentIntersection_obj::__alloc( HX_CTX ,pt,s,t,r);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,segmentWithTriangle,return )

 ::Dynamic Intersect_obj::segmentAndPlane(::Array< Float > p0,::Array< Float > p1,::Array< Float > v0,::Array< Float > n){
            	HX_STACKFRAME(&_hx_pos_bdf4538359f99c9e_1174_segmentAndPlane)
HXLINE(1177)		Float denom = ::verb::core::Vec_obj::dot(n,::verb::core::Vec_obj::sub(p1,p0));
HXLINE(1180)		if ((::Math_obj::abs(denom) < ::verb::core::Constants_obj::EPSILON)) {
HXLINE(1181)			return null();
            		}
HXLINE(1184)		Float numer = ::verb::core::Vec_obj::dot(n,::verb::core::Vec_obj::sub(v0,p0));
HXLINE(1186)		Float p = (numer / denom);
HXLINE(1188)		bool _hx_tmp;
HXDLIN(1188)		if (!((p > (((Float)1.0) + ::verb::core::Constants_obj::EPSILON)))) {
HXLINE(1188)			_hx_tmp = (p < -(::verb::core::Constants_obj::EPSILON));
            		}
            		else {
HXLINE(1188)			_hx_tmp = true;
            		}
HXDLIN(1188)		if (_hx_tmp) {
HXLINE(1188)			return null();
            		}
HXLINE(1190)		return  ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("p",70,00,00,00),p));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Intersect_obj,segmentAndPlane,return )


Intersect_obj::Intersect_obj()
{
}

bool Intersect_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rays") ) { outValue = rays_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"meshes") ) { outValue = meshes_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curves") ) { outValue = curves_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"planes") ) { outValue = planes_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"surfaces") ) { outValue = surfaces_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"segments") ) { outValue = segments_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triangles") ) { outValue = triangles_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"polylines") ) { outValue = polylines_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"meshSlices") ) { outValue = meshSlices_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"threePlanes") ) { outValue = threePlanes_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curveAndSurface") ) { outValue = curveAndSurface_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"polylineAndMesh") ) { outValue = polylineAndMesh_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"segmentAndPlane") ) { outValue = segmentAndPlane_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"boundingBoxTrees") ) { outValue = boundingBoxTrees_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"kdTreeFromSegments") ) { outValue = kdTreeFromSegments_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curvesWithEstimate") ) { outValue = curvesWithEstimate_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"segmentWithTriangle") ) { outValue = segmentWithTriangle_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"lookupAdjacentSegment") ) { outValue = lookupAdjacentSegment_dyn(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"clipRayInCoplanarTriangle") ) { outValue = clipRayInCoplanarTriangle_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"mergeTriangleClipIntervals") ) { outValue = mergeTriangleClipIntervals_dyn(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"surfacesAtPointWithEstimate") ) { outValue = surfacesAtPointWithEstimate_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"curveAndSurfaceWithEstimate") ) { outValue = curveAndSurfaceWithEstimate_dyn(); return true; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"makeMeshIntersectionPolylines") ) { outValue = makeMeshIntersectionPolylines_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Intersect_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Intersect_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Intersect_obj::__mClass;

static ::String Intersect_obj_sStaticFields[] = {
	HX_("surfaces",a6,01,f0,42),
	HX_("surfacesAtPointWithEstimate",c5,c4,31,a0),
	HX_("meshes",9b,b7,b1,08),
	HX_("meshSlices",ae,71,ed,53),
	HX_("makeMeshIntersectionPolylines",af,55,27,6f),
	HX_("kdTreeFromSegments",21,ff,80,94),
	HX_("lookupAdjacentSegment",b7,69,d4,99),
	HX_("curveAndSurface",a5,4d,2d,c5),
	HX_("curveAndSurfaceWithEstimate",13,0a,23,6e),
	HX_("polylineAndMesh",04,ac,68,da),
	HX_("boundingBoxTrees",ce,da,8b,3f),
	HX_("curves",e4,cc,ea,3e),
	HX_("curvesWithEstimate",d2,eb,01,b8),
	HX_("triangles",ab,30,41,7f),
	HX_("clipRayInCoplanarTriangle",4d,1d,13,0a),
	HX_("mergeTriangleClipIntervals",de,70,f9,e4),
	HX_("planes",97,92,b0,37),
	HX_("threePlanes",95,f5,ad,d7),
	HX_("polylines",33,0c,bc,77),
	HX_("segments",60,ed,26,4e),
	HX_("rays",49,57,a4,4b),
	HX_("segmentWithTriangle",41,c3,71,7d),
	HX_("segmentAndPlane",d8,be,f5,8e),
	::String(null())
};

void Intersect_obj::__register()
{
	Intersect_obj _hx_dummy;
	Intersect_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.eval.Intersect",5c,7c,d1,99);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Intersect_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Intersect_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Intersect_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Intersect_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Intersect_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace eval
