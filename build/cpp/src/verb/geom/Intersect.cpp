// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_verb_core_CurveCurveIntersection
#include <verb/core/CurveCurveIntersection.h>
#endif
#ifndef INCLUDED_verb_core_CurveSurfaceIntersection
#include <verb/core/CurveSurfaceIntersection.h>
#endif
#ifndef INCLUDED_verb_core_ISerializable
#include <verb/core/ISerializable.h>
#endif
#ifndef INCLUDED_verb_core_NurbsCurveData
#include <verb/core/NurbsCurveData.h>
#endif
#ifndef INCLUDED_verb_core_NurbsSurfaceData
#include <verb/core/NurbsSurfaceData.h>
#endif
#ifndef INCLUDED_verb_core_SerializableBase
#include <verb/core/SerializableBase.h>
#endif
#ifndef INCLUDED_verb_eval_IBoundingBoxTree
#include <verb/eval/IBoundingBoxTree.h>
#endif
#ifndef INCLUDED_verb_eval_Intersect
#include <verb/eval/Intersect.h>
#endif
#ifndef INCLUDED_verb_geom_ICurve
#include <verb/geom/ICurve.h>
#endif
#ifndef INCLUDED_verb_geom_ISurface
#include <verb/geom/ISurface.h>
#endif
#ifndef INCLUDED_verb_geom_Intersect
#include <verb/geom/Intersect.h>
#endif
#ifndef INCLUDED_verb_geom_NurbsCurve
#include <verb/geom/NurbsCurve.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_0b8b10ca7ee15e54_29_curves,"verb.geom.Intersect","curves",0x57401396,"verb.geom.Intersect.curves","verb/geom/Intersect.hx",29,0xde804d22)
HX_LOCAL_STACK_FRAME(_hx_pos_0b8b10ca7ee15e54_46_curveAndSurface,"verb.geom.Intersect","curveAndSurface",0x8ac6a0b3,"verb.geom.Intersect.curveAndSurface","verb/geom/Intersect.hx",46,0xde804d22)
HX_LOCAL_STACK_FRAME(_hx_pos_0b8b10ca7ee15e54_61_surfaces,"verb.geom.Intersect","surfaces",0x1029d8d8,"verb.geom.Intersect.surfaces","verb/geom/Intersect.hx",61,0xde804d22)
namespace verb{
namespace geom{

void Intersect_obj::__construct() { }

Dynamic Intersect_obj::__CreateEmpty() { return new Intersect_obj; }

void *Intersect_obj::_hx_vtable = 0;

Dynamic Intersect_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Intersect_obj > _hx_result = new Intersect_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Intersect_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x19e193fc;
}

::Array< ::Dynamic> Intersect_obj::curves(::Dynamic first,::Dynamic second,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(((Float)1e-3));
            	HX_STACKFRAME(&_hx_pos_0b8b10ca7ee15e54_29_curves)
HXDLIN(  29)		 ::verb::core::NurbsCurveData _hx_tmp = ::verb::geom::ICurve_obj::asNurbs(first);
HXDLIN(  29)		return ::verb::eval::Intersect_obj::curves(_hx_tmp,::verb::geom::ICurve_obj::asNurbs(second),tol);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,curves,return )

::Array< ::Dynamic> Intersect_obj::curveAndSurface(::Dynamic curve,::Dynamic surface,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(((Float)1e-3));
            	HX_STACKFRAME(&_hx_pos_0b8b10ca7ee15e54_46_curveAndSurface)
HXDLIN(  46)		 ::verb::core::NurbsCurveData _hx_tmp = ::verb::geom::ICurve_obj::asNurbs(curve);
HXDLIN(  46)		return ::verb::eval::Intersect_obj::curveAndSurface(_hx_tmp,::verb::geom::ISurface_obj::asNurbs(surface),tol,null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,curveAndSurface,return )

::Array< ::Dynamic> Intersect_obj::surfaces(::Dynamic first,::Dynamic second,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(((Float)1e-3));
            	HX_GC_STACKFRAME(&_hx_pos_0b8b10ca7ee15e54_61_surfaces)
HXDLIN(  61)		 ::verb::core::NurbsSurfaceData _this = ::verb::geom::ISurface_obj::asNurbs(first);
HXDLIN(  61)		::Array< ::Dynamic> _this1 = ::verb::eval::Intersect_obj::surfaces(_this,::verb::geom::ISurface_obj::asNurbs(second),tol);
HXDLIN(  61)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(_this1->length);
HXDLIN(  61)		{
HXDLIN(  61)			int _g = 0;
HXDLIN(  61)			int _g1 = _this1->length;
HXDLIN(  61)			while((_g < _g1)){
HXDLIN(  61)				_g = (_g + 1);
HXDLIN(  61)				int i = (_g - 1);
HXDLIN(  61)				{
HXDLIN(  61)					 ::verb::geom::NurbsCurve inValue =  ::verb::geom::NurbsCurve_obj::__alloc( HX_CTX ,( ( ::verb::core::NurbsCurveData)(_hx_array_unsafe_get(_this1,i)) ));
HXDLIN(  61)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(  61)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Intersect_obj,surfaces,return )


Intersect_obj::Intersect_obj()
{
}

bool Intersect_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"curves") ) { outValue = curves_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"surfaces") ) { outValue = surfaces_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curveAndSurface") ) { outValue = curveAndSurface_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Intersect_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Intersect_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Intersect_obj::__mClass;

static ::String Intersect_obj_sStaticFields[] = {
	HX_("curves",e4,cc,ea,3e),
	HX_("curveAndSurface",a5,4d,2d,c5),
	HX_("surfaces",a6,01,f0,42),
	::String(null())
};

void Intersect_obj::__register()
{
	Intersect_obj _hx_dummy;
	Intersect_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.geom.Intersect",7c,37,ba,96);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Intersect_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Intersect_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Intersect_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Intersect_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Intersect_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace geom
