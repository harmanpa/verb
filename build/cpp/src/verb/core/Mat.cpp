// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_verb_core_Mat
#include <verb/core/Mat.h>
#endif
#ifndef INCLUDED_verb_core_Vec
#include <verb/core/Vec.h>
#endif
#ifndef INCLUDED_verb_core__Mat_LUDecomp
#include <verb/core/_Mat/LUDecomp.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_14_mul,"verb.core.Mat","mul",0xfc19c636,"verb.core.Mat.mul","verb/core/Mat.hx",14,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_21_mult,"verb.core.Mat","mult",0x9a73a97e,"verb.core.Mat.mult","verb/core/Mat.hx",21,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_59_add,"verb.core.Mat","add",0xfc109c53,"verb.core.Mat.add","verb/core/Mat.hx",59,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_65_div,"verb.core.Mat","div",0xfc12e783,"verb.core.Mat.div","verb/core/Mat.hx",65,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_71_sub,"verb.core.Mat","sub",0xfc1e53b2,"verb.core.Mat.sub","verb/core/Mat.hx",71,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_77_dot,"verb.core.Mat","dot",0xfc12ecbb,"verb.core.Mat.dot","verb/core/Mat.hx",77,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_82_identity,"verb.core.Mat","identity",0xf8d865cc,"verb.core.Mat.identity","verb/core/Mat.hx",82,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_90_transpose,"verb.core.Mat","transpose",0xc082ac2b,"verb.core.Mat.transpose","verb/core/Mat.hx",90,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_95_transposeN,"verb.core.Mat","transposeN",0xb1d3f9c3,"verb.core.Mat.transposeN","verb/core/Mat.hx",95,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_103_solve,"verb.core.Mat","solve",0xfb30da31,"verb.core.Mat.solve","verb/core/Mat.hx",103,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_108_LUsolve,"verb.core.Mat","LUsolve",0x14e75788,"verb.core.Mat.LUsolve","verb/core/Mat.hx",108,0x57cc617e)
HX_LOCAL_STACK_FRAME(_hx_pos_9d236faa95ce82cb_158_LU,"verb.core.Mat","LU",0xec776497,"verb.core.Mat.LU","verb/core/Mat.hx",158,0x57cc617e)
namespace verb{
namespace core{

void Mat_obj::__construct() { }

Dynamic Mat_obj::__CreateEmpty() { return new Mat_obj; }

void *Mat_obj::_hx_vtable = 0;

Dynamic Mat_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Mat_obj > _hx_result = new Mat_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Mat_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x176bee42;
}

::Array< ::Dynamic> Mat_obj::mul(Float a,::Array< ::Dynamic> b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_14_mul)
HXDLIN(  14)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  14)		{
HXDLIN(  14)			int _g1 = 0;
HXDLIN(  14)			int _g2 = b->length;
HXDLIN(  14)			while((_g1 < _g2)){
HXDLIN(  14)				_g1 = (_g1 + 1);
HXDLIN(  14)				int i = (_g1 - 1);
HXDLIN(  14)				_g->push(::verb::core::Vec_obj::mul(a,b->__get(i).StaticCast< ::Array< Float > >()));
            			}
            		}
HXDLIN(  14)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,mul,return )

::Array< ::Dynamic> Mat_obj::mult(::Array< ::Dynamic> x,::Array< ::Dynamic> y){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_21_mult)
HXLINE(  23)		::Array< Float > foo;
HXDLIN(  23)		::Array< Float > bar;
HXDLIN(  23)		Float woo;
HXDLIN(  23)		int i0;
HXDLIN(  23)		 ::Dynamic k0;
HXDLIN(  23)		 ::Dynamic p0;
HXDLIN(  23)		 ::Dynamic r0;
HXDLIN(  23)		int p = x->length;
HXDLIN(  23)		int q = y->length;
HXDLIN(  23)		int r = y->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN(  23)		::Array< ::Dynamic> ret = ::Array_obj< ::Dynamic>::__new();
HXLINE(  28)		int i = (p - 1);
HXLINE(  29)		int j = 0;
HXLINE(  30)		int k = 0;
HXLINE(  32)		while((i >= 0)){
HXLINE(  33)			foo = ::Array_obj< Float >::__new();
HXLINE(  34)			bar = x->__get(i).StaticCast< ::Array< Float > >();
HXLINE(  36)			k = (r - 1);
HXLINE(  37)			while((k >= 0)){
HXLINE(  38)				woo = (bar->__get((q - 1)) * y->__get((q - 1)).StaticCast< ::Array< Float > >()->__get(k));
HXLINE(  40)				j = (q - 2);
HXLINE(  41)				while((j >= 1)){
HXLINE(  42)					i0 = (j - 1);
HXLINE(  43)					woo = (woo + ((bar->__get(j) * y->__get(j).StaticCast< ::Array< Float > >()->__get(k)) + (bar->__get(i0) * y->__get(i0).StaticCast< ::Array< Float > >()->__get(k))));
HXLINE(  44)					j = (j - 2);
            				}
HXLINE(  46)				if ((j == 0)) {
HXLINE(  46)					woo = (woo + (bar->__get(0) * y->__get(0).StaticCast< ::Array< Float > >()->__get(k)));
            				}
HXLINE(  47)				foo[k] = woo;
HXLINE(  48)				k = (k - 1);
            			}
HXLINE(  50)			ret[i] = foo;
HXLINE(  51)			i = (i - 1);
            		}
HXLINE(  53)		return ret;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,mult,return )

::Array< ::Dynamic> Mat_obj::add(::Array< ::Dynamic> a,::Array< ::Dynamic> b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_59_add)
HXDLIN(  59)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  59)		{
HXDLIN(  59)			int _g1 = 0;
HXDLIN(  59)			int _g2 = a->length;
HXDLIN(  59)			while((_g1 < _g2)){
HXDLIN(  59)				_g1 = (_g1 + 1);
HXDLIN(  59)				int i = (_g1 - 1);
HXDLIN(  59)				_g->push(::verb::core::Vec_obj::add(a->__get(i).StaticCast< ::Array< Float > >(),b->__get(i).StaticCast< ::Array< Float > >()));
            			}
            		}
HXDLIN(  59)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,add,return )

::Array< ::Dynamic> Mat_obj::div(::Array< ::Dynamic> a,Float b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_65_div)
HXDLIN(  65)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  65)		{
HXDLIN(  65)			int _g1 = 0;
HXDLIN(  65)			int _g2 = a->length;
HXDLIN(  65)			while((_g1 < _g2)){
HXDLIN(  65)				_g1 = (_g1 + 1);
HXDLIN(  65)				int i = (_g1 - 1);
HXDLIN(  65)				_g->push(::verb::core::Vec_obj::div(a->__get(i).StaticCast< ::Array< Float > >(),b));
            			}
            		}
HXDLIN(  65)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,div,return )

::Array< ::Dynamic> Mat_obj::sub(::Array< ::Dynamic> a,::Array< ::Dynamic> b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_71_sub)
HXDLIN(  71)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  71)		{
HXDLIN(  71)			int _g1 = 0;
HXDLIN(  71)			int _g2 = a->length;
HXDLIN(  71)			while((_g1 < _g2)){
HXDLIN(  71)				_g1 = (_g1 + 1);
HXDLIN(  71)				int i = (_g1 - 1);
HXDLIN(  71)				_g->push(::verb::core::Vec_obj::sub(a->__get(i).StaticCast< ::Array< Float > >(),b->__get(i).StaticCast< ::Array< Float > >()));
            			}
            		}
HXDLIN(  71)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,sub,return )

::Array< Float > Mat_obj::dot(::Array< ::Dynamic> a,::Array< Float > b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_77_dot)
HXDLIN(  77)		::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN(  77)		{
HXDLIN(  77)			int _g1 = 0;
HXDLIN(  77)			int _g2 = a->length;
HXDLIN(  77)			while((_g1 < _g2)){
HXDLIN(  77)				_g1 = (_g1 + 1);
HXDLIN(  77)				int i = (_g1 - 1);
HXDLIN(  77)				_g->push(::verb::core::Vec_obj::dot(a->__get(i).StaticCast< ::Array< Float > >(),b));
            			}
            		}
HXDLIN(  77)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,dot,return )

::Array< ::Dynamic> Mat_obj::identity(int n){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_82_identity)
HXLINE(  83)		::Array< ::Dynamic> zeros = ::verb::core::Vec_obj::zeros2d(n,n);
HXLINE(  84)		{
HXLINE(  84)			int _g = 0;
HXDLIN(  84)			int _g1 = n;
HXDLIN(  84)			while((_g < _g1)){
HXLINE(  84)				_g = (_g + 1);
HXDLIN(  84)				int i = (_g - 1);
HXDLIN(  84)				zeros->__get(i).StaticCast< ::Array< Float > >()[i] = ((Float)1.0);
            			}
            		}
HXLINE(  85)		return zeros;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mat_obj,identity,return )

::Array< ::Dynamic> Mat_obj::transpose(::Array< ::Dynamic> a){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_90_transpose)
HXLINE(  91)		if ((a->length == 0)) {
HXLINE(  91)			return ::Array_obj< ::Dynamic>::__new(0);
            		}
HXLINE(  92)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  92)		{
HXLINE(  92)			int _g1 = 0;
HXDLIN(  92)			int _g2 = a->__get(0).StaticCast< ::Array< Float > >()->length;
HXDLIN(  92)			while((_g1 < _g2)){
HXLINE(  92)				_g1 = (_g1 + 1);
HXDLIN(  92)				int i = (_g1 - 1);
HXDLIN(  92)				::Array< Float > _g2 = ::Array_obj< Float >::__new(0);
HXDLIN(  92)				{
HXLINE(  92)					int _g3 = 0;
HXDLIN(  92)					int _g4 = a->length;
HXDLIN(  92)					while((_g3 < _g4)){
HXLINE(  92)						_g3 = (_g3 + 1);
HXDLIN(  92)						int j = (_g3 - 1);
HXDLIN(  92)						_g2->push(a->__get(j).StaticCast< ::Array< Float > >()->__get(i));
            					}
            				}
HXDLIN(  92)				_g->push(_g2);
            			}
            		}
HXDLIN(  92)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mat_obj,transpose,return )

::Array< ::Dynamic> Mat_obj::transposeN(::Array< ::Dynamic> a){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_95_transposeN)
HXLINE(  96)		if ((a->length == 0)) {
HXLINE(  96)			return ::Array_obj< ::Dynamic>::__new(0);
            		}
HXLINE(  97)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  97)		{
HXLINE(  97)			int _g1 = 0;
HXDLIN(  97)			int _g2 = ::cpp::VirtualArray( a->__get(0))->get_length();
HXDLIN(  97)			while((_g1 < _g2)){
HXLINE(  97)				_g1 = (_g1 + 1);
HXDLIN(  97)				int i = (_g1 - 1);
HXDLIN(  97)				::cpp::VirtualArray _g2 = ::cpp::VirtualArray_obj::__new(0);
HXDLIN(  97)				{
HXLINE(  97)					int _g3 = 0;
HXDLIN(  97)					int _g4 = a->length;
HXDLIN(  97)					while((_g3 < _g4)){
HXLINE(  97)						_g3 = (_g3 + 1);
HXDLIN(  97)						int j = (_g3 - 1);
HXDLIN(  97)						_g2->push(::cpp::VirtualArray( a->__get(j))->__get(i));
            					}
            				}
HXDLIN(  97)				_g->push(_g2);
            			}
            		}
HXDLIN(  97)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mat_obj,transposeN,return )

::Array< Float > Mat_obj::solve(::Array< ::Dynamic> A,::Array< Float > b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_103_solve)
HXDLIN( 103)		return ::verb::core::Mat_obj::LUsolve(::verb::core::Mat_obj::LU(A),b);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,solve,return )

::Array< Float > Mat_obj::LUsolve( ::verb::core::_Mat::LUDecomp LUP,::Array< Float > b){
            	HX_STACKFRAME(&_hx_pos_9d236faa95ce82cb_108_LUsolve)
HXLINE( 109)		int j;
HXLINE( 110)		::Array< ::Dynamic> LU = LUP->LU;
HXLINE( 111)		int n = LU->length;
HXLINE( 112)		::Array< Float > x = b->copy();
HXLINE( 113)		::Array< int > P = LUP->P;
HXLINE( 114)		int Pi;
HXDLIN( 114)		::Array< Float > LUi;
HXDLIN( 114)		 ::Dynamic LUii;
HXDLIN( 114)		Float tmp;
HXLINE( 109)		int i = (n - 1);
HXLINE( 117)		while((i != -1)){
HXLINE( 118)			x[i] = b->__get(i);
HXLINE( 119)			i = (i - 1);
            		}
HXLINE( 122)		i = 0;
HXLINE( 123)		while((i < n)){
HXLINE( 124)			Pi = P->__get(i);
HXLINE( 125)			if ((P->__get(i) != i)) {
HXLINE( 126)				tmp = x->__get(i);
HXLINE( 127)				x[i] = x->__get(Pi);
HXLINE( 128)				x[Pi] = tmp;
            			}
HXLINE( 131)			LUi = LU->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 132)			j = 0;
HXLINE( 133)			while((j < i)){
HXLINE( 134)				::Array< Float > x1 = x;
HXDLIN( 134)				int i1 = i;
HXDLIN( 134)				x1[i1] = (x1->__get(i1) - (x->__get(j) * LUi->__get(j)));
HXLINE( 135)				j = (j + 1);
            			}
HXLINE( 137)			i = (i + 1);
            		}
HXLINE( 140)		i = (n - 1);
HXLINE( 141)		while((i >= 0)){
HXLINE( 142)			LUi = LU->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 143)			j = (i + 1);
HXLINE( 144)			while((j < n)){
HXLINE( 145)				::Array< Float > x1 = x;
HXDLIN( 145)				int i1 = i;
HXDLIN( 145)				x1[i1] = (x1->__get(i1) - (x->__get(j) * LUi->__get(j)));
HXLINE( 146)				j = (j + 1);
            			}
HXLINE( 149)			::Array< Float > x1 = x;
HXDLIN( 149)			int i1 = i;
HXDLIN( 149)			x1[i1] = (x1->__get(i1) / LUi->__get(i));
HXLINE( 150)			i = (i - 1);
            		}
HXLINE( 153)		return x;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Mat_obj,LUsolve,return )

 ::verb::core::_Mat::LUDecomp Mat_obj::LU(::Array< ::Dynamic> A){
            	HX_GC_STACKFRAME(&_hx_pos_9d236faa95ce82cb_158_LU)
HXLINE( 160)		 ::Dynamic abs = ::Math_obj::abs_dyn();
HXLINE( 161)		int i;
HXDLIN( 161)		int j;
HXDLIN( 161)		Float absAjk;
HXDLIN( 161)		Float Akk;
HXDLIN( 161)		::Array< Float > Ak;
HXDLIN( 161)		int Pk;
HXDLIN( 161)		::Array< Float > Ai;
HXLINE( 162)		Float max;
HXLINE( 164)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 164)		{
HXLINE( 164)			int _g1 = 0;
HXDLIN( 164)			int _g2 = A->length;
HXDLIN( 164)			while((_g1 < _g2)){
HXLINE( 164)				_g1 = (_g1 + 1);
HXDLIN( 164)				int i = (_g1 - 1);
HXDLIN( 164)				_g->push(A->__get(i).StaticCast< ::Array< Float > >()->copy());
            			}
            		}
HXDLIN( 164)		A = _g;
HXLINE( 165)		int n = A->length;
HXDLIN( 165)		int n1 = (n - 1);
HXLINE( 166)		::Array< int > P = ::Array_obj< int >::__new();
HXLINE( 161)		int k = 0;
HXLINE( 169)		while((k < n)){
HXLINE( 170)			Pk = k;
HXLINE( 171)			Ak = A->__get(k).StaticCast< ::Array< Float > >();
HXLINE( 172)			max = ::Math_obj::abs(Ak->__get(k));
HXLINE( 174)			j = (k + 1);
HXLINE( 175)			while((j < n)){
HXLINE( 176)				absAjk = ::Math_obj::abs(A->__get(j).StaticCast< ::Array< Float > >()->__get(k));
HXLINE( 177)				if ((max < absAjk)) {
HXLINE( 178)					max = absAjk;
HXLINE( 179)					Pk = j;
            				}
HXLINE( 181)				j = (j + 1);
            			}
HXLINE( 183)			P[k] = Pk;
HXLINE( 185)			if ((Pk != k)) {
HXLINE( 186)				A[k] = A->__get(Pk).StaticCast< ::Array< Float > >();
HXLINE( 187)				A[Pk] = Ak;
HXLINE( 188)				Ak = A->__get(k).StaticCast< ::Array< Float > >();
            			}
HXLINE( 191)			Akk = Ak->__get(k);
HXLINE( 193)			i = (k + 1);
HXLINE( 194)			while((i < n)){
HXLINE( 195)				::Array< Float > A1 = A->__get(i).StaticCast< ::Array< Float > >();
HXDLIN( 195)				int k1 = k;
HXDLIN( 195)				A1[k1] = (A1->__get(k1) / Akk);
HXLINE( 196)				i = (i + 1);
            			}
HXLINE( 199)			i = (k + 1);
HXLINE( 200)			while((i < n)){
HXLINE( 201)				Ai = A->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 202)				j = (k + 1);
HXLINE( 203)				while((j < n1)){
HXLINE( 204)					::Array< Float > Ai1 = Ai;
HXDLIN( 204)					int j1 = j;
HXDLIN( 204)					Ai1[j1] = (Ai1->__get(j1) - (Ai->__get(k) * Ak->__get(j)));
HXLINE( 205)					j = (j + 1);
HXLINE( 206)					::Array< Float > Ai2 = Ai;
HXDLIN( 206)					int j2 = j;
HXDLIN( 206)					Ai2[j2] = (Ai2->__get(j2) - (Ai->__get(k) * Ak->__get(j)));
HXLINE( 207)					j = (j + 1);
            				}
HXLINE( 209)				if ((j == n1)) {
HXLINE( 209)					::Array< Float > Ai1 = Ai;
HXDLIN( 209)					int j1 = j;
HXDLIN( 209)					Ai1[j1] = (Ai1->__get(j1) - (Ai->__get(k) * Ak->__get(j)));
            				}
HXLINE( 210)				i = (i + 1);
            			}
HXLINE( 213)			k = (k + 1);
            		}
HXLINE( 216)		return  ::verb::core::_Mat::LUDecomp_obj::__alloc( HX_CTX ,A,P);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mat_obj,LU,return )


Mat_obj::Mat_obj()
{
}

bool Mat_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"LU") ) { outValue = LU_dyn(); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"mul") ) { outValue = mul_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"add") ) { outValue = add_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"div") ) { outValue = div_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sub") ) { outValue = sub_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dot") ) { outValue = dot_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mult") ) { outValue = mult_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"solve") ) { outValue = solve_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"LUsolve") ) { outValue = LUsolve_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"identity") ) { outValue = identity_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"transpose") ) { outValue = transpose_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"transposeN") ) { outValue = transposeN_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Mat_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Mat_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Mat_obj::__mClass;

static ::String Mat_obj_sStaticFields[] = {
	HX_("mul",04,1c,53,00),
	HX_("mult",f0,67,65,48),
	HX_("add",21,f2,49,00),
	HX_("div",51,3d,4c,00),
	HX_("sub",80,a9,57,00),
	HX_("dot",89,42,4c,00),
	HX_("identity",3e,45,2f,b9),
	HX_("transpose",79,50,2f,4c),
	HX_("transposeN",b5,19,37,5d),
	HX_("solve",7f,bf,c5,80),
	HX_("LUsolve",56,ac,7a,d5),
	HX_("LU",89,42,00,00),
	::String(null())
};

void Mat_obj::__register()
{
	Mat_obj _hx_dummy;
	Mat_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.core.Mat",a0,89,49,ff);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Mat_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Mat_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Mat_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Mat_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Mat_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace core
