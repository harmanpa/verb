// Generated by Haxe 4.1.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_verb_core_BoundingBox
#include <verb/core/BoundingBox.h>
#endif
#ifndef INCLUDED_verb_core_Constants
#include <verb/core/Constants.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_bd1733fd2e780abe_13_new,"verb.core.BoundingBox","new",0xd658c479,"verb.core.BoundingBox.new","verb/core/BoundingBox.hx",13,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_47_fromPoint,"verb.core.BoundingBox","fromPoint",0x30e52b5f,"verb.core.BoundingBox.fromPoint","verb/core/BoundingBox.hx",47,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_62_add,"verb.core.BoundingBox","add",0xd64ee63a,"verb.core.BoundingBox.add","verb/core/BoundingBox.hx",62,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_93_addRange,"verb.core.BoundingBox","addRange",0x4bef5d23,"verb.core.BoundingBox.addRange","verb/core/BoundingBox.hx",93,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_114_contains,"verb.core.BoundingBox","contains",0x1aedeb66,"verb.core.BoundingBox.contains","verb/core/BoundingBox.hx",114,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_158_intersects,"verb.core.BoundingBox","intersects",0x411a73bb,"verb.core.BoundingBox.intersects","verb/core/BoundingBox.hx",158,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_181_clear,"verb.core.BoundingBox","clear",0x60985de6,"verb.core.BoundingBox.clear","verb/core/BoundingBox.hx",181,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_192_getLongestAxis,"verb.core.BoundingBox","getLongestAxis",0xc63dc19c,"verb.core.BoundingBox.getLongestAxis","verb/core/BoundingBox.hx",192,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_218_getAxisLength,"verb.core.BoundingBox","getAxisLength",0xa83a9df6,"verb.core.BoundingBox.getAxisLength","verb/core/BoundingBox.hx",218,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_234_intersect,"verb.core.BoundingBox","intersect",0xf8418db8,"verb.core.BoundingBox.intersect","verb/core/BoundingBox.hx",234,0xc9d37177)
HX_LOCAL_STACK_FRAME(_hx_pos_bd1733fd2e780abe_137_intervalsOverlap,"verb.core.BoundingBox","intervalsOverlap",0x101925e0,"verb.core.BoundingBox.intervalsOverlap","verb/core/BoundingBox.hx",137,0xc9d37177)
namespace verb{
namespace core{

void BoundingBox_obj::__construct(::Array< ::Dynamic> pts){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_13_new)
HXLINE(  34)		this->max = null();
HXLINE(  31)		this->min = null();
HXLINE(  16)		this->dim = 3;
HXLINE(  15)		this->initialized = false;
HXLINE(  25)		if (::hx::IsNotNull( pts )) {
HXLINE(  26)			this->addRange(pts);
            		}
            	}

Dynamic BoundingBox_obj::__CreateEmpty() { return new BoundingBox_obj; }

void *BoundingBox_obj::_hx_vtable = 0;

Dynamic BoundingBox_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BoundingBox_obj > _hx_result = new BoundingBox_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool BoundingBox_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x019feaa9;
}

 ::verb::core::BoundingBox BoundingBox_obj::fromPoint(::Array< Float > pt){
            	HX_GC_STACKFRAME(&_hx_pos_bd1733fd2e780abe_47_fromPoint)
HXDLIN(  47)		return  ::verb::core::BoundingBox_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,pt));
            	}


HX_DEFINE_DYNAMIC_FUNC1(BoundingBox_obj,fromPoint,return )

 ::verb::core::BoundingBox BoundingBox_obj::add(::Array< Float > point){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_62_add)
HXLINE(  63)		if (!(this->initialized)) {
HXLINE(  65)			this->dim = point->length;
HXLINE(  66)			this->min = point->slice(0,null());
HXLINE(  67)			this->max = point->slice(0,null());
HXLINE(  68)			this->initialized = true;
HXLINE(  70)			return ::hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE(  73)		{
HXLINE(  73)			int _g = 0;
HXDLIN(  73)			int _g1 = this->dim;
HXDLIN(  73)			while((_g < _g1)){
HXLINE(  73)				_g = (_g + 1);
HXDLIN(  73)				int i = (_g - 1);
HXLINE(  74)				if ((point->__get(i) > this->max->__get(i))) {
HXLINE(  74)					this->max[i] = point->__get(i);
            				}
HXLINE(  75)				if ((point->__get(i) < this->min->__get(i))) {
HXLINE(  75)					this->min[i] = point->__get(i);
            				}
            			}
            		}
HXLINE(  78)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(BoundingBox_obj,add,return )

 ::verb::core::BoundingBox BoundingBox_obj::addRange(::Array< ::Dynamic> points){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_93_addRange)
HXLINE(  94)		int l = points->length;
HXLINE(  96)		{
HXLINE(  96)			int _g = 0;
HXDLIN(  96)			int _g1 = l;
HXDLIN(  96)			while((_g < _g1)){
HXLINE(  96)				_g = (_g + 1);
HXDLIN(  96)				int i = (_g - 1);
HXLINE(  97)				this->add(points->__get(i).StaticCast< ::Array< Float > >());
            			}
            		}
HXLINE( 100)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(BoundingBox_obj,addRange,return )

bool BoundingBox_obj::contains(::Array< Float > point,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_bd1733fd2e780abe_114_contains)
HXLINE( 116)		if (!(this->initialized)) {
HXLINE( 118)			return false;
            		}
HXLINE( 121)		return this->intersects( ::verb::core::BoundingBox_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,point)),tol);
            	}


HX_DEFINE_DYNAMIC_FUNC2(BoundingBox_obj,contains,return )

bool BoundingBox_obj::intersects( ::verb::core::BoundingBox bb,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(-1);
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_158_intersects)
HXLINE( 160)		bool _hx_tmp;
HXDLIN( 160)		if (this->initialized) {
HXLINE( 160)			_hx_tmp = !(bb->initialized);
            		}
            		else {
HXLINE( 160)			_hx_tmp = true;
            		}
HXDLIN( 160)		if (_hx_tmp) {
HXLINE( 160)			return false;
            		}
HXLINE( 162)		::Array< Float > a1 = this->min;
HXDLIN( 162)		::Array< Float > a2 = this->max;
HXDLIN( 162)		::Array< Float > b1 = bb->min;
HXDLIN( 162)		::Array< Float > b2 = bb->max;
HXLINE( 167)		{
HXLINE( 167)			int _g = 0;
HXDLIN( 167)			int _g1 = this->dim;
HXDLIN( 167)			while((_g < _g1)){
HXLINE( 167)				_g = (_g + 1);
HXDLIN( 167)				int i = (_g - 1);
HXLINE( 168)				if (!(::verb::core::BoundingBox_obj::intervalsOverlap(a1->__get(i),a2->__get(i),b1->__get(i),b2->__get(i),tol))) {
HXLINE( 168)					return false;
            				}
            			}
            		}
HXLINE( 171)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(BoundingBox_obj,intersects,return )

 ::verb::core::BoundingBox BoundingBox_obj::clear(){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_181_clear)
HXLINE( 182)		this->initialized = false;
HXLINE( 183)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(BoundingBox_obj,clear,return )

int BoundingBox_obj::getLongestAxis(){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_192_getLongestAxis)
HXLINE( 194)		Float max = ((Float)0.0);
HXLINE( 195)		int id = 0;
HXLINE( 197)		{
HXLINE( 197)			int _g = 0;
HXDLIN( 197)			int _g1 = this->dim;
HXDLIN( 197)			while((_g < _g1)){
HXLINE( 197)				_g = (_g + 1);
HXDLIN( 197)				int i = (_g - 1);
HXLINE( 198)				Float l = this->getAxisLength(i);
HXLINE( 199)				if ((l > max)) {
HXLINE( 200)					max = l;
HXLINE( 201)					id = i;
            				}
            			}
            		}
HXLINE( 205)		return id;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BoundingBox_obj,getLongestAxis,return )

Float BoundingBox_obj::getAxisLength(int i){
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_218_getAxisLength)
HXLINE( 219)		bool _hx_tmp;
HXDLIN( 219)		if ((i >= 0)) {
HXLINE( 219)			_hx_tmp = (i > (this->dim - 1));
            		}
            		else {
HXLINE( 219)			_hx_tmp = true;
            		}
HXDLIN( 219)		if (_hx_tmp) {
HXLINE( 219)			return ((Float)0.0);
            		}
HXLINE( 220)		return ::Math_obj::abs((this->min->__get(i) - this->max->__get(i)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(BoundingBox_obj,getAxisLength,return )

 ::verb::core::BoundingBox BoundingBox_obj::intersect( ::verb::core::BoundingBox bb,Float tol){
            	HX_GC_STACKFRAME(&_hx_pos_bd1733fd2e780abe_234_intersect)
HXLINE( 236)		if (!(this->initialized)) {
HXLINE( 236)			return null();
            		}
HXLINE( 238)		::Array< Float > a1 = this->min;
HXDLIN( 238)		::Array< Float > a2 = this->max;
HXDLIN( 238)		::Array< Float > b1 = bb->min;
HXDLIN( 238)		::Array< Float > b2 = bb->max;
HXLINE( 243)		if (!(this->intersects(bb,tol))) {
HXLINE( 243)			return null();
            		}
HXLINE( 245)		::Array< Float > maxbb = ::Array_obj< Float >::__new(0);
HXDLIN( 245)		::Array< Float > minbb = ::Array_obj< Float >::__new(0);
HXLINE( 248)		{
HXLINE( 248)			int _g = 0;
HXDLIN( 248)			int _g1 = this->dim;
HXDLIN( 248)			while((_g < _g1)){
HXLINE( 248)				_g = (_g + 1);
HXDLIN( 248)				int i = (_g - 1);
HXLINE( 249)				maxbb->push(::Math_obj::min(a2->__get(i),b2->__get(i)));
HXLINE( 250)				minbb->push(::Math_obj::max(a1->__get(i),b1->__get(i)));
            			}
            		}
HXLINE( 253)		return  ::verb::core::BoundingBox_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,minbb)->init(1,maxbb));
            	}


HX_DEFINE_DYNAMIC_FUNC2(BoundingBox_obj,intersect,return )

bool BoundingBox_obj::intervalsOverlap(Float a1,Float a2,Float b1,Float b2,::hx::Null< Float >  __o_tol){
            		Float tol = __o_tol.Default(-1);
            	HX_STACKFRAME(&_hx_pos_bd1733fd2e780abe_137_intervalsOverlap)
HXLINE( 139)		Float tol1;
HXDLIN( 139)		if ((tol < ((Float)-0.5))) {
HXLINE( 139)			tol1 = ::verb::core::Constants_obj::TOLERANCE;
            		}
            		else {
HXLINE( 139)			tol1 = tol;
            		}
HXDLIN( 139)		Float x1 = (::Math_obj::min(a1,a2) - tol1);
HXDLIN( 139)		Float x2 = (::Math_obj::max(a1,a2) + tol1);
HXDLIN( 139)		Float y1 = (::Math_obj::min(b1,b2) - tol1);
HXDLIN( 139)		Float y2 = (::Math_obj::max(b1,b2) + tol1);
HXLINE( 145)		bool _hx_tmp;
HXDLIN( 145)		bool _hx_tmp1;
HXDLIN( 145)		bool _hx_tmp2;
HXDLIN( 145)		if ((x1 >= y1)) {
HXLINE( 145)			_hx_tmp2 = (x1 <= y2);
            		}
            		else {
HXLINE( 145)			_hx_tmp2 = false;
            		}
HXDLIN( 145)		if (!(_hx_tmp2)) {
HXLINE( 145)			if ((x2 >= y1)) {
HXLINE( 145)				_hx_tmp1 = (x2 <= y2);
            			}
            			else {
HXLINE( 145)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXLINE( 145)			_hx_tmp1 = true;
            		}
HXDLIN( 145)		if (!(_hx_tmp1)) {
HXLINE( 145)			if ((y1 >= x1)) {
HXLINE( 145)				_hx_tmp = (y1 <= x2);
            			}
            			else {
HXLINE( 145)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 145)			_hx_tmp = true;
            		}
HXDLIN( 145)		if (!(_hx_tmp)) {
HXLINE( 145)			if ((y2 >= x1)) {
HXLINE( 145)				return (y2 <= x2);
            			}
            			else {
HXLINE( 145)				return false;
            			}
            		}
            		else {
HXLINE( 145)			return true;
            		}
HXDLIN( 145)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(BoundingBox_obj,intervalsOverlap,return )


::hx::ObjectPtr< BoundingBox_obj > BoundingBox_obj::__new(::Array< ::Dynamic> pts) {
	::hx::ObjectPtr< BoundingBox_obj > __this = new BoundingBox_obj();
	__this->__construct(pts);
	return __this;
}

::hx::ObjectPtr< BoundingBox_obj > BoundingBox_obj::__alloc(::hx::Ctx *_hx_ctx,::Array< ::Dynamic> pts) {
	BoundingBox_obj *__this = (BoundingBox_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(BoundingBox_obj), true, "verb.core.BoundingBox"));
	*(void **)__this = BoundingBox_obj::_hx_vtable;
	__this->__construct(pts);
	return __this;
}

BoundingBox_obj::BoundingBox_obj()
{
}

void BoundingBox_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BoundingBox);
	HX_MARK_MEMBER_NAME(initialized,"initialized");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(min,"min");
	HX_MARK_MEMBER_NAME(max,"max");
	HX_MARK_END_CLASS();
}

void BoundingBox_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(initialized,"initialized");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(min,"min");
	HX_VISIT_MEMBER_NAME(max,"max");
}

::hx::Val BoundingBox_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		if (HX_FIELD_EQ(inName,"min") ) { return ::hx::Val( min ); }
		if (HX_FIELD_EQ(inName,"max") ) { return ::hx::Val( max ); }
		if (HX_FIELD_EQ(inName,"add") ) { return ::hx::Val( add_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clear") ) { return ::hx::Val( clear_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addRange") ) { return ::hx::Val( addRange_dyn() ); }
		if (HX_FIELD_EQ(inName,"contains") ) { return ::hx::Val( contains_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromPoint") ) { return ::hx::Val( fromPoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"intersect") ) { return ::hx::Val( intersect_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"intersects") ) { return ::hx::Val( intersects_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"initialized") ) { return ::hx::Val( initialized ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getAxisLength") ) { return ::hx::Val( getAxisLength_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getLongestAxis") ) { return ::hx::Val( getLongestAxis_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool BoundingBox_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 16:
		if (HX_FIELD_EQ(inName,"intervalsOverlap") ) { outValue = intervalsOverlap_dyn(); return true; }
	}
	return false;
}

::hx::Val BoundingBox_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"min") ) { min=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"max") ) { max=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"initialized") ) { initialized=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BoundingBox_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("initialized",14,f5,0f,37));
	outFields->push(HX_("dim",48,3d,4c,00));
	outFields->push(HX_("min",92,11,53,00));
	outFields->push(HX_("max",a4,0a,53,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo BoundingBox_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(BoundingBox_obj,initialized),HX_("initialized",14,f5,0f,37)},
	{::hx::fsInt,(int)offsetof(BoundingBox_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(BoundingBox_obj,min),HX_("min",92,11,53,00)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(BoundingBox_obj,max),HX_("max",a4,0a,53,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *BoundingBox_obj_sStaticStorageInfo = 0;
#endif

static ::String BoundingBox_obj_sMemberFields[] = {
	HX_("initialized",14,f5,0f,37),
	HX_("dim",48,3d,4c,00),
	HX_("min",92,11,53,00),
	HX_("max",a4,0a,53,00),
	HX_("fromPoint",86,9e,18,7b),
	HX_("add",21,f2,49,00),
	HX_("addRange",dc,cb,7c,5d),
	HX_("contains",1f,5a,7b,2c),
	HX_("intersects",b4,c2,eb,e3),
	HX_("clear",8d,71,5b,48),
	HX_("getLongestAxis",15,81,94,45),
	HX_("getAxisLength",9d,30,44,11),
	HX_("intersect",df,00,75,42),
	::String(null()) };

::hx::Class BoundingBox_obj::__mClass;

static ::String BoundingBox_obj_sStaticFields[] = {
	HX_("intervalsOverlap",99,75,39,22),
	::String(null())
};

void BoundingBox_obj::__register()
{
	BoundingBox_obj _hx_dummy;
	BoundingBox_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("verb.core.BoundingBox",07,14,b5,2d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &BoundingBox_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(BoundingBox_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(BoundingBox_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< BoundingBox_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BoundingBox_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BoundingBox_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace verb
} // end namespace core
