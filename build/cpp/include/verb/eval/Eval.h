// Generated by Haxe 4.1.4
#ifndef INCLUDED_verb_eval_Eval
#define INCLUDED_verb_eval_Eval

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS2(verb,core,NurbsCurveData)
HX_DECLARE_CLASS2(verb,core,NurbsSurfaceData)
HX_DECLARE_CLASS2(verb,core,Pair)
HX_DECLARE_CLASS2(verb,core,SerializableBase)
HX_DECLARE_CLASS2(verb,core,VolumeData)
HX_DECLARE_CLASS2(verb,eval,Eval)

namespace verb{
namespace eval{


class HXCPP_CLASS_ATTRIBUTES Eval_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef Eval_obj OBJ_;
		Eval_obj();

	public:
		enum { _hx_ClassId = 0x7ac88223 };

		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="verb.eval.Eval")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,false,"verb.eval.Eval"); }

		inline static ::hx::ObjectPtr< Eval_obj > __new() {
			::hx::ObjectPtr< Eval_obj > __this = new Eval_obj();
			__this->__construct();
			return __this;
		}

		inline static ::hx::ObjectPtr< Eval_obj > __alloc(::hx::Ctx *_hx_ctx) {
			Eval_obj *__this = (Eval_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Eval_obj), false, "verb.eval.Eval"));
			*(void **)__this = Eval_obj::_hx_vtable;
			return __this;
		}

		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~Eval_obj();

		HX_DO_RTTI_ALL;
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		static void __register();
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("Eval",bc,97,f5,2d); }

		static ::Array< Float > rationalCurveTangent( ::verb::core::NurbsCurveData curve,Float u);
		static ::Dynamic rationalCurveTangent_dyn();

		static ::Array< Float > rationalSurfaceNormal( ::verb::core::NurbsSurfaceData surface,Float u,Float v);
		static ::Dynamic rationalSurfaceNormal_dyn();

		static ::Array< ::Dynamic> rationalSurfaceDerivatives( ::verb::core::NurbsSurfaceData surface,Float u,Float v,::hx::Null< int >  numDerivs);
		static ::Dynamic rationalSurfaceDerivatives_dyn();

		static ::Array< Float > rationalSurfacePoint( ::verb::core::NurbsSurfaceData surface,Float u,Float v);
		static ::Dynamic rationalSurfacePoint_dyn();

		static ::Array< ::Dynamic> rationalCurveDerivatives( ::verb::core::NurbsCurveData curve,Float u,::hx::Null< int >  numDerivs);
		static ::Dynamic rationalCurveDerivatives_dyn();

		static ::Array< Float > rationalCurvePoint( ::verb::core::NurbsCurveData curve,Float u);
		static ::Dynamic rationalCurvePoint_dyn();

		static ::Array< ::Dynamic> surfaceDerivatives( ::verb::core::NurbsSurfaceData surface,Float u,Float v,int numDerivs);
		static ::Dynamic surfaceDerivatives_dyn();

		static ::Array< ::Dynamic> surfaceDerivativesGivenNM(int n,int m, ::verb::core::NurbsSurfaceData surface,Float u,Float v,int numDerivs);
		static ::Dynamic surfaceDerivativesGivenNM_dyn();

		static ::Array< Float > surfacePoint( ::verb::core::NurbsSurfaceData surface,Float u,Float v);
		static ::Dynamic surfacePoint_dyn();

		static ::Array< Float > surfacePointGivenNM(int n,int m, ::verb::core::NurbsSurfaceData surface,Float u,Float v);
		static ::Dynamic surfacePointGivenNM_dyn();

		static ::Array< ::Dynamic> curveRegularSamplePoints( ::verb::core::NurbsCurveData crv,int divs);
		static ::Dynamic curveRegularSamplePoints_dyn();

		static ::Array< ::Dynamic> curveRegularSamplePoints2( ::verb::core::NurbsCurveData crv,int divs);
		static ::Dynamic curveRegularSamplePoints2_dyn();

		static ::Array< ::Dynamic> rationalSurfaceRegularSampleDerivatives( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV,int numDerivs);
		static ::Dynamic rationalSurfaceRegularSampleDerivatives_dyn();

		static ::Array< ::Dynamic> surfaceRegularSampleDerivatives( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV,int numDerivs);
		static ::Dynamic surfaceRegularSampleDerivatives_dyn();

		static ::Array< ::Dynamic> rationalSurfaceRegularSamplePoints( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV);
		static ::Dynamic rationalSurfaceRegularSamplePoints_dyn();

		static ::Array< ::Dynamic> surfaceRegularSamplePoints( ::verb::core::NurbsSurfaceData surface,int divsU,int divsV);
		static ::Dynamic surfaceRegularSamplePoints_dyn();

		static  ::verb::core::Pair regularlySpacedBasisFunctions(int degree,::Array< Float > knots,int divs);
		static ::Dynamic regularlySpacedBasisFunctions_dyn();

		static  ::verb::core::Pair regularlySpacedDerivativeBasisFunctions(int degree,::Array< Float > knots,int divs);
		static ::Dynamic regularlySpacedDerivativeBasisFunctions_dyn();

		static ::Array< Float > surfacePointGivenBasesKnotSpans(int degreeU,int degreeV,::Array< ::Dynamic> controlPoints,int knotSpanU,int knotSpanV,::Array< Float > basesU,::Array< Float > basesV,int dim);
		static ::Dynamic surfacePointGivenBasesKnotSpans_dyn();

		static ::Array< ::Dynamic> surfaceDerivativesGivenBasesKnotSpans(int degreeU,int degreeV,::Array< ::Dynamic> controlPoints,int knotSpanU,int knotSpanV,::Array< ::Dynamic> basesU,::Array< ::Dynamic> basesV,int dim,int numDerivs);
		static ::Dynamic surfaceDerivativesGivenBasesKnotSpans_dyn();

		static ::Array< ::Dynamic> curveDerivatives( ::verb::core::NurbsCurveData crv,Float u,int numDerivs);
		static ::Dynamic curveDerivatives_dyn();

		static ::Array< ::Dynamic> curveDerivativesGivenN(int n, ::verb::core::NurbsCurveData curve,Float u,int numDerivs);
		static ::Dynamic curveDerivativesGivenN_dyn();

		static ::Array< Float > curvePoint( ::verb::core::NurbsCurveData curve,Float u);
		static ::Dynamic curvePoint_dyn();

		static bool areValidRelations(int degree,int num_controlPoints,int knots_length);
		static ::Dynamic areValidRelations_dyn();

		static ::Array< Float > curvePointGivenN(int n, ::verb::core::NurbsCurveData curve,Float u);
		static ::Dynamic curvePointGivenN_dyn();

		static ::Array< Float > volumePoint( ::verb::core::VolumeData volume,Float u,Float v,Float w);
		static ::Dynamic volumePoint_dyn();

		static ::Array< Float > volumePointGivenNML( ::verb::core::VolumeData volume,int n,int m,int l,Float u,Float v,Float w);
		static ::Dynamic volumePointGivenNML_dyn();

		static ::Array< ::Dynamic> derivativeBasisFunctions(Float u,int degree,::Array< Float > knots);
		static ::Dynamic derivativeBasisFunctions_dyn();

		static ::Array< ::Dynamic> derivativeBasisFunctionsGivenNI(int knotIndex,Float u,int p,int n,::Array< Float > knots);
		static ::Dynamic derivativeBasisFunctionsGivenNI_dyn();

		static ::Array< Float > basisFunctions(Float u,int degree,::Array< Float > knots);
		static ::Dynamic basisFunctions_dyn();

		static ::Array< Float > basisFunctionsGivenKnotSpanIndex(int knotSpan_index,Float u,int degree,::Array< Float > knots);
		static ::Dynamic basisFunctionsGivenKnotSpanIndex_dyn();

		static int knotSpan(int degree,Float u,::Array< Float > knots);
		static ::Dynamic knotSpan_dyn();

		static int knotSpanGivenN(int n,int degree,Float u,::Array< Float > knots);
		static ::Dynamic knotSpanGivenN_dyn();

		static ::Array< Float > dehomogenize(::Array< Float > homoPoint);
		static ::Dynamic dehomogenize_dyn();

		static ::Array< ::Dynamic> rational1d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic rational1d_dyn();

		static ::Array< ::Dynamic> rational2d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic rational2d_dyn();

		static ::Array< Float > weight1d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic weight1d_dyn();

		static ::Array< ::Dynamic> weight2d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic weight2d_dyn();

		static ::Array< ::Dynamic> dehomogenize1d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic dehomogenize1d_dyn();

		static ::Array< ::Dynamic> dehomogenize2d(::Array< ::Dynamic> homoPoints);
		static ::Dynamic dehomogenize2d_dyn();

		static ::Array< ::Dynamic> homogenize1d(::Array< ::Dynamic> controlPoints,::Array< Float > weights);
		static ::Dynamic homogenize1d_dyn();

		static ::Array< ::Dynamic> homogenize2d(::Array< ::Dynamic> controlPoints,::Array< ::Dynamic> weights);
		static ::Dynamic homogenize2d_dyn();

};

} // end namespace verb
} // end namespace eval

#endif /* INCLUDED_verb_eval_Eval */ 
