// Generated by Haxe 4.1.4
#ifndef INCLUDED_verb_core_Vec
#define INCLUDED_verb_core_Vec

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS2(verb,core,Vec)

namespace verb{
namespace core{


class HXCPP_CLASS_ATTRIBUTES Vec_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef Vec_obj OBJ_;
		Vec_obj();

	public:
		enum { _hx_ClassId = 0x1772c5f6 };

		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="verb.core.Vec")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,false,"verb.core.Vec"); }

		inline static ::hx::ObjectPtr< Vec_obj > __new() {
			::hx::ObjectPtr< Vec_obj > __this = new Vec_obj();
			__this->__construct();
			return __this;
		}

		inline static ::hx::ObjectPtr< Vec_obj > __alloc(::hx::Ctx *_hx_ctx) {
			Vec_obj *__this = (Vec_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Vec_obj), false, "verb.core.Vec"));
			*(void **)__this = Vec_obj::_hx_vtable;
			return __this;
		}

		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~Vec_obj();

		HX_DO_RTTI_ALL;
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		static void __register();
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("Vec",34,9a,41,00); }

		static Float angleBetween(::Array< Float > a,::Array< Float > b);
		static ::Dynamic angleBetween_dyn();

		static Float positiveAngleBetween(::Array< Float > a,::Array< Float > b,::Array< Float > n);
		static ::Dynamic positiveAngleBetween_dyn();

		static Float signedAngleBetween(::Array< Float > a,::Array< Float > b,::Array< Float > n);
		static ::Dynamic signedAngleBetween_dyn();

		static Float angleBetweenNormalized2d(::Array< Float > a,::Array< Float > b);
		static ::Dynamic angleBetweenNormalized2d_dyn();

		static Float domain(::Array< Float > a);
		static ::Dynamic domain_dyn();

		static ::Array< Float > range(int max);
		static ::Dynamic range_dyn();

		static ::Array< Float > span(Float min,Float max,Float step);
		static ::Dynamic span_dyn();

		static ::Array< Float > neg(::Array< Float > arr);
		static ::Dynamic neg_dyn();

		static Float min(::Array< Float > arr);
		static ::Dynamic min_dyn();

		static Float max(::Array< Float > arr);
		static ::Dynamic max_dyn();

		static bool all(::Array< bool > arr);
		static ::Dynamic all_dyn();

		static ::Array< bool > finite(::Array< Float > arr);
		static ::Dynamic finite_dyn();

		static ::Array< Float > onRay(::Array< Float > origin,::Array< Float > dir,Float u);
		static ::Dynamic onRay_dyn();

		static ::Array< Float > lerp(Float i,::Array< Float > u,::Array< Float > v);
		static ::Dynamic lerp_dyn();

		static ::Array< Float > normalized(::Array< Float > arr);
		static ::Dynamic normalized_dyn();

		static ::Array< Float > cross(::Array< Float > u,::Array< Float > v);
		static ::Dynamic cross_dyn();

		static Float dist(::Array< Float > a,::Array< Float > b);
		static ::Dynamic dist_dyn();

		static Float distSquared(::Array< Float > a,::Array< Float > b);
		static ::Dynamic distSquared_dyn();

		static Float sum(::Array< Float > a);
		static ::Dynamic sum_dyn();

		static ::Array< Float > addAll( ::Dynamic a);
		static ::Dynamic addAll_dyn();

		static void addAllMutate(::Array< ::Dynamic> a);
		static ::Dynamic addAllMutate_dyn();

		static void addMulMutate(::Array< Float > a,Float s,::Array< Float > b);
		static ::Dynamic addMulMutate_dyn();

		static void subMulMutate(::Array< Float > a,Float s,::Array< Float > b);
		static ::Dynamic subMulMutate_dyn();

		static void addMutate(::Array< Float > a,::Array< Float > b);
		static ::Dynamic addMutate_dyn();

		static void subMutate(::Array< Float > a,::Array< Float > b);
		static ::Dynamic subMutate_dyn();

		static void mulMutate(Float a,::Array< Float > b);
		static ::Dynamic mulMutate_dyn();

		static Float norm(::Array< Float > a);
		static ::Dynamic norm_dyn();

		static Float normSquared(::Array< Float > a);
		static ::Dynamic normSquared_dyn();

		static ::cpp::VirtualArray rep(int num, ::Dynamic ele);
		static ::Dynamic rep_dyn();

		static ::Array< Float > fill(int num,Float ele);
		static ::Dynamic fill_dyn();

		static ::Array< Float > zeros1d(int rows);
		static ::Dynamic zeros1d_dyn();

		static ::Array< ::Dynamic> zeros2d(int rows,int cols);
		static ::Dynamic zeros2d_dyn();

		static ::Array< ::Dynamic> zeros3d(int rows,int cols,int depth);
		static ::Dynamic zeros3d_dyn();

		static Float dot(::Array< Float > a,::Array< Float > b);
		static ::Dynamic dot_dyn();

		static ::Array< Float > add(::Array< Float > a,::Array< Float > b);
		static ::Dynamic add_dyn();

		static ::Array< Float > mul(Float a,::Array< Float > b);
		static ::Dynamic mul_dyn();

		static ::Array< Float > div(::Array< Float > a,Float b);
		static ::Dynamic div_dyn();

		static ::Array< Float > sub(::Array< Float > a,::Array< Float > b);
		static ::Dynamic sub_dyn();

		static bool isZero(::Array< Float > vec);
		static ::Dynamic isZero_dyn();

		static ::Array< Float > sortedSetUnion(::Array< Float > a,::Array< Float > b);
		static ::Dynamic sortedSetUnion_dyn();

		static ::Array< Float > sortedSetSub(::Array< Float > a,::Array< Float > b);
		static ::Dynamic sortedSetSub_dyn();

};

} // end namespace verb
} // end namespace core

#endif /* INCLUDED_verb_core_Vec */ 
